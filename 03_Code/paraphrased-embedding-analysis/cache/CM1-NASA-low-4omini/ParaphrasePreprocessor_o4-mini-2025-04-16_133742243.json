{"6306ea9a-5e36-3db6-9888-08f5f65849a5":"Memory uploads and downloads can target various locations—DRAM, EEPROM, hardware registers, or the EEPROM filesystem. The D_MEM_DAT_UPLD command designates which destination to use. When the EEPROM filesystem is chosen, a block number replaces the memory address; the DPU FSW then constructs a filename of the form eefs1:DPU_blk.##, where ## is the block number. After the DPU FSW receives all of the uploaded data, it writes the data to that file in the EEPROM filesystem, overwriting any existing file with the same name. To reinitialize the EEPROM filesystem, the D_MEM_DISK_INIT command is used.","35c05af7-4ad3-3aff-9fef-1ca76b881940":"The global data items accessed by this CSC.","aee05ebe-70d6-3fa6-bf04-908fed5ee77b":"Commands are taken from the Command Queue and run by the Command Dispatch Task, ccmCmdTask(), which waits on a semaphore released by ccmCmdEnq(). When the semaphore is given, ccmCmdTask() wakes and calls ccmCmdProcess() to handle any pending commands. ccmCmdProcess() pulls each command from the queue and hands it off to ccmCmdDispatch(), which checks its length and executes it. If command echo is turned on, ccmCmdDispatch() invokes ccmHkMkCmdEcho() to send the command back to the ground station. The system keeps counters for both executed and rejected commands. If ccmCmdEnq() receives a 1 Hz Clock Time message or a spacecraft Attitude message, these are not queued but are processed immediately in interrupt context: Attitude messages go to dpaCommandSend(), and 1 Hz Clock Time messages call tisTimeSync() to update the system time. Any other messages not originating from the DPU or spacecraft observatory are dropped silently. To ensure ccmCmdTask() still reports its status to the CCM Control Task even when no ground commands arrive, the semaphore has a 20 second timeout. If this timeout expires, ccmCmdTask() checks that the Command Queue is empty and then calls ccmTaskReport() to report in.","277f0370-f6a2-3ae9-a75e-2683d446a347":"To support control and monitoring, the DPU generates eight distinct types of housekeeping packets.","b05d66ed-652d-3c73-8ee7-881ee2f59cee":"This routine retrieves the TMALI CSC’s housekeeping data, including certain DCI parameters, and then resets its internal counters to zero. If the caller passes a NIL pointer for the TMALI_HK structure, no data is returned but the counters are still cleared. Two of the four error counters are updated inside an ISR, so they must be safe across task switches. Although VxWorks could handle this with a counting semaphore, the TMALI CSC instead uses a free-running error counter plus an extra temporary variable to update the reported count. Because 32-bit unsigned increments and assignments are atomic, the counters remain task-safe and no error events are lost. As a result, tmaliHkGet() always reports a total error count that matches the actual number of errors that occurred.","46a47c92-0a83-34be-b468-1143774393e2":"The optimal frame depth will be established through benchmark testing, with the default set to 10 frames. Based on the data above, reading ten maximum-sized frames at the highest transfer rate takes about 24 ms.","f0cc222b-4d06-3f55-a85f-77b8cc1b5e0e":"Commands are pulled from the Command Queue and handled by ccmCmdTask(), which waits on a semaphore released by ccmCmdEnq(). When the semaphore is given, ccmCmdTask() calls ccmCmdProcess() to fetch queued commands and hands them to ccmCmdDispatch(), which verifies each command’s length and executes it. If command echo is enabled, ccmCmdDispatch() calls ccmHkMkCmdEcho() to send the command back to the ground. The system maintains counts of executed and rejected commands. If a 1 Hz Clock Time message or an Attitude message arrives, it bypasses the queue and is executed immediately in interrupt context—Attitude messages go to dpaCommandSend() and Clock Time parameters go to tisTimeSync() for time synchronization. Any other non-DPU or non-spacecraft observatory messages are silently discarded. To ensure ccmCmdTask() still reports in to the CCM Control Task even when no ground commands arrive, the semaphore has a 20 second timeout. If it expires and the queue is empty, ccmCmdTask() calls ccmTaskReport().","b3d600d2-cf3e-35e7-ba9d-73e1b90b302a":"Memory uploads and downloads can target DRAM, EEPROM, hardware registers, or the EEPROM filesystem. The D_MEM_DAT_UPLD command designates the destination. When the EEPROM filesystem is selected, a block number is supplied instead of a memory address, and the DPU FSW uses it to construct a filename in the form eefs1:DPU_blk.##, where ## is the block number. Once all data has been received, the DPU FSW writes it to that file, overwriting any existing file with the same name. The EEPROM filesystem can be reinitialized with the D_MEM_DISK_INIT command.","1ca8a9c9-d97c-38e2-8e1a-72241ec0228b":"The DCI’s hardware windowing feature is enabled and managed via tmaliDciWindowSet(), which activates it and sends the specified window parameters to the DCI driver.","1d34025f-a3fb-3da6-a26f-4725c52ac084":"Commands are retrieved from the Command Queue and executed by ccmCmdTask(), which blocks on a semaphore released by ccmCmdEnq(). When the semaphore is given, ccmCmdTask() wakes up and calls ccmCmdProcess() to pull waiting commands from the queue and hand them off to ccmCmdDispatch(), where each command’s length is checked before execution. If command echo is enabled, ccmCmdDispatch() calls ccmHkMkCmdEcho() to send the command back to the ground. Counts of executed and rejected commands are maintained. If ccmCmdEnq() receives a 1 Hz Clock Time message or a spacecraft Attitude message, these are not queued but are executed immediately in the interrupt context: Attitude messages are passed to dpaCommandSend(), and 1 Hz Clock Time parameters go to tisTimeSync() for time synchronization. All other non-DPU or non-observatory messages are discarded without error. To ensure ccmCmdTask() periodically checks in with the CCM Control Task even when no ground commands arrive, the semaphore wait times out after 20 seconds; on timeout, the task verifies the Command Queue is empty and calls ccmTaskReport().","d2a9c9b3-60a4-33ea-8be0-b9c583f74036":"This function allows setting the DCI data timeout in milliseconds. Its initial value is defined by the parameter passed when tmaliTask starts. The timeout cannot exceed X seconds; if a larger value is requested, it defaults to X milliseconds.","7798b768-904b-396f-bc02-a6ee2e167bdf":"If more than 65,535 bytes must be uploaded, break the file into chunks of at most 65,535 bytes and send each chunk in sequence. The DPU flight software uses sequence numbers, so it can accept these chunks in any order. There is no time limit on completing a single chunk upload, allowing a long upload to continue across ground contacts. At any time, you may send the highest sequence number to the DPU FSW, and it will issue event S_ccm_MISSING_SEQNO listing any missing chunks. To cancel an upload in progress, send the D_MEM_DAT_CNCL command.","5bd67670-29bd-3756-928e-ba01196ad5f0":"When all events in the Ping-Pong buffer have been delivered to the TMALI_EVENT_QUEUE, tamliTask() must re-arm the hardware so it can swap the buffers when ready. If TMALI fails to transfer all the data from the ping buffer before the pong buffer fills, the DCI driver triggers an error interrupt and calls tmaliDciErrorReportedISR(). That ISR sets an error flag so tamliTask() can recover and posts the semDciWait semaphore to wake tamliTask()—even if it’s already running—because it may have just finished a transfer at the moment of the error. The error is also counted in TMALI_HK. Meanwhile, the DCI hardware drops new events until tamliTask() completes the previous transfer, sees the error flag, forces a manual Ping-Pong swap, and re-enables data acquisition. This guarantees only complete frames enter the Ping-Pong buffer for processing. Normally this error should not occur, since the TMALI task should keep up with the DCI Ping-Pong buffer. If events still accumulate faster than they can be handled, the TMALI queue will fill and trigger an S_TMALI_QUEUE_FULL error via ccmErrEnq().","0c11996b-fb22-3be5-96a2-18b6f06945d3":"When uploading more than 65 535 bytes, the data must be split into chunks no larger than 65 535 bytes and each chunk sent in order as a separate virtual upload. Because each chunk carries its own sequence number, the DPU flight software may receive them out of order. There is no time limit on completing any single virtual upload, so a long transfer can span multiple ground contacts. At any point during an upload, sending the final sequence number to the DPU FSW causes it to issue event S_ccm_MISSING_SEQNO listing any missing sequence numbers. To cancel an upload in progress, issue the D_MEM_DAT_CNCL command to discard it.","417ed1bc-9a98-352d-acbe-4d904941bfe1":"The CCM Control Task also processes memory dump requests. When a dump command is received, it divides the data into smaller chunks and outputs one chunk each time it is activated. This deferred approach ensures that a large dump does not tie up CPU resources or keep the high-priority CCM Command Dispatch Task occupied for too long.","6adfb5cd-a367-38c7-8bea-79d1726faac7":"This routine lets you configure the DCI data timeout in milliseconds. The initial frame depth value comes from the parameter given when tmaliTask is started. If you request a timeout exceeding X seconds, it resets to the default of X milliseconds.","975b1774-03bf-336c-ae7e-ffff46169a9d":"In the normal data exchange process, the TMALI CSC acts as an intermediary for EVENT data provided by the DCI Driver CSC and ultimately passed on to the DPA CSC. It waits for a notification from the DCI CSC indicating that the Ping-Pong buffer has hit its frame limit or timed out, which means the EVENT data is ready. TMALI then reads all available EVENT data from the DCI, informs the DCI that it may swap the Ping-Pong buffers when convenient, and releases a semaphore to unblock the tmaliWait() call from the DPA.","1668125c-e5cf-3214-9a19-ff08fc6a3b2c":"The bit layout of the DCI control/status register can be configured using tmaliBitArrangementSet().","2888db66-3ffd-3485-8be8-8076a586865f":"The Command and Control (CCM) CSC is a Level 2 reusable component from the INSTRUMENT Y project that consists of two main tasks and several key data structures. The first task, ccmCtrlTask(), initializes the DPU flight software, spawns other tasks at startup, schedules the creation of DPU housekeeping data packets, monitors the execution of those tasks, and arranges periodic functions such as the heartbeat message and watchdog strobe. The second task, ccmCmdTask(), receives real-time commands from the SCU or ICU and dispatches them for execution. The component’s primary data structures include a static data table that tracks the operational state—such as housekeeping rates, CCM-specific flags, and the number of executed commands—a command queue that stores incoming commands via interrupt from the ICU or SCU, and an error/event queue that accumulates error and event codes reported by the DPU flight software for periodic inclusion in telemetry packets within the housekeeping data.","768cf777-831a-396b-9e3b-bb5bbb33eb6f":"The D_MEM_BLK_DNLD command retrieves the contents of a file stored in the EEPROM filesystem by simply supplying its block number, which is used to form the filename and download the entire file. To download data from any other location, the D_MEM_DAT_DNLD command is used. Downloads are performed in a deferred manner to minimize CPU usage. On the ground, what appears as a single logical download actually arrives as a sequence of packets whose data must be extracted and concatenated to reconstruct the original data.","16a7704a-c956-39ff-8892-04bd43b8537b":"Each DPU FSW task invokes this routine to report its execution, allowing ccmCtrlTask() to assess the health of the DPU FSW execution.","0b4fdce4-7b8d-3d19-a419-465409ed34ca":"The Telescope Module Access Library and Interface CSC is responsible for managing the detector event queue and offers an API that allows data processing algorithms to retrieve detector events from that queue.","28868435-794f-3114-b1ec-087d07f42f87":"This public function is invoked by each DPU FSW task to signal its execution, allowing ccmCtrlTask() to assess the health of the DPU FSW.","a56431fb-e16d-3fbe-9fa7-9b728a5d9301":"When large blocks of memory must be sent to the DPU—such as for a software patch or full upload—the standard memory upload process is used. This involves sending multiple D_MEM_DAT_UPLD commands that together form a single logical upload. CCSDS-style grouping flags let the DPU flight software accept up to 65,535 bytes in one logical upload. Data from each D_MEM_DAT_UPLD command is held in a temporary DRAM buffer until every sequence number has arrived. When the final command is received, the flight software checks that no sequence numbers are missing, verifies the end-to-end checksum, and then writes the complete buffer to the target address specified in the first command.","034821fa-e846-3d5f-a712-2cab3aab6cc4":"Events are retrieved from the TMALI_EVENT_QUEUE by the DPA CSC using two API functions, tmaliWait() and tmaliNextEvent(). To improve efficiency, tmaliNextEvent() is inlined to eliminate per‐event call overhead, each event is stored in a register and fully processed there before the next event is retrieved, and tmaliNextEvent() omits error checking, so the DPA CSC must keep track of how many events it has retrieved compared to the number returned by tmaliWait().","bcaee947-f60d-3f12-9aab-b7e9b783e9ea":"This routine is invoked by the MIL-STD-1553 Command ISR and the SSI Interface ISR whenever a command is received from the SCU or ICU, enqueues the command, and wakes up the CCM Command Dispatch Task for execution.","caf39fb3-5550-3e2d-9d7b-0a369f1b0948":"Use the tmaliBitArrangementSet() function to configure the bit arrangement of the DCI control/status register.","95fb044f-2046-38f0-b241-fe9fa977900b":"The ideal frame depth is established through benchmark testing, with 10 frames as the default setting; based on the data above, reading 10 maximum-sized frames at peak transfer rate requires about 24 ms.","6181127f-57bb-3d6c-a693-895ee3b0d075":"The DPU-CCM CSC offers a centralized error-reporting API, ccmErrEnq(), that other FSW tasks call to log errors. Whenever ccmTask() wakes, it checks if it’s time to assemble an error/event packet for downlink. If so, ccmTask() invokes ccmHkMkError() to build the packet and hand it off to DPU-SCUI for transmission to the ground.","f2635035-8f10-32de-92f0-2695c9288a4a":"The CSC maintains a FIFO ring buffer to temporarily hold data received from the DCI before it is processed. Two pointers, pIn and pOut, track where data enters and exits the buffer and are arranged so that reading requires only a single comparison to check if the buffer is empty. The buffer holds only four-byte Events, so the pointers reference these four-byte units. Because the DCI specifies all sizes in bytes, size values must be converted before reading data.","98f777a5-8d50-3772-a55b-abd45958b813":"The TMALI CSC acts as an intermediary for EVENT data sent by the DCI Driver CSC and passed on to the DPA CSC. It waits for the DCI CSC to signal that a frame limit or data timeout has occurred in the ping-pong buffer, indicating that the EVENT data is ready. TMALI then reads all the EVENT data from the DCI and notifies the DCI that it may swap the ping-pong buffers when convenient. Finally, TMALI releases a semaphore to unblock the tmaliWait() call in the DPA.","31310305-81b9-3860-b8d7-087a5e789bd6":"This routine retrieves the current data timeout value used by the DCI and returns it in milliseconds. The timeout is detailed in document 036911400, section 4.3.2.4.1.3.","aaf7e356-ab47-30aa-961f-d572d4844469":"The global data elements accessed by this CSC.","7a992a5c-644e-38f2-bece-ed0322d17445":"There are two methods to upload data to the DPU: the D_MEM_DAT_POKE command or the D_MEM_DAT_UPLD command. The D_MEM_DAT_POKE command is used to insert small amounts of data (up to Z bytes) into a DPU memory location, with the Z-byte limit set by Company X’s command length restriction.","b35d2bcd-847d-397a-92ad-b8714eac445f":"The CCM Control Task starts the DPU flight software by launching the SCU Interface Task and the CCM Command Task, then waits on temporary semaphores with five‐second timeouts. If both tasks release their semaphores to signal successful initialization, the Control Task toggles the BC_INDEX bit in EEPROM to mark a successful boot; if either task fails to signal, it disables the watchdog strobe to force a DPU reboot. These two tasks are the minimum required for ground contact and commandability. After boot, the Control Task blocks on a binary semaphore provided by the SCUI Command ISR whenever a 1 Hz Clock Message arrives; if no message appears within 1.5 seconds, the semaphore times out. The Control Task then remains active to generate and transmit DPU housekeeping data at the proper intervals, carry out periodic processing, and handle memory dump commands. Finally, it calls ccmErrEnq() so that any error occurring in an interrupt service routine sets a global errno and is enqueued into the Error/Event Queue during this task’s normal execution.","426b5ffc-f36a-383f-a8f0-d419a106007b":"In the normal data exchange sequence, the DPA CSC calls tmaliWait() to find out how many EVENTS are pending; if tmaliWait() returns a number above zero, the DPA then calls tmaliNextEvent() for each pending EVENT to retrieve it.","5c0f562d-28e5-327c-9721-b08cf6ecc5d3":"This function obtains the current frame depth of the Ping-Pong buffers used by the DCI CSC, defining how many frames are loaded into a buffer before an interrupt is generated. The initial depth is set by the parameter supplied when starting the tmaliTask. The value returned is the active setting, which may differ from the most recently commanded depth until that command takes effect when data moves from the hardware Ping-Pong buffer to the TMALI queue in response to a frame or timeout interrupt (see section 5.13.2.3).","3c62a5be-6021-3217-bbf6-e225d1e89e3b":"Whenever the CCM Control task runs, it invokes ccmPerProcess() to perform periodic duties such as updating analog-to-digital conversions, monitoring DPU tasks, generating ICU heartbeat messages, and stroking the watchdog. Inside ccmPerProcess(), ccmHealthChk() verifies that each task has run recently by tracking the time since its last report. Tasks report their activity by calling ccmTaskReport() with their assigned index. Each task has a target execution rate, and if a task misses its expected run, a DPU housekeeping error is recorded. If the Command Dispatch Task goes unreported for an extended period, the DPU initiates a reboot—since it cannot be controlled without that task—otherwise it simply strobes the watchdog.","0b4bb7d4-ab4a-3536-807b-cdeb5579a6bd":"The tmaliDciFrameDepthSet command defines how many frames the DCI CSC’s ping-pong buffers will read before triggering an interrupt. The initial depth comes from the parameter passed when starting tmaliTask. You cannot request more than 64 frames; any command above that limit causes the frame depth to revert to the default value of V frames. The actual update may be delayed briefly if the DCI bus is busy, and it typically takes effect right after the DCI reports a frame-level reached or timeout event to avoid changing settings when hardware is close to detecting a frame. Changing the depth while the DCI CSC is actively processing data can lead to unpredictable behavior. If a new tmaliDciFrameDepthSet command is issued before the previous setting becomes active, the new request replaces the pending one and is applied at the first available opportunity.","3bffeba3-2c78-3628-ab1e-e8ad0e595c1d":"The tmaliHkGet() routine retrieves the TMALI CSC housekeeping data, including certain DCI parameters, and then resets all internal TMALI counters to zero. If the caller supplies a NIL pointer for a TMALI_HK structure, no data is returned but the counters are still reset. Two of the four error counters are incremented in an ISR context, so they need a task‐safe implementation. Instead of using a VxWorks counting semaphore, the TMALI CSC employs a free‐running error counter and a temporary variable to update the reported counts. Because 32-bit unsigned integer increments and assignments are atomic, the counters remain task‐safe and no error events are lost. Consequently, the total errors reported by tmaliHkGet() exactly match the actual number of errors that occurred.","47c13b41-538f-356c-a7de-59ca84d0b120":"When a command arrives from the SCU via the 1553 interface or from the ICU via the SSI interface, the corresponding ISR enqueues the command packet into a Command Queue and posts the semaphore to wake the ccmCmdTask(). Because the DPU can send commands to itself, commands may arrive in either interrupt context or task context, so the CCM uses two queues—one without semaphore protection for interrupt context and one with semaphore protection for task context.","27da15c7-49e5-3552-b1bd-24108986cbc1":"The MIL-STD-1553 Command ISR and the SSI Interface ISR invoke this routine whenever they receive a command from the SCU or ICU, enqueuing the command and waking the CCM Command Dispatch Task to execute it.","b6952139-6807-33af-96a9-132935531439":"The TMALI CSC is initialized by launching tmaliTask() with its default startup parameters; this task allocates memory for the TMALI_EVENT_QUEUE, installs the DCI ISRs, initializes static variables and data structures, and then enters an endless loop that transfers data from the DCI to the TMALI queue, throttled by the semDciWait semaphore.","a4ab6f19-21a3-3628-aae7-c94df16a968c":"During system startup, the operating system’s initial task, usrRoot(), launches the CCM Control Task (ccmCtrlTask()). Upon startup, this task invokes ccmInit(), which establishes the error/event queue, creates necessary semaphores, and installs various interrupt service routines, then spawns the remaining tasks for the DPU flight software. As it runs, the CCM Control Task retrieves DPU configuration defaults from the EEPROM’s SYSTEM_CONFIG_AREA, falling back on built-in defaults if the checksum is invalid. It then initializes each remaining CSC either by calling its specific initialization function or, for those with dedicated tasks, by using VxWorks’ taskSpawn(), supplying the EEPROM-read defaults as parameters. Additionally, ccmInit() calls ccmCmdLengthInit() to build the command length verification table that the command processor uses to check incoming command sizes.","538575b2-0798-3439-bfdf-f36375d23a83":"The TMALI CSC is initialized by launching tmaliTask() with the default startup parameters. This task allocates memory for the TMALI_EVENT_QUEUE, installs the DCI interrupt service routines, initializes all static variables and data structures, and then enters an endless loop that moves data from the DCI into the TMALI queue, paced by the semDciWait semaphore.","45df9dde-c99f-350d-a122-05fe7505d99d":"This routine sets the DCI’s bit arrangement: when bSpecialArrangement is TRUE, it enables special arrangement mode; otherwise, it applies the default mode with no rearrangement.","94ed76a0-77c2-3757-bea5-779e473c08aa":"Every time the CCM Control runs, it calls ccmPerProcess() to carry out periodic duties such as updating analog-to-digital conversions, monitoring DPU tasks, producing ICU heartbeat messages, and strobing the watchdog. Inside ccmPerProcess(), ccmHealthChk() ensures other tasks have executed by checking how long it’s been since each last reported. Tasks report their execution by calling ccmTaskReport() with their task index. Each task must run at an expected frequency, and if one misses its schedule, an error is recorded in DPU housekeeping. If the Command Dispatch Task goes unreported for too long, the DPU reboots—since it can’t be commanded otherwise—otherwise it strobes the watchdog.","c15544ec-0a76-3779-8098-5095d8b1a935":"The ccmErrEnq() function keeps track of the most recent error code and how many times it occurs in a row. Once an error is logged, it becomes the “previous error,” and each identical error that follows increments a repeat counter. If the same error appears more than once during a single high-rate housekeeping interval, ccmErrEnq() enqueues a special S_ccm_ERR_REPEAT error, with the repeat count stored in its least significant byte. This prevents housekeeping telemetry from being overwhelmed by a flood of the same error.","5233365f-9b83-3955-ba6b-6538d1f40a91":"This routine is invoked by the MIL-STD-1553 Command ISR at 1 Hz (upon receiving the Clock Message) to release the semaphore and wake the CCM Control Task, which remains blocked after finishing its processing.","135782dc-e228-3b2c-9534-6f645acae157":"This routine lets you configure the DCI’s bit arrangement: when bSpecialArrangement is TRUE, it uses the special arrangement, otherwise it uses the default no-rearrangement mode.","2a21cd73-14d9-37e7-bcb7-a8425e6a95b2":"This function retrieves the frame depth of the DCI CSC’s Ping-Pong buffers. The frame depth specifies how many frames are loaded into the selected Ping-Pong buffer before an interrupt is generated. Its initial value is set by the parameter supplied when starting the tmaliTask. The returned depth is the currently active setting, which may differ from the last requested value because changes take effect only when data moves from the hardware Ping-Pong buffer into the TMALI queue in response to a frame or timeout interrupt (see section 5.13.2.3).","09b45c48-1774-3677-a22b-8637ceeb5f69":"The DCI’s hardware windowing capability can be activated and managed by calling tmaliDciWindowSet(), which triggers the hardware windowing function and passes the specified window parameters to the DCI driver.","979afca3-c229-34d2-b89c-3d0901eecbea":"This routine is invoked by the MIL-STD-1553 Command ISR at 1 Hz upon receipt of the Clock Message to release the semaphore and wake the CCM Control Task, which remains blocked after completing its processing.","9d071f3e-dd42-33c1-86ee-afa2e3812ba2":"Once tamliTask() has moved all events from the Ping-Pong buffer into TMALI_EVENT_QUEUE, it must rearm the hardware to swap buffers when ready. If the ping buffer isn’t cleared before the pong buffer fills, the DCI driver issues an error interrupt that calls tmaliDciErrorReportedISR(). That ISR sets an error flag so tamliTask() can recover and posts semDciWait to wake tamliTask()—even if it’s already active—to handle the error. It also increments the error count in TMALI_HK. Meanwhile, the DCI hardware discards new events until tamliTask() finishes the pending transfer, sees the error flag, forces a manual Ping-Pong swap, and restarts data acquisition. This ensures only complete frames reach the Ping-Pong buffer for processing. Normally this error shouldn’t occur because tamliTask() should keep up with incoming data; if it can’t, the TMALI queue fills and an S_TMALI_QUEUE_FULL error is logged via ccmErrEnq().","25827c10-2881-3b70-9724-65b4b4d6d11c":"The Data Processing Unit receives commands through two interfaces—MIL-STD-1553 from the spacecraft control unit and SSI from the instrument control unit. Any DPU command can originate from either the SCU or the ICU, whether generated onboard or sent from the ground; specifically, commands may be generated and sent by the ICU via SSI, generated and sent by the SCU via 1553, generated on the ground and relayed through the ICU/SSI, or generated on the ground and relayed through the SCU/1553.","15da4c28-a24a-3049-8edf-8ac8575ea61a":"The D_MEM_BLK_DNLD command retrieves data from a file in the EEPROM filesystem. Like its upload counterpart, it requires only a block number, which is used to form the filename, and then the full file contents are downloaded. For downloading from any other memory location, the D_MEM_DAT_DNLD command is used. Downloads are performed asynchronously to minimize CPU usage. On the ground, each logical download appears as multiple packets whose payloads must be extracted and concatenated in sequence to reconstruct the original data.","6485ce43-484d-38ea-a03e-0ba343c56744":"The ccmErrEnq() function keeps track of the most recent error code and how many times it occurs in a row. When an error is reported, it becomes the “previous” error and each immediately repeating occurrence increases a repetition counter. If that same error appears more than once within a single high-rate housekeeping interval, the function enqueues a special error code, S_ccm_ERR_REPEAT, with the repetition count stored in its least significant byte. This prevents housekeeping telemetry from being flooded by a single repeated error.","2d98be0f-c7df-3dec-82a6-ade1a628100b":"The CCM Control Task starts up the DPU flight software by launching the SCU Interface Task and the CCM Command Task, then waits on two temporary semaphores (each with a five-second timeout) to confirm their initialization. If both tasks signal success, the Control Task toggles the BC_INDEX parameter in EEPROM to record a successful boot; if either fails, it disables the watchdog strobe to trigger a DPU reboot. These two tasks are the minimum required for ground contact and commandability. Once initialization is confirmed, the Control Task blocks on a binary semaphore released by the SCUI Command ISR when the 1 Hz Clock Message arrives, timing out after 1.5 seconds if the message is missing. Thereafter the Control Task remains active to generate and transmit DPU housekeeping at scheduled intervals, carry out periodic processing, and handle memory dump commands. Finally, it calls ccmErrEnq() so that any errno set by an interrupt service routine is enqueued into the Error/Event Queue during its normal processing.","14846b9d-d5bd-32d2-9f02-ee41e8a3797b":"Events are retrieved from the TMALI_EVENT_QUEUE by the DPA CSC using an API of two functions, tmaliWait() and tmaliNextEvent(). To maximize efficiency, the DPA CSC inlines tmaliNextEvent() to eliminate function-call overhead, loads each event into a register and completes its processing there before fetching the next event, and—since tmaliNextEvent() performs no error checking—tracks the number of events retrieved against the count returned by tmaliWait().","80150773-c06a-3d3f-9935-9d4bcca2bc9a":"The TMALI CSC collects housekeeping data and makes it available through the tmaliHkGet() call, returning the information in a TMALI_HK data structure.","663c1163-fd4e-35e2-abb6-4c47fc49bdd4":"To prevent error counts from rolling over, ccmErrEnq verifies that no error exceeds 250 occurrences in a single high-rate housekeeping reporting period; if an error’s count exceeds 250, it enqueues an S_ccm_ERR_REPEAT error with the current count and resets its error tracking.","1c2e1322-c61a-31cf-9e15-8e3947ca0a16":"The Telescope Module Access Library and Interface (TMALI) CSC controls the detector event queue and offers an API through which data processing algorithms can retrieve the queued detector events.","1e60d487-9892-3a18-a02b-4e5d7aa64259":"Public Functions This function is called by the MIL-STD-1553 Command ISR once per second upon receipt of the Clock Message to wake the CCM Control Task, which is blocked on a semaphore after finishing its processing.","e74f9800-7d16-3e6b-b471-427abfb20195":"This routine retrieves the TMALI CSC’s stored housekeeping data, including certain DCI parameters, and then resets the internal TMALI counters to zero. If the caller’s TMALI_HK pointer is NIL, no data is returned but the counters are still cleared. Two of the four error counters are updated in an ISR, so they must be task‐switch safe. Rather than using a counting semaphore as in VxWorks, the TMALI CSC employs a free-running error counter plus a temporary variable to compute the reported error count. Because 32-bit unsigned integer increments and assignments are atomic, this approach is task safe and guarantees that the total errors reported exactly match the actual errors, with no events lost.","d6b7acb6-fab6-3142-a91d-709b94733e22":"Whenever the CCM Control task runs, it calls ccmPerProcess() to perform its periodic duties—updating analog-to-digital conversions, monitoring DPU tasks, producing ICU heartbeat messages, and stroking the watchdog. Inside ccmPerProcess(), ccmHealthChk() ensures each task has executed by checking how much time has passed since its last report. Tasks report their execution to CCM Control by calling ccmTaskReport() with their task index. Each task must meet its expected execution frequency; if a task misses its deadline, a DPU housekeeping error is logged. If the Command Dispatch Task goes unreported for an extended period, the DPU triggers a reboot—since commands cannot be accepted without that task—otherwise it strobes the watchdog.","207c506d-8917-34dd-8465-51972c8f0d7c":"This function provides a way to configure and activate DCI hardware windowing parameters for data acquisition. It verifies the supplied window specification before telling the DCI driver to update the hardware. If the specification is invalid, it returns an error and leaves windowing disabled; otherwise, it applies the requested window settings and enables the hardware windowing feature.","0607f776-bfb5-30d9-8da4-255be7ea627c":"This function can be invoked by any CSC to record an error or event for inclusion in DPU housekeeping. When called from an interrupt context, it sets a static global flag (ccmISRError) so the error can be queued later (see ccmCtrlTask()), since the error/event queue is protected by a semaphore that cannot be taken inside an ISR. The semaphore uses priority inheritance to minimize conflicts if multiple callers contend and a priority inversion occurs. In addition, if an error repeats frequently within a high-rate reporting interval, it is replaced by a special “repeat” error code that follows the original error code to indicate the repeated occurrences.","182934c6-09d7-31b0-a5df-fc581c7f1a81":"ccmErrEnq() can also be invoked from an interrupt context, where taking a semaphore on the Error Queue is illegal. To work around this, the error code is stored in the global variable ccmISRerror, and the error is actually enqueued when ccmTask() next runs. If more than one error occurs in interrupt context before ccmTask() executes, only the last error is preserved and earlier ones are overwritten.","6c8b8d9e-3d7e-3d38-82cd-1e9d335fd296":"The TMALI CSC comprises a ring-buffer–based queue, TMALI_EVENT_QUEUE, that holds detector events received from the DCI driver until they are fetched by the DPA CSC. The CSC provides an event retrieval API—tmaliNextEvent() and tmaliWait()—for the DPA CSC. It also offers configuration functions for the DCI interface: tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet(), and tmaliDataTimeoutGet(). A housekeeping function, tmaliHkGet(), gathers CSC status data when requested by the Command and Control Task. The task tmaliTask() and the ISR tmaliTransferToQueueISR() use a semaphore to coordinate moving data from the DCI into the queue. An error-handling ISR, tmaliDciErrorReportedISR(), is registered with the DCI driver to track the number of errors it reports.","294a7051-ebd2-3120-95f0-4cc834f4b194":"This function retrieves the frame depth of the DCI CSC’s Ping-Pong buffers. The frame depth specifies how many frames are loaded into the selected Ping-Pong buffer before an interrupt occurs. Its initial value is set by the parameter given when starting the tmaliTask. The returned value is the current active setting, which may differ from the last commanded setting because changes only take effect when data moves from the hardware Ping-Pong buffer to the TMALI queue in response to a frame or timeout interrupt (see section 5.13.2.3).","a26057b2-789e-3057-aa8a-a6628ac484fc":"When tmaliTransferToQueueISR() runs, it gives a semaphore to wake tmaliTask(), which then moves data onto the queue over the VME bus. tmaliTask() calls the DCI driver’s read() routine, a high-speed assembly transfer. Because the TMALI ring buffer is an array, tmaliTask() first inspects TMALI_EVENT_QUEUE to decide if all data in the DCI buffer can be read in one call or if two calls are needed to handle buffer wrap-around. It also checks that enough space exists in the Ping-Pong buffer to hold the incoming data. If there isn’t room for a complete set of frames, tmaliTask() throws away the entire readable Ping-Pong buffer and logs S_TMALI_QUEUE_FULL via ccmErrEnq. Discarded data always represents whole CCD frames, since the hardware aligns Ping-Pong switches with frame boundaries. Dropping the newer frames in this way preserves the scientifically more valuable data collected immediately after a burst.","3fedffab-ecd8-364a-8ef0-41e406f67349":"The ccmErrEnq() function keeps track of the most recent error and how many times it repeats. Whenever an error code is reported, it becomes the “previous” error, and each time the same code appears consecutively, a repeat counter is increased. If the same error shows up more than once during a single high-rate housekeeping interval, the function queues a special error code, S_ccm_ERR_REPEAT, with the repeat count placed in the least significant byte. This approach prevents the housekeeping telemetry from being overloaded by a single recurring error.","9094754e-cf4a-3fb7-8159-25d10c9e18ae":"The ccmErrEnq() function can also be invoked from an interrupt context. Since it’s illegal to take a semaphore during an interrupt, the Error Queue’s mutual-exclusion mechanism cannot be used there. Instead, the appropriate error code is stored in the global variable ccmISRerror, and that error is enqueued the next time ccmTask() runs. Because only a single code can be held in ccmISRerror, if more than one error occurs before ccmTask() executes, the earlier error will be overwritten by the later one.","7b1d1f25-6ff8-348c-b6bf-5f1705716a0f":"Data can be loaded into the DPU either with the D_MEM_DAT_POKE command (Memory Poke) or the D_MEM_DAT_UPLD command (Memory Upload). The Memory Poke command is intended for inserting small amounts of data—up to Z bytes—into a DPU memory location, with the Z-byte limit imposed by Company X’s command length restriction.","a78cb0f7-4a56-315b-9707-9d1a999b9433":"The CCM Control Task also processes memory dump requests. When a dump command is received, it divides the data into smaller chunks and outputs one chunk each time it is activated. This deferred approach ensures that a large dump does not monopolize CPU resources or keep the high-priority CCM Command Dispatch Task occupied for too long.","13a33233-e355-37f6-af42-e3c52ef4a137":"The global data items that this CSC accesses.","abb354a7-50a8-3ce4-ba91-99c573f53939":"When called, if the TMALI queue is empty the function blocks on a semaphore until the ISR signals that events are available. If data is already in the queue or the semaphore is taken immediately, it counts and returns the number of events in the TMALI queue. The TickstoWait parameter specifies how long, in kernel ticks, the function may block; it can be set to the symbolic value FOREVER, causing the function to wait indefinitely until data arrives. If a finite timeout is used and no data appears within that period, the function returns zero. If the TMALI task has not been initialized, the function returns an error.","144eb452-93dc-337a-a715-b8f0f85648fe":"The DPU receives commands through two interfaces: MIL-STD-1553 from the Spacecraft and SSI from the ICU. Any DPU command may originate at either the SCU or the ICU. Commands can come directly from the ICU via SSI, directly from the SCU via 1553, from the ground via the ICU (G-ICU), or from the ground via the SCU (G-SCU).","47b32ee5-d3c0-3863-b2d3-2eabc3b0fd23":"At boot, no Error Queue exists until it’s created, so any errors occurring during this phase are recorded in the global task variable errno. For details on errno, see VxWorks® Programmer’s Guide, section 2.3.7. Once the Error Queue is created, any errno set thereafter is enqueued by calling ccmErrEnq().","00ea49ee-4bb7-391c-9764-6de09ffe3fae":"The DCI control/status register’s bit arrangement is configurable via the tmaliBitArrangementSet() function.","ed97367d-60ae-37b7-a0bc-1d9d617425cc":"The TMALI CSC includes a ring-buffer queue (TMALI_EVENT_QUEUE) that holds detector events received from the DCI Driver until the DPA CSC retrieves them; an API (tmaliNextEvent() and tmaliWait()) for the DPA CSC to pull events from that queue; a set of DCI interface configuration calls (tmaliBitArrangementSet(), tmaliDciFrameDepthGet()/Set(), tmaliDciWindowSet(), tmaliDataTimeoutSet()/Get()); a housekeeping function (tmaliHkGet()) that supplies CSC status data on demand from the Command and Control Task; the tmaliTask() thread and the tmaliTransferToQueueISR() interrupt routine, which use a semaphore to synchronize moving data from the DCI into the queue; and an error-handling ISR (tmaliDciErrorReportedISR()) registered with the DCI Driver to track its error count.","42e4ddf0-576a-3f3a-a5b2-5f6ae43043ad":"Data can be loaded into the DPU in two ways: via Memory Poke (D_MEM_DAT_POKE) for small writes of up to Z bytes, or via Memory Upload (D_MEM_DAT_UPLD) for larger transfers. The Z-byte limit on the poke command stems from Company X’s maximum command length restriction.","406d5983-3c5c-3633-9e68-6ca9d74eb433":"This routine is invoked by any CSC to log an error or event for inclusion in DPU housekeeping. When called from an interrupt context, it sets the static global variable ccmISRError so that the error can be enqueued later (see ccmCtrlTask()). This deferral is necessary because the error/event queue is protected by a semaphore, which cannot be taken in an ISR. The queue’s semaphore uses priority inheritance to minimize conflicts among multiple callers in the event of priority inversion. The routine also consolidates repeated errors by issuing a special repeat error code after the initial error code to indicate that the same error has occurred more than once during the last high‐rate reporting period.","1ccc0f44-d7cb-363b-8daa-42c9cbda4e48":"When tmaliTransferToQueueISR() is triggered, it releases a semaphore to wake tmaliTask(), which then transfers data onto the queue over the VME bus. tmaliTask() invokes the DCI driver’s read() function, which uses a high-speed assembly routine. Because the TMALI ring buffer is an array, tmaliTask() must first inspect TMALI_EVENT_QUEUE to decide if all the data in the DCI buffer can be read in one call or if two calls are needed to handle wrap-around at the buffer’s end. It must also check that there is enough free space to receive the entire Ping-Pong buffer; if there isn’t, it discards the Ping-Pong buffer’s contents and reports S_TMALI_QUEUE_FULL via ccmErrEnq. Since the hardware guarantees Ping-Pong switches occur on CCD frame boundaries, only whole frames are dropped. Discarding the newer data reflects the scientific preference for events captured immediately after a burst.","8315d7d9-f1bb-3a29-9bb0-7fb8f91034eb":"The CSC uses a ring‐buffer FIFO to hold incoming DCI data until processing. Two pointers, pIn and pOut, manage the buffer contents and are arranged so that reading requires only one comparison to check for emptiness. The buffer stores only four-byte Events, so the pointers address those entities directly. Because the DCI reports sizes in bytes, conversions are performed before data is read.","5c6dd184-15cf-3b63-93e9-f88e90f97cbb":"To prevent losing error counts due to rollover, ccmErrEnq() ensures that no error’s count exceeds 250 within a single high-rate housekeeping reporting period. If the count does exceed 250 in that period, ccmErrEnq() enqueues an S_ccm_ERR_REPEAT error with the current count and resets its error tracking mechanism.","f7aecaad-eb17-33cc-b06c-313bb1c98153":"During boot, before the error queue is created, any errors go directly into the global errno variable. For details on errno, see section 2.3.7 of the VxWorks® Programmer’s Guide. Once the error queues are established, any errno value is enqueued into the Error Queue by calling ccmErrEnq().","677acf9d-95cd-3d75-bbb8-108ae99ab505":"When a command is received from the SCU via the 1553 interface or from the ICU via the SSI interface, the corresponding ISR enqueues the command packet into the Command Queue and signals the semaphore to wake ccmCmdTask(). Because the DPU can issue commands to itself, they may arrive in either interrupt context or task context. Therefore, the CCM uses two separate queues: one for interrupt context without semaphore protection and one for task context with semaphore protection.","b1a3ea21-45cc-3752-9545-11b23346c0ed":"The S_ccm_ERR_REPEAT error stores the count of the most recent repeated error in its low‐order byte. Whenever a new error is reported, ccmErrEnq() enqueues an S_ccm_ERR_REPEAT entry for any previously repeating error before adding the new error. To ensure each original error code and its repeat count appear together in the same packet, ccmMkHkErr() enqueues the special S_ccm_ERRQ_FLUSH code, signaling ccmErrEnq() to reset its tracking mechanism and enqueue any pending repeat counts for that error.","64a62731-7b98-308a-8aa7-6280741deb37":"The S_ccm_ERR_REPEAT code stores the count of the last repeated error in its low-order byte. Whenever a new error is reported, ccmErrEnq() queues an S_ccm_ERR_REPEAT entry for any previously repeated error along with the new error. To keep each original error code and its repeat count together in the same packet, ccmMkHkErr() enqueues the special S_ccm_ERRQ_FLUSH code, signaling ccmErrEnq() to clear its tracking mechanism and enqueue any accumulated repeat counts for that error.","138ca949-ad6a-35d3-88a4-03abb0ff4794":"This routine is invoked by the MIL-STD-1553 Command ISR and the SSI Interface ISR whenever a command arrives from the SCU or ICU, to enqueue the command and wake up the CCM Command Dispatch Task for execution.","16598da8-f59a-3689-9801-4c35905e8346":"On initialization, the TMALI CSC starts tmaliTask() with its default startup parameters. This task allocates memory for the TMALI_EVENT_QUEUE, installs the DCI interrupt service routines, initializes static variables and data structures, and then enters an infinite loop in which it moves data from the DCI into the TMALI queue, regulated by the semDciWait semaphore.","77082507-d2bf-3ad7-9ba3-5eb3bc2e6228":"The DPU generates eight distinct types of housekeeping packets.","d0ccf8ba-3a19-31ec-8ebd-f427be4c23a5":"Public Functions  \nThis routine enables retrieving the DCI’s current data timeout value, returning it in milliseconds. The timeout is detailed in document 036911400, section 4.3.2.4.1.3.","f6d42825-93ff-3c93-97a7-34b7c8a6631b":"During normal operation, frames arrive about every 11 ms. If the DCI hardware has placed event data into a Ping-Pong buffer and no further events occur within a configurable timeout period, it issues a data timeout interrupt. This interrupt is not an error but signals that the current exposure has finished and allows the TMALI CSC to retrieve the remaining events from the Ping-Pong buffer. The tmaliDciTimeoutSet() function provides the DCI driver with an API to adjust this timeout.","58f96747-3b38-3b87-b88e-6234010d52cb":"Data can be uploaded to different destinations—including DRAM, EEPROM, hardware registers, or the EEPROM filesystem—by using the D_MEM_DAT_UPLD command to select the target. When the EEPROM filesystem is chosen, a block number is given instead of a memory address. The DPU flight software uses that block number to generate a filename of the form eefs1:DPU_blk.##. After all of the upload data has been received, it is written to that file, overwriting any existing file with the same name. The EEPROM filesystem can be reinitialized with the D_MEM_DISK_INIT command.","71b2fd83-b042-33a9-ab42-cebec7d2b637":"This routine configures and activates the DCI hardware windowing parameters used for data acquisition. It first validates the requested window settings; if they are invalid, it returns an error and does not enable hardware windowing. If the settings pass validation, it programs the hardware with the new window specification and turns on the windowing function.","5530a803-f64e-34b4-9cd9-4dfc68f401d4":"For control and monitoring, the DPU generates eight distinct types of housekeeping packets.","0206f39c-fe52-3c51-827b-55372a174fe0":"The CCM Control Task manages memory dump requests by segmenting a large dump into smaller chunks and processing one chunk each time it is activated, ensuring that a lengthy dump does not tie up CPU resources or monopolize the high-priority CCM Command Dispatch Task.","b993686e-1a46-3ac5-b2a4-712e34d9774a":"Once all events in the Ping-Pong buffer have been transferred to the TMALI_EVENT_QUEUE, the tmaliTask() function must re-arm the hardware so the Ping-Pong buffers can swap when ready. If tmaliTask() does not finish moving data out of the ping buffer before the pong buffer fills, the DCI driver will generate an error interrupt and call tmaliDciErrorReportedISR(). That ISR sets an error flag for tmaliTask() to detect, gives the semDciWait semaphore to wake tmaliTask() (in case it isn’t already running), and increments the error count in TMALI_HK. Meanwhile the DCI hardware will drop incoming events until tmaliTask() completes its prior transfer, notices the error flag, forces a manual Ping-Pong buffer swap, and re-enables data acquisition. This ensures that only complete frames are stored in the Ping-Pong buffer for processing. Under normal conditions this error should not occur because tmaliTask() should clear the DCI Ping-Pong buffer quickly enough; if it cannot keep up, the TMALI queue will fill and an S_TMALI_QUEUE_FULL error will be reported via ccmErrEnq().","3d68bfa5-ad37-33b3-8672-d2ef50464c0f":"This function configures the number of frames the DCI CSC’s Ping-Pong buffers will load before issuing an interrupt. The initial frame depth is set by the parameter passed to tmaliTask at startup. You may set a maximum of 64 frames; attempting to set a higher value reverts the timeout to the default V frames. The new depth setting may be applied with a slight delay if the DCI bus is active, and it typically takes effect right after the DCI reports a frame-level reached or timeout event to avoid changing the setting when the hardware is about to detect a frame. Altering the frame depth while the CSC is processing data may produce unpredictable results. If a tmaliDciFrameDepthSet command is issued before the previous change has been activated, the latest request replaces the earlier one and is applied at the next available opportunity.","9621ed45-dd12-3a6d-9aa1-db95b4b7fd0a":"If an upload exceeds 65535 bytes, the file must be split into multiple parts no larger than 65535 bytes, and each virtual upload sent consecutively. Because of sequence numbers, the DPU FSW may receive upload commands out of order. There is no time limit on completing a single virtual upload, so lengthy uploads can span multiple ground contacts. During an upload, sending the final sequence number to the DPU FSW causes it to issue event S_ccm_MISSING_SEQNO listing any missing sequence numbers. To cancel an ongoing upload, issue the D_MEM_DAT_CNCL command.","e4f70e1e-8be1-335f-9425-6a23d4108324":"This routine allows configuring the DCI’s data timeout in milliseconds. The initial frame depth is set by the parameter passed when starting the tmaliTask. If a timeout greater than X seconds is requested, it will default back to X milliseconds.","a8c0bbd3-0871-3761-ae67-a8281a387eb3":"Normal Data Exchange Sequence The TMALI CSC acts as an intermediary manager of EVENT data supplied by the DCI Driver CSC before delivering it to the DPA CSC. The TMALI CSC waits for a notification from the DCI CSC that the Ping-Pong buffer has reached its frame limit or timed out, indicating EVENT data is ready. TMALI then retrieves all EVENT data from the DCI, informs the DCI it may swap Ping-Pong buffers, and signals a semaphore to unblock the tmaliWait() call from the DPA.","f9265c63-7317-3874-a3cd-483e6e041dd8":"During the normal data exchange sequence, the DPA CSC invokes tmaliWait() to determine how many EVENTs are pending. If tmaliWait() returns a positive number, the DPA calls tmaliNextEvent() once for each pending EVENT to collect it.","c8b8bfe7-d485-3f2e-953b-5a26844e7342":"The DPA CSC pulls events from the TMALI_EVENT_QUEUE using the tmaliWait() and tmaliNextEvent() calls. To maximize performance, tmaliNextEvent() is inlined to eliminate per-event function calls, each event is loaded into a register and fully processed before the next is fetched, and because tmaliNextEvent() omits error checking, the DPA CSC must track how many events it has retrieved against the count returned by tmaliWait().","340fcf1b-3d14-3f79-8893-b8ce71433765":"The DPU-CCM CSC offers a centralized error-reporting interface called ccmErrEnq() that other flight software tasks use to log errors. Each time ccmTask() wakes, it checks whether it’s time to assemble an error/event packet for downlink, and if so, it invokes ccmHkMkError() to build the packet and hand it off to DPU-SCUI for transmission to the ground.","5ddca483-5b28-3e2a-aeec-a06fed997884":"When large amounts of memory need to be uploaded to the DPU, such as for a software patch or a full software upload, the standard memory upload process is used. This involves sending a series of D_MEM_DAT_UPLD commands that together form one logical upload. CCSDS-style grouping flags let the DPU flight software accept up to 65,535 bytes in a single logical upload. Each command’s data is held in a temporary DRAM buffer until all sequence numbers for the entire upload have been received. When the final command arrives, the flight software checks that every sequence number is present, validates the end-to-end checksum, and then writes the buffered data to the target location specified in the first upload command.","952110df-29a7-3265-8d24-e7cad92f15c7":"During system startup, the operating system’s root task, usrRoot(), spawns the CCM Control Task (ccmCtrlTask()). Once running, ccmCtrlTask() invokes ccmInit(), which sets up the error/event queue, creates the required semaphores and installs all necessary ISRs, then launches the rest of the DPU flight software tasks. As the CCM Control Task initializes, it reads DPU configuration defaults from the SYSTEM_CONFIG_AREA in EEPROM, falling back on hard-coded defaults if the checksum fails. It then brings up each remaining CSC either by calling its initialization function or, if the CSC runs in its own task, by spawning that task with VxWorks® taskSpawn(), passing in the EEPROM-loaded defaults. Finally, ccmInit() calls ccmCmdLengthInit() to build the command length verification table that the command processor uses to check incoming command sizes.","ca2836cb-29de-39a7-898b-ea1e69059578":"During normal operation frames arrive roughly every 11 ms. The DCI hardware issues an interrupt when event data is present in one of its ping-pong buffers and a configurable interval passes with no new events. This data-timeout interrupt isn’t an error but generally signals that the current exposure has finished, allowing the TMALI CSC to retrieve the remaining events from the ping-pong buffer. The tmaliDciTimeoutSet() function provides an API for the DCI driver to modify the timeout setting.","f018e08c-525d-3557-a377-b316b27047ab":"During system startup, no error queue exists until it is created, so any errors occurring at this stage are stored in the global task variable errno. For more information on errno, see section 2.3.7 of the VxWorks Programmer’s Guide. Once the error queues are in place, if errno is set it is added to the Error Queue by calling ccmErrEnq().","bcc0333b-e0d8-3b5c-a2ee-2b6503dfde4c":"During initialization, the TMALI CSC installs the tmaliTransferToQueueISR() ISR hook routine into the DCI Driver, which is triggered when the DCI interface reaches the programmed frame limit in the Ping-Pong buffer or detects a data receipt timeout.","5cd610f3-dc90-3662-ab7e-70f344bc19c1":"In normal operation, frames arrive roughly every 11 ms. The DCI hardware issues an interrupt when event data has been written into one of the Ping-Pong buffers and no new events appear within a configurable timeout period. This interrupt isn’t an error but generally signals that the current exposure has finished, allowing the TMALI CSC to collect the remaining events from the Ping-Pong buffer. The tmaliDciTimeoutSet() function provides an API for the DCI driver to modify the timeout value.","3d3c847c-86be-31b8-a857-0d109e53fa2d":"During initialization, the TMALI CSC installs an ISR hook routine named tmaliTransferToQueueISR() into the DCI Driver, which is invoked whenever the DCI interface either hits its configured frame limit in the ping-pong buffer or encounters a data receipt timeout.","662b5d71-25bc-37bf-a61b-37b2c585d794":"If the TMALI queue is empty, this function waits on a semaphore until the ISR signals that events have arrived. If data is already present on the queue or the semaphore is already taken, it counts the events and returns that number. The TickstoWait parameter sets the maximum wait time in kernel ticks, or can be set to FOREVER so the function only returns when data is available. If a finite timeout is used and no data arrives before it expires, the function returns zero. If the TMALI task has not been initialized, the function returns an error.","f7723ed1-c1e3-32e4-80c5-68be98104d52":"This function can be called by any CSC to report an error or event for inclusion in DPU housekeeping. If it’s invoked from an interrupt context, it sets a static global variable, ccmISRError, so the error can be queued later in ccmCtrlTask(), since the error/event queue is protected by a semaphore that cannot be taken in an ISR. The semaphore uses priority inheritance to minimize conflicts if multiple callers contend for it. This function also collapses frequently recurring errors by issuing a special repeat error code immediately following the original error code to indicate that the same error has occurred multiple times during the current high-rate reporting period.","4cefbc60-9714-3794-821a-983469298eab":"The Telescope Module Access Library and Interface (TMALI) CSC provides a ring‐buffer event queue, TMALI_EVENT_QUEUE, that holds detector events received from the DCI driver over the data capture interface until they are fetched by the DPA CSC. It offers two functions, tmaliNextEvent() and tmaliWait(), to allow the DPA CSC to retrieve these events, as well as a suite of configuration calls—tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet(), and tmaliDataTimeoutGet()—for setting up the DCI interface. The tmaliHkGet() function gathers housekeeping data when requested by the Command and Control Task. Data transfer from the DCI to the queue is synchronized by the tmaliTask() thread and the tmaliTransferToQueueISR() interrupt service routine using a semaphore. An error‐handling ISR, tmaliDciErrorReportedISR(), is registered with the DCI driver to record the number of errors reported.","4f6fb9a6-44f5-325e-8080-636c41718181":"The DPU receives commands through two interfaces: the spacecraft’s MIL-STD-1553 bus and the ICU’s SSI link. Any DPU command may originate from either the ICU or the spacecraft control unit, whether generated locally or relayed from ground. In particular, commands can be sent by the ICU over SSI, by the SCU over 1553, by ground via the ICU/SSI (G-ICU), or by ground via the SCU/1553 (G-SCU).","69251ec5-bee9-31c3-94c5-4cda07e3e0b9":"When large memory transfers are needed, such as applying a software patch or uploading a full program, the DPU performs a standard memory upload by issuing multiple D_MEM_DAT_UPLD commands that together constitute one virtual upload. CCSDS-style grouping flags allow the DPU flight software to receive up to 65,535 bytes in this virtual upload. Each command’s data is held in a temporary DRAM buffer until every expected sequence number arrives. Once the final command is received, the flight software verifies that all sequences are present, checks the end-to-end upload checksum, and then commits the buffered data to the target location specified in the first command.","cba4501b-afd7-3efb-a398-b140529b1ff0":"If no events are in the TMALI queue, the function blocks on a semaphore until the ISR signals new events. If events are already in the queue or the semaphore is immediately obtained, it counts the queued events and returns that number. The TickstoWait parameter sets the maximum wait time in kernel ticks, or may be set to FOREVER so the function only returns when data arrives. If a finite timeout expires without events, the function returns zero. If the TMALI task has not been initialized, the function returns an error.","98992ace-c8ef-3eb3-a46d-b1fef3c7f1d8":"During the normal data exchange sequence, the DPA CSC calls tmaliWait() to find out how many events are queued, and if tmaliWait() returns a number greater than zero, the DPA then calls tmaliNextEvent() once for each event to retrieve them.","f9dfa81c-73bc-321e-8aa5-ec962c36c703":"The Telescope Module Access Library and Interface (TMALI) CSC oversees the detector event queue and offers an API allowing data processing algorithms to retrieve detector events from that queue.","7cf578ce-6a0d-341d-a1f8-5ec45d9ecfd5":"Ring buffer data structure: pIn identifies the slot most recently populated with data, and pOut identifies the slot most recently vacated.","5b08dde6-f7a9-3837-a419-393fc4a10be3":"The ring buffer data structure uses pIn to point to the most recently filled slot and pOut to point to the most recently emptied slot.","2b53e58b-b3d9-3029-bc71-b192e31f298a":"In the ring buffer data structure, a separate pointer pEnd marks the last slot in the buffer. Before advancing any pointer, check if it’s at pEnd; if so, reset it to the buffer’s start at pBuf, otherwise just increment it.","51d70ac6-c190-314f-99a9-d33b0c7261f7":"This function configures how many frames the DCI CSC’s Ping-Pong buffers will load before issuing an interrupt. The starting frame depth comes from the parameter passed to tmaliTask at startup, and you cannot set it higher than 64 frames—any request above that resets the timeout to the default V frames. Applying a new frame depth may be delayed slightly if the DCI bus is busy; typically the change occurs right after the DCI reports a frame event or timeout to avoid altering the setting when the hardware is about to detect a frame. Adjusting the frame depth while the CSC is processing data can lead to unpredictable behavior. If a tmaliDciFrameDepthSet command arrives before the previous change has taken effect, it simply replaces the pending request and is applied at the next opportunity.","7be33dd4-f6b4-31fd-9586-81606064efe7":"To prevent error counts from being lost to rollover, ccmErrEnq() verifies that no error count exceeds 250 during a single high‐rate housekeeping reporting period; if it does, ccmErrEnq() enqueues an S_ccm_ERR_REPEAT error with the current count and resets its error tracking.","035ea18e-468f-3a98-b85d-561cec40ce84":"Error Collection and Reporting: ccmErrEnq() can also be called from interrupt context. Because it’s illegal to take a semaphore during an interrupt, the usual mutual‐exclusion mechanism for the Error Queue is bypassed. Instead, the global variable ccmISRerror is set to the new error code, and the error is actually queued when ccmTask() next runs. As a result, if more than one error occurs in interrupt context before ccmTask() executes, the earlier error will be overwritten by the later one.","ced8ead4-8286-3925-95b8-15e3287635d3":"This function enables setting the DCI hardware windowing parameters for data acquisition. It first checks the supplied window specifications before instructing the DCI driver to update the hardware. If the specifications are invalid, it returns an error and leaves hardware windowing disabled. If they are valid, it applies the settings and activates the hardware windowing feature.","0f933526-af70-33ce-b341-7b55f7235f97":"The Command and Control (CCM) component is a Level 2 reusable module from the INSTRUMENT Y project that comprises two primary tasks. The first, ccmCtrlTask(), initializes the DPU flight software, launches and oversees other tasks at startup, arranges the generation of housekeeping data packets, monitors task execution, and schedules recurring functions such as the heartbeat message and watchdog strobe. The second, ccmCmdTask(), receives real-time commands from the SCU or ICU via interrupt and dispatches them for execution. The component relies on three main data structures: a static data table that records the system’s operational state—including housekeeping rates, CCM-specific flags, and the command count—a command queue that holds incoming commands, and an error/event queue that collects error and event codes reported by the DPU flight software for periodic inclusion in telemetry housekeeping packets.","97c6dc14-862c-30cd-beba-b9c88ae2133a":"The Command and Control CSC is brought up by usrRoot() at OS startup, which spawns the ccmCtrlTask(). Once running, ccmCtrlTask() invokes ccmInit(), which creates the error/event queue, sets up required semaphores, and installs the various ISRs. After that, it launches the rest of the tasks that make up the DPU flight software. Upon startup, the CCM Control Task loads DPU configuration defaults from the SYSTEM_CONFIG_AREA in EEPROM, falling back to hard-coded defaults if the checksum is invalid. It then initializes each remaining CSC—either by calling its initialization routine or, if it has a dedicated task, by using VxWorks® taskSpawn()—passing in the EEPROM-read defaults. As part of ccmInit(), the command length verification table is also built via ccmCmdLengthInit(), enabling the command processor to check the length of incoming commands.","25d78690-834b-3a98-9beb-4f977ccc3125":"In the ring buffer data structure, pIn points to the most recently written position and pOut points to the most recently emptied position.","42a80079-ccba-3a00-8019-40a4a59a0c29":"This ring buffer design makes management simple but wastes one slot when full because pIn is one position behind pOut, and the buffer is considered empty when pIn equals pOut.","fbef9dee-4240-3746-a8e1-dd47c0c8e4d1":"This function allows configuring the DCI’s bit arrangement: if bSpecialArrangement is TRUE, the DCI uses the special bit arrangement mode; otherwise, it defaults to no rearrangement.","a5e45f42-01ea-345f-911e-6230799a5dac":"Each DPU FSW task calls this routine to indicate it has run, enabling ccmCtrlTask() to monitor the health of the DPU FSW execution.","f3fddda1-3520-3ec2-9e6e-41c9753ca5f5":"During initialization, the TMALI CSC installs an ISR hook routine, tmaliTransferToQueueISR(), into the DCI driver, which is called whenever the DCI interface either reaches its configured frame limit in the ping-pong buffer or detects a data reception timeout.","585dfbc2-30a4-37fb-9116-efe4efce2f3d":"The TMALI CSC collects housekeeping data, which can be obtained by calling tmaliHkGet() and is returned in the TMALI_HK data structure.","45dbc082-65e0-3758-ac9c-ec46d159ae10":"The S_ccm_ERR_REPEAT error stores the number of times the last error was repeated in its least significant byte. Whenever a new error is reported, ccmErrEnq() will enqueue an S_ccm_ERR_REPEAT for any previously repeated error along with the new error. To ensure that each original error code and its repeat count appear in the same packet, ccmMkHkErr() enqueues the special code S_ccm_ERRQ_FLUSH, signaling ccmErrEnq() to reset its error-tracking state and enqueue any accumulated repeat counts for that error.","6e194a13-5063-3e26-a2c8-91261c27e517":"The Command and Control CSC is a Level 2 reuse component from the INSTRUMENT Y project. It provides two main tasks: ccmCtrlTask(), which initializes the DPU flight software, launches other tasks at startup, schedules periodic generation of housekeeping data packets, monitors the execution of all tasks, and handles recurring operations such as heartbeat messaging and watchdog strobes; and ccmCmdTask(), which receives real-time commands from the SCU or ICU and dispatches them for execution. Internally, the CSC maintains a static data table to record its operational state—including housekeeping rates, specific flags, and the count of executed commands—a command queue for incoming commands delivered via interrupt from the ICU or SCU, and an error/event queue that accumulates DPU flight software error and event codes for regular inclusion in telemetry housekeeping packets.","17cf5d55-03c7-3011-b7d7-1072b40292c4":"The CCM Control Task sets up the DPU flight software and ensures a proper boot by first launching the SCU Interface Task and the CCM Command Task, then waiting on temporary semaphores for up to five seconds each. If both tasks signal successful startup, the control task flips the BC_INDEX flag in EEPROM to mark a successful boot; if either fails to respond, it stops the watchdog strobe to force a DPU reboot. This check is used because the flight software needs both of these tasks at minimum for ground contact and commandability. Once initialized, the control task waits on a binary semaphore released by the SCUI Command ISR whenever a 1 Hz Clock Message arrives, with a 1.5 second timeout if no message is received. The control task remains active to generate and send DPU housekeeping data on schedule, carry out periodic processing, and handle memory dump commands. Finally, it calls ccmErrEnq() so that any errors detected in an interrupt service routine—captured in a global errno variable—can be placed into the Error/Event Queue during its normal processing.","db03215f-e926-3451-ab93-f2a59e4fbc72":"When a command arrives from the SCU via the 1553 interface or from the ICU via the SSI interface, the corresponding ISR enqueues the command packet into the Command Queue and signals a semaphore to wake ccmCmdTask(). Since the DPU can send commands to itself, they may arrive in either interrupt or task context. Therefore, the CCM maintains two queues: one that is not semaphore-protected for interrupt context, and one that is semaphore-protected for task context.","8f72cbad-3883-33f5-b620-a78aa57d7f4e":"The optimal frame depth will be established through benchmark testing. By default, it is set to 10 frames. Based on the data above, reading ten maximum‐sized frames at peak transfer speed takes about 24 ms.","25644cd6-30ef-3273-b131-b348e228ceb4":"This ring buffer design makes management straightforward but sacrifices one slot when full—pIn sits immediately before pOut—and the buffer is empty whenever pIn and pOut are equal.","91c7dd15-734b-3b72-8139-25084df788a5":"The CSC employs a ring‐buffer FIFO to temporarily hold data from the DCI before processing. Two pointers, pIn and pOut, track entries and are arranged so that reading requires only one comparison to check for emptiness. Since the buffer stores only Events (each four bytes), the pointers reference those Event units. Because the DCI reports sizes in bytes, conversions are performed before data is read.","f5a229cf-46ad-38fd-91fb-731287c46123":"This public function returns the DCI’s currently configured data timeout in milliseconds, as specified in document 036911400, section 4.3.2.4.1.3.","e8e16ca3-c084-384b-9315-49d36cfa4a5e":"When tmaliTransferToQueueISR() is called, it gives a semaphore to wake tmaliTask(), which then transfers data to the queue over the VME bus. The tmaliTask() function uses the DCI driver’s read() call, implemented in a high-speed assembly routine, to perform the transfer. Because the TMALI ring buffer is an array, tmaliTask() first checks the TMALI_EVENT_QUEUE to decide whether all available data can be fetched in one read() or whether it must issue two reads to handle wrap-around at the end of the buffer. It also checks that there is enough free space in the Ping-Pong buffer to store the incoming data. If there isn’t enough room for the full set of frames, tmaliTask() discards the entire contents of the readable Ping-Pong buffer and reports the S_TMALI_QUEUE_FULL error via the ccmErrEnq mechanism. Since the hardware ensures Ping-Pong swaps occur only at CCD frame boundaries, any discarded data always represents a whole number of frames. This approach of dropping newer data ensures that events recorded immediately after a burst—deemed more scientifically valuable—are retained.","a98d05f0-94b8-3ed9-95f7-3f6754a8133b":"The D_MEM_BLK_DNLD command retrieves data from a file stored in the EEPROM filesystem. Only the block number is needed, and it downloads the full contents of the file associated with that block. To download content from any other memory region, the D_MEM_DAT_DNLD command is used. Downloads are carried out in a deferred manner to minimize CPU load. Although the system sends a single logical download, it arrives as a series of packets, which must be extracted and stitched together to reconstruct the original data stream.","f4fd0784-28c4-3aed-ab43-00450a6c5a64":"A ring buffer uses a dedicated pointer pEnd to mark its last slot. Before moving either pointer, check if it’s at pEnd; if it is, reset it to the start of the buffer at pBuf, otherwise simply increment it.","b9ff6f1c-154a-3a82-b7b9-c8f0b5f886cc":"The TMALI CSC collects housekeeping data accessible via the tmaliHkGet() call, returning it in a TMALI_HK data structure.","bc4861a9-1d9d-3ab2-9857-d17176bfac3a":"Ring buffer data structure: management is straightforward, but one slot remains unused when the buffer is full because pIn sits one position behind pOut, and the buffer is empty whenever pIn and pOut are equal.","d95c7cab-7815-31b3-a6e4-3c31afa2baad":"In the ring buffer data structure, a separate pointer, pEnd, marks the buffer’s last available position. Before advancing either pointer, check if it is at pEnd; if it is, reset it to the buffer’s start at pBuf, otherwise simply increment it.","35648906-88dd-37b6-b898-9ace097dcebe":"Calling tmaliDciWindowSet() activates the DCI hardware windowing feature and transfers the specified window parameters to the DCI driver.","78919754-9dba-38c5-b5ba-a65b2059127b":"The DPU-CCM CSC offers a centralized error-reporting interface, ccmErrEnq(), that FSW tasks call to log errors. Each time ccmTask() wakes, it checks whether it’s time to assemble an error/event packet for ground transmission. If so, it invokes ccmHkMkError() to create the packet and forward it to DPU-SCUI for sending to the ground."}