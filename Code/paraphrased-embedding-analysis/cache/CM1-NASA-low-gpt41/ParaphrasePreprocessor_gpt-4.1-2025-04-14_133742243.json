{"6306ea9a-5e36-3db6-9888-08f5f65849a5":"Data can be uploaded to various locations, such as DRAM, EEPROM, hardware registers, or the EEPROM filesystem. The D_MEM_DAT_UPLD command determines where the data will be uploaded. When targeting the EEPROM filesystem, a block number is given instead of a memory address; the DPU flight software then generates a filename in the format eefs1:DPU_blk.##, where ## represents the block number. After all the upload data has been received, the DPU flight software saves it to this file within the EEPROM filesystem, overwriting any file that already exists with that name. The EEPROM filesystem may be reinitialized by issuing the D_MEM_DISK_INIT command.","35c05af7-4ad3-3aff-9fef-1ca76b881940":"Global Data refers to the data elements that this CSC accesses globally.","aee05ebe-70d6-3fa6-bf04-908fed5ee77b":"Commands are removed from the Command Queue and run by the Command Dispatch Task, ccmCmdTask(). This task waits for a semaphore signal, which is triggered by ccmCmdEnq(). When the semaphore is given, ccmCmdTask() wakes up and calls ccmCmdProcess() to handle any pending commands. The ccmCmdProcess() function retrieves commands from the queue and passes them to ccmCmdDispatch(), which checks the command length and executes it. If command echoing is enabled, ccmCmdDispatch() will call ccmHkMkCmdEcho() to send the command back to the ground without validation. The system keeps track of the number of both rejected and executed commands. If the command given to ccmCmdEnq() is a 1 Hz Clock Time message or an Attitude message from the spacecraft, it bypasses the Command Queue and is executed immediately within the interrupt context. Attitude messages are sent to dpaCommandSend(), and 1 Hz Clock Time message parameters are used by tisTimeSync() to update the current time. Any messages unrelated to the DPU or spacecraft observatory are discarded silently without error notification. To ensure that ccmCmdTask() periodically checks in with the CCM Control Task, even in the absence of ground commands, the semaphore has a 20-second timeout. If the semaphore times out, and no commands are found in the queue, ccmCmdTask() calls ccmTaskReport() to report in to the CCM Control Task.","277f0370-f6a2-3ae9-a75e-2683d446a347":"The DPU generates eight different kinds of housekeeping packets for control and monitoring purposes.","b05d66ed-652d-3c73-8ee7-881ee2f59cee":"This routine retrieves housekeeping data stored for the TMALI CSC, including certain DCI parameters, and resets the TMALI internal counters to zero. If the pointer provided by the caller to a TMALI_HK structure is NIL, no data is returned, but the internal counters are still reset. Two out of four error counters are updated within an ISR context, so these counters must be implemented in a way that is safe for task switching. While VxWorks could handle this with a counting semaphore, the TMALI CSC uses a faster approach by employing continuously running error counters and carefully updating the reported error count with an additional temporary variable. Since incrementing and assigning 32-bit unsigned integers are atomic operations, the counters are safe for use in tasks, and no error events are missed. As a result, the error totals reported by the tmaliHkGet() function accurately reflect all errors that occurred, with no loss of error information due to internal updates.","46a47c92-0a83-34be-b468-1143774393e2":"Determining the best frame depth for DCI will be based on results from benchmark testing. The initial default frame depth is set to 10 frames. Based on current information, reading 10 frames of the largest possible size at the peak data transfer rate will require about 24 milliseconds.","f0cc222b-4d06-3f55-a85f-77b8cc1b5e0e":"Commands are removed from the Command Queue and run by the Command Dispatch Task, ccmCmdTask(). This task waits for a semaphore signal, which is triggered by ccmCmdEnq(). When the semaphore is given, ccmCmdTask() wakes up and calls ccmCmdProcess() to handle any pending commands. The ccmCmdProcess() function retrieves commands from the queue and passes them to ccmCmdDispatch(), which checks the command length and executes it. If command echoing is enabled, ccmCmdDispatch() will call ccmHkMkCmdEcho() to send the command back to the ground without validation. The system keeps track of the number of both rejected and executed commands. If the command given to ccmCmdEnq() is a 1 Hz Clock Time message or an Attitude message from the spacecraft, it bypasses the Command Queue and is executed immediately within the interrupt context. Attitude messages are sent to dpaCommandSend(), and 1 Hz Clock Time message parameters are used by tisTimeSync() to update the current time. All other unrelated messages (not from DPU or the spacecraft observatory) are discarded silently without error reporting. To ensure the ccmCmdTask() regularly checks in with the CCM Control Task when no ground commands are received, the semaphore includes a 20-second timeout. If this timeout occurs and no commands are found in the queue, ccmCmdTask() calls ccmTaskReport() to report in to the CCM Control Task.","b3d600d2-cf3e-35e7-ba9d-73e1b90b302a":"Data can be uploaded to various locations, such as DRAM, EEPROM, hardware registers, or the EEPROM filesystem. The D_MEM_DAT_UPLD command determines where the data will be uploaded. When targeting the EEPROM filesystem, a block number is given instead of a memory address; the DPU flight software then generates a filename in the format eefs1:DPU_blk.##, with ## representing the block number. After all the upload data has been received, the DPU flight software saves it to the specified file in the EEPROM filesystem, overwriting any existing file with the same name. The EEPROM filesystem can be reset to its initial state using the D_MEM_DISK_INIT command.","1ca8a9c9-d97c-38e2-8e1a-72241ec0228b":"The hardware windowing feature of the DCI can be enabled and managed through the tmaliDciWindowSet() function, which turns on the hardware windowing and sends the defined window parameters to the DCI driver.","1d34025f-a3fb-3da6-a26f-4725c52ac084":"Commands are removed from the Command Queue and run by the Command Dispatch Task, ccmCmdTask(). This task waits for a semaphore signal, which is triggered by ccmCmdEnq(). When the semaphore is given, ccmCmdTask() wakes up and calls ccmCmdProcess() to handle any pending commands. The ccmCmdProcess() function retrieves commands from the queue and passes them to ccmCmdDispatch(), which checks the command length and executes it. If command echoing is enabled, ccmCmdDispatch() will call ccmHkMkCmdEcho() to send the command back to the ground without validation. The system keeps track of the number of both rejected and executed commands. If the command given to ccmCmdEnq() is a 1 Hz Clock Time message or an Attitude message from the spacecraft, it bypasses the Command Queue and is executed immediately within the interrupt context. Attitude messages are sent to dpaCommandSend(), and 1 Hz Clock Time message parameters are used by tisTimeSync() to update the current time. All other unrelated messages that are not from the DPU or the spacecraft observatory are silently ignored without generating an error. To ensure ccmCmdTask() regularly checks in with the CCM Control Task even when no ground commands are received, the semaphore includes a 20-second timeout. If this timeout is reached, the task checks that the Command Queue is empty, and then calls ccmTaskReport() to notify the CCM Control Task.","d2a9c9b3-60a4-33ea-8be0-b9c583f74036":"This function allows the user to specify the data timeout for the DCI in milliseconds. The initial frame depth value is set based on the parameter given when starting the tmaliTask. The timeout cannot be set to a value greater than X seconds; if a higher value is requested, the timeout will revert to the default value of X milliseconds.","7798b768-904b-396f-bc02-a6ee2e167bdf":"If more than 65,535 bytes must be uploaded, the file should be divided into several smaller files, each no larger than 65,535 bytes, and these partial uploads should be transmitted sequentially. The DPU FSW is capable of handling incoming upload commands that arrive out of order due to the use of sequence numbers. There is no time restriction for completing each of these smaller uploads, so a lengthy upload can span multiple ground passes. While an upload is underway, the last sequence number can be provided to the DPU FSW, and it will return a list of any missing sequence numbers through event S_ccm_MISSING_SEQNO. If it becomes necessary to stop an in-progress upload, the D_MEM_DAT_CNCL command can be used to abort it.","5bd67670-29bd-3756-928e-ba01196ad5f0":"After all events from the Ping-Pong buffer are fully moved to the TMALI_EVENT_QUEUE, the tamliTask() function must reset the hardware to allow the Ping-Pong buffer to swap when ready. If TMALI does not finish moving data from the ping buffer before the pong buffer fills up, the DCI Driver will trigger an error interrupt, which activates the tmaliDciErrorReportedISR(). This interrupt service routine sets an error flag so tmaliTask() can perform recovery steps. Additionally, tmaliDciErrorReportedISR() releases the semDciWait semaphore to wake up tmaliTask(), even though it is likely already running, in case tmaliTask() has just finished data transfer at the moment the error occurs. The error occurrence will be recorded in TMALI_HK. Until tmaliTask() finishes the previous data transfer, recognizes the error flag, and manually forces a Ping-Pong buffer swap and re-enables data collection, the DCI hardware will discard incoming events. This ensures that only full frames are stored in the Ping-Pong buffer for processing. Under typical conditions, this error should not occur, as TMALI task performance should be sufficient to quickly retrieve data from the DCI Ping-Pong buffer. If event processing falls behind, it should instead result in a TMALI queue full state, which is logged as an S_TMALI_QUEUE_FULL error through the ccmErrEnq() system.","0c11996b-fb22-3be5-96a2-18b6f06945d3":"If more than 65,535 bytes must be uploaded, the file should be divided into several smaller files, each no larger than 65,535 bytes, and these partial uploads should be transmitted sequentially. Due to the presence of sequence numbers, the DPU flight software (FSW) can accept the upload commands even if they arrive out of order. There is no time constraint for completing a single partial upload, so an extended upload can take place over multiple ground contacts. While an upload is ongoing, the most recent sequence number can be sent to the DPU FSW, and it will return a list of any missing sequence numbers through event number S_ccm_MISSING_SEQNO. If it becomes necessary to stop an ongoing upload, it can be cancelled by sending the D_MEM_DAT_CNCL command, which discards the upload.","417ed1bc-9a98-352d-acbe-4d904941bfe1":"The CCM Control Task is responsible for processing memory dump commands. When a data dump is requested, the CCM Control Task divides the dump into smaller segments and transfers a part of the data each time it is activated. This deferred approach ensures that large dumps do not monopolize CPU resources or occupy the high-priority CCM Command Dispatch Task for too long.","6adfb5cd-a367-38c7-8bea-79d1726faac7":"This function allows the user to specify the data timeout for the DCI in milliseconds. The initial frame depth value is set based on the parameter given when starting the tmaliTask. The timeout cannot be set to a value greater than X seconds; if a higher value is requested, the timeout will revert to the default value of X milliseconds.","975b1774-03bf-336c-ae7e-ffff46169a9d":"The TMALI CSC acts as an intermediary, managing EVENT data received from the DCI Driver CSC and forwarding it to the DPA CSC. TMALI waits for the DCI CSC to signal that either the frame limit has been reached or a data timeout has occurred in the Ping-Pong buffer, indicating that the EVENT data is ready. Once this notification is received, TMALI reads all EVENT data from the DCI and then informs the DCI that it can proceed with swapping the Ping-Pong buffers when needed. Afterward, TMALI releases a semaphore to unblock the tmaliWait() function in the DPA.","1668125c-e5cf-3214-9a19-ff08fc6a3b2c":"The tmaliBitArrangementSet() function allows you to configure the bit layout of the DCI control and status register.","2888db66-3ffd-3485-8be8-8076a586865f":"The Command and Control (CCM) CSC, adapted from the INSTRUMENT Y project as a Level 2 reusable component, consists of these parts:\n* A Control Task (ccmCtrlTask()), responsible for initializing the DPU flight software during startup, launching other tasks, managing the scheduling of DPU housekeeping data packet generation, overseeing the functioning of various tasks, and handling the scheduling of periodic operations like sending the heartbeat message and activating the watchdog strobe.\n* A Command Dispatch Task (ccmCmdTask()), which collects and routes incoming real-time commands sent by the SCU or ICU.\n\nThe primary data structures are:\n* A Static Data table that records operational status, including housekeeping data rates, CCM-specific indicators, and a count of processed commands.\n* A Command Queue that temporarily stores incoming commands, received via interrupts from the ICU or SCU.\n* An Error/Event Queue that gathers error and event codes generated by the DPU flight software; these codes are periodically extracted from the queue, incorporated into telemetry packets, and included in the DPU housekeeping data.","768cf777-831a-396b-9e3b-bb5bbb33eb6f":"The D_MEM_BLK_DNLD command is used to download data from files stored in the EEPROM filesystem. Similar to the upload process, you only need to specify the block number, and the entire file associated with that block number will be downloaded. If you need to download data from sources outside the EEPROM filesystem, you should use the D_MEM_DAT_DNLD command. As mentioned earlier, downloads are processed in a deferred manner to minimize CPU usage. From the ground perspective, a single logical download is received as multiple download packets, which must be combined in order to reconstruct the original data.","16a7704a-c956-39ff-8892-04bd43b8537b":"Each DPU FSW task calls this function to indicate it has run, allowing ccmCtrlTask() to evaluate the health of DPU FSW execution.","0b4fdce4-7b8d-3d19-a419-465409ed34ca":"The Telescope Module Access Library and Interface (TMALI) CSC is responsible for handling the detector event queue and offers an API that allows data processing algorithms to access and retrieve detector events from this queue.","28868435-794f-3114-b1ec-087d07f42f87":"Each DPU FSW task calls this function to indicate it has run, allowing ccmCtrlTask() to evaluate the health of DPU FSW execution.","a56431fb-e16d-3fbe-9fa7-9b728a5d9301":"For large memory uploads to the DPU, such as during a software patch or a complete software update, the standard memory upload process is followed. This process involves sending multiple D_MEM_DAT_UPLD commands, which together form a single \"virtual\" upload. CCSDS-like sequence flags are used to enable the DPU flight software to accept up to 65,535 bytes in one \"virtual\" upload. The data received in each D_MEM_DAT_UPLD command is temporarily stored in DRAM until all sequence numbers for the upload have been received. After the final command arrives, the flight software checks that all sequence numbers are accounted for and the overall upload checksum is correct, then writes the entire buffered data to the target memory location specified in the initial upload command.","034821fa-e846-3d5f-a712-2cab3aab6cc4":"The DPA CSC accesses events from the TMALI_EVENT_QUEUE using an API that includes two functions: tmaliWait() and tmaliNextEvent(). For optimal performance, the following practices are important:\n* The DPA CSC will use inlining for the tmaliNextEvent() function to eliminate the overhead of calling the function for each event,\n* Each event obtained will be loaded into a register by the DPA CSC, which will then finish processing that event while it remains in the register before moving to the next,\n* Since tmaliNextEvent() does not perform any error checking to ensure maximum speed, the DPA CSC is responsible for tracking the count of events retrieved and verifying it matches the number reported by tmaliWait().","bcaee947-f60d-3f12-9aab-b7e9b783e9ea":"This function is invoked by the MIL-STD-1553 Command ISR and the SSI Interface ISR whenever a command is received from the SCU or ICU, in order to place the command in the queue and signal the CCM Command Dispatch Task to execute the command.","caf39fb3-5550-3e2d-9d7b-0a369f1b0948":"The tmaliBitArrangementSet() function allows the configuration of the bit arrangement in the DCI control/status register.","95fb044f-2046-38f0-b241-fe9fa977900b":"Determining the optimal frame depth in DCI will be based on results from benchmark testing. The initial default frame depth is set to 10 frames. Based on current information, reading 10 frames of the largest possible size at the peak data transfer rate will require about 24 milliseconds.","6181127f-57bb-3d6c-a693-895ee3b0d075":"The DPU-CCM CSC offers a centralized error reporting function, ccmErrEnq(), which other FSW tasks utilize to log errors. On each activation, ccmTask() checks whether it is the scheduled time to generate an error or event packet for downlink. If it is, ccmTask() invokes ccmHkMkError() to build the packet and sends it to DPU-SCUI for transmission to the ground.","f2635035-8f10-32de-92f0-2695c9288a4a":"The CSC uses a FIFO ring buffer to temporarily hold data received from the DCI before processing. This ring buffer is managed with two pointers, pIn and pOut, which track the buffer’s contents. The design of the pointers prioritizes simple buffer reading, requiring only one comparison to determine if the buffer is empty. The buffer stores Events, each four bytes in size, so the pointers reference these four-byte elements. Since all data from the DCI is provided in bytes, sizes must be converted before the data can be read.","98f777a5-8d50-3772-a55b-abd45958b813":"The TMALI CSC acts as an intermediary, managing EVENT data received from the DCI Driver CSC and forwarding it to the DPA CSC. TMALI waits for the DCI CSC to signal that a frame limit or data timeout has occurred in the Ping-Pong buffer, indicating that the EVENT data is ready. Once notified, TMALI retrieves all EVENT data from the DCI, then informs the DCI that it is safe to switch Ping-Pong buffers when appropriate. TMALI then releases a semaphore to allow the tmaliWait() call in the DPA to proceed.","31310305-81b9-3860-b8d7-087a5e789bd6":"This function allows retrieval of the current data timeout value utilized by the DCI, returning the timeout duration in milliseconds. Details regarding the timeout can be found in document 036911400, section 4.3.2.4.1.3.","aaf7e356-ab47-30aa-961f-d572d4844469":"Global Data refers to the data items accessed globally by this CSC.","7a992a5c-644e-38f2-bece-ed0322d17445":"There are two methods available for uploading data to the DPU:\n* Using the Memory Poke command (D_MEM_DAT_POKE), or\n* Using the Memory Upload command (D_MEM_DAT_UPLD).\nThe Memory Poke command should be used when transferring a small amount of data (Z bytes or fewer) to a specific DPU memory location, with the Z-byte limit defined by Company X's maximum command length restriction.","b35d2bcd-847d-397a-92ad-b8714eac445f":"The CCM Control Task is responsible for starting up the DPU Flight Software (FSW) and ensuring a successful boot. It does this by waiting on temporary semaphores, each with a 5-second timeout, after launching the SCU Interface Task and the CCM Command Task. If both tasks signal that they have initialized successfully by releasing their semaphores, the CCM Control Task updates the BC_INDEX parameter in EEPROM to record the successful boot. If either task fails to signal successful initialization, the CCM Control Task disables the watchdog strobe, causing the DPU to reboot. This approach is used because at least these two tasks need to be running to enable communication with the ground and to allow command reception. After initialization, the CCM Control Task waits on a binary semaphore, which is released by the SCUI Command ISR when the 1 Hz Clock Message arrives. If the Clock Message is not received, the semaphore times out after 1.5 seconds. The CCM Control Task continues running to generate and send DPU housekeeping data at scheduled times, execute various periodic tasks, and handle memory dump commands. Finally, a call to ccmErrEnq() ensures that if an error arises in an interrupt service routine, the current errno value is stored and placed into the Error/Event Queue during the routine task processing.","426b5ffc-f36a-383f-a8f0-d419a106007b":"The DPA CSC invokes tmaliWait() to check the number of pending EVENTs. If tmaliWait() returns a value above zero, the DPA proceeds to call tmaliNextEvent() once for each EVENT that needs to be retrieved.","5c0f562d-28e5-327c-9721-b08cf6ecc5d3":"This function retrieves the current frame depth setting for the Ping-Pong buffers used by the DCI CSC. The frame depth defines how many frames are loaded into the selected Ping-Pong buffer before an interrupt occurs. The starting value is set by a parameter when the tmaliTask begins. The value returned reflects the currently active setting, which may not match the most recently set value, since changes only take effect when data moves from the hardware Ping-Pong buffer to the TMALI queue in response to a frame or timeout interrupt (refer to section 5.13.2.3).","3c62a5be-6021-3217-bbf6-e225d1e89e3b":"Each time the CCM Control runs, it invokes ccmPerProcess() to manage regular processing tasks. These tasks include updating analog-to-digital conversions, monitoring DPU tasks, generating ICU heartbeat messages, and triggering the watchdog strobe. Within ccmPerProcess(), the ccmHealthChk() function checks that other tasks are executing properly by tracking the time elapsed since each last reported in. Tasks confirm their execution to the CCM Control Task by calling ccmTaskReport() and providing their respective task index. Every task has a defined execution frequency, and if any task fails to meet this frequency, an error is logged in the DPU housekeeping system. Should the Command Dispatch Task not report in for an extended time, the DPU will initiate a reboot, as this task is vital for receiving commands. Otherwise, the system will continue to strobe the watchdog.","0b4bb7d4-ab4a-3536-807b-cdeb5579a6bd":"This function configures the frame depth for the Ping-Pong buffers utilized by the DCI CSC. Frame depth specifies how many frames are loaded into the chosen Ping-Pong buffer before triggering an interrupt. The initial frame depth value is set according to the parameter received when the tmaliTask starts. The maximum frame depth that can be set is 64 frames; if a higher value is requested, the system will default to a timeout value of V frames. Adjusting the frame depth may be slightly delayed if there is ongoing activity on the DCI bus, and changes typically occur when the DCI has just indicated that a frame level has been reached or a timeout has happened. This approach reduces the risk of modifying the setting during a critical frame event. Altering the frame depth while the DCI CSC is actively processing may cause unpredictable behavior. If a new ‘tmaliDciFrameDepthSet’ command is received before the previous change has taken effect, the new command will replace the earlier one, and the DCI will update to the most recent value as soon as possible.","3bffeba3-2c78-3628-ab1e-e8ad0e595c1d":"This routine retrieves housekeeping data stored for the TMALI CSC, including certain DCI parameters, and resets the TMALI internal counters to zero. If the pointer provided by the caller to a TMALI_HK structure is NIL, no data is returned, but the internal counters are still reset. Two out of four error counters are updated within an ISR context, so these counters must be implemented in a way that is safe for task switching. While VxWorks could handle this with a counting semaphore, the TMALI CSC uses a faster approach by employing continuously running error counters and carefully updating the reported error count with an additional temporary variable. Since incrementing and assigning 32-bit unsigned integers are atomic operations, the counters are safe for use in tasks, and no error events are missed. As a result, the error totals reported by the tmaliHkGet() function accurately reflect all errors that occurred, with no loss of error information due to internal updates.","47c13b41-538f-356c-a7de-59ca84d0b120":"When a command is received from the SCU through the 1553 interface or from the ICU through the SSI interface, the corresponding interrupt service routine (ISR) will place the command packet into the Command Queue and signal the semaphore to wake up ccmCmdTask(). Since the DPU can issue commands to itself, commands may be received either in interrupt context or in task context. As a result, the CCM uses two separate queues: one dedicated to interrupt context that does not use a semaphore, and another for task context that is protected by a semaphore.","27da15c7-49e5-3552-b1bd-24108986cbc1":"This function is invoked by the MIL-STD-1553 Command ISR and the SSI Interface ISR whenever a command is received from the SCU or ICU, in order to place the command in the queue and signal the CCM Command Dispatch Task to execute the command.","b6952139-6807-33af-96a9-132935531439":"At startup, the TMALI CSC is initialized by creating the tmaliTask() using the default parameters. This task sets up memory for the TMALI_EVENT_QUEUE, configures DCI interrupt service routines, initializes static variables and data structures, and then continuously runs a loop where it moves data from the DCI to the TMALI queue, regulated by the semDciWait semaphore.","a4ab6f19-21a3-3628-aae7-c94df16a968c":"The Command and Control CSC begins its initialization by having the operating system’s startup task, usrRoot(), spawn the CCM Control Task, ccmCtrlTask(). After being started, this task runs ccmInit(), which sets up the error/event queue, creates the required semaphores, and installs various interrupt service routines. It then starts up the other tasks that make up the DPU flight software. Upon startup, the CCM Control Task retrieves default DPU configuration settings from the SYSTEM_CONFIG_AREA in EEPROM. If the checksum for this area fails, predefined default values are used instead. The CCM Control Task continues by initializing the remaining CSCs, either by directly calling their initialization functions or, if they have their own tasks, by starting those tasks with the VxWorks® taskSpawn() function. During CSC initialization, it passes the startup defaults retrieved from EEPROM to each initialization function as parameters. Additionally, ccmInit() sets up the command length verification table by calling ccmCmdLengthInit(), which the command processor later uses to confirm command lengths for newly received commands.","538575b2-0798-3439-bfdf-f36375d23a83":"At startup, the TMALI CSC is initialized by creating the tmaliTask() using the default parameters. This task sets up memory for the TMALI_EVENT_QUEUE, configures DCI interrupt service routines, initializes static variables and data structures, and then continuously runs a loop where it moves data from the DCI to the TMALI queue, regulating this transfer with the semDciWait semaphore.","45df9dde-c99f-350d-a122-05fe7505d99d":"This function allows you to configure the DCI's bit arrangement. If bSpecialArrangement is set to TRUE, the DCI switches to special bit arrangement mode; if FALSE, it uses the default, non-rearranged mode.","94ed76a0-77c2-3757-bea5-779e473c08aa":"Each time the CCM Control runs, it invokes ccmPerProcess() to manage regular processing tasks. These tasks include updating analog-to-digital conversions, monitoring DPU tasks, generating ICU heartbeat messages, and triggering the watchdog strobe. Within ccmPerProcess(), the ccmHealthChk() function checks that other tasks are executing properly by tracking the time elapsed since each last reported in. Other tasks signal their activity to the CCM Control Task by calling ccmTaskReport() with their respective task index. Every task has a defined execution frequency, and if any task fails to meet this frequency, an error is logged in the DPU housekeeping data. Should the Command Dispatch Task not report in for an extended time, the DPU will initiate a reboot, since this task is vital for receiving commands; otherwise, the system will continue by stroking the watchdog.","c15544ec-0a76-3779-8098-5095d8b1a935":"The ccmErrEnq() function monitors the last error that was reported and keeps a count of how often it occurs. After an error code is reported, it is saved as the previous error in ccmErrEnq(). If the same error code is reported consecutively, the function increases a repetition counter for that error. When an error code is reported multiple times within a single high-rate housekeeping reporting period, the function queues a special error, S_ccm_ERR_REPEAT, and includes the number of repetitions in the least significant byte. This process helps prevent the housekeeping telemetry from being overloaded with repeated instances of the same error.","5233365f-9b83-3955-ba6b-6538d1f40a91":"This function is invoked by the MIL-STD-1553 Command Interrupt Service Routine once per second (triggered by the arrival of the Clock Message) to signal the CCM Control Task to resume, which waits on a semaphore after it finishes its work.","135782dc-e228-3b2c-9534-6f645acae157":"This function allows you to configure the DCI's bit arrangement. If bSpecialArrangement is set to TRUE, the DCI switches to special bit arrangement mode; if it is FALSE, the DCI uses the default mode with no rearrangement.","2a21cd73-14d9-37e7-bcb7-a8425e6a95b2":"This function retrieves the current frame depth setting for the Ping-Pong buffers used by the DCI CSC. The frame depth defines how many frames are loaded into the active Ping-Pong buffer before an interrupt occurs. The starting value is set by a parameter when the tmaliTask begins. The value returned reflects the currently active setting, which may not match the most recently set value, since changes only take effect when data moves from the hardware Ping-Pong buffer to the TMALI queue in response to a frame or timeout interrupt (refer to section 5.13.2.3).","09b45c48-1774-3677-a22b-8637ceeb5f69":"The hardware windowing feature of the DCI can be enabled and managed using the tmaliDciWindowSet() function, which turns on the hardware windowing and sends the defined window parameters to the DCI driver.","979afca3-c229-34d2-b89c-3d0901eecbea":"This function is invoked by the MIL-STD-1553 Command Interrupt Service Routine once per second (upon receiving the Clock Message) to signal the CCM Control Task to resume, which waits on a semaphore after finishing its processing.","9d071f3e-dd42-33c1-86ee-afa2e3812ba2":"After all events from the Ping-Pong buffer are fully moved to the TMALI_EVENT_QUEUE, the tamliTask() function must reset the hardware to prepare for the next Ping-Pong buffer swap. If the TMALI does not finish transferring data from the ping buffer before the pong buffer fills up, the DCI Driver will trigger an error interrupt, which activates the tmaliDciErrorReportedISR(). This interrupt service routine sets an error flag so tmaliTask() can perform recovery steps. Additionally, tmaliDciErrorReportedISR() releases the semDciWait semaphore to wake up tmaliTask(), even though it is likely already running, in case tmaliTask() has just finished data transfer at the moment the error occurs. The error occurrence will be recorded in TMALI_HK. Meanwhile, until tmaliTask() finishes the current transfer, detects the error flag, and manually triggers a Ping-Pong buffer swap and resumes data acquisition, the DCI hardware will ignore new events. This approach ensures that only complete frames are stored in the Ping-Pong buffer for processing. Under typical conditions, this error should not occur, as tmaliTask() should be quick enough to clear data from the DCI Ping-Pong buffer. If event processing falls behind, it should instead result in a TMALI queue full state, which is logged as an S_TMALI_QUEUE_FULL error through the ccmErrEnq() system.","25827c10-2881-3b70-9724-65b4b4d6d11c":"The DPU receives commands through two interfaces: the MIL-STD-1553 interface from the Spacecraft and the SSI interface from the ICU. Any command intended for the DPU can originate from either the SCU or the ICU. The possible sources for DPU commands are as follows:\n- ICU: commands created and transmitted by the ICU over the SSI interface.\n- SCU: commands created and transmitted by the SCU over the 1553 interface.\n- G-ICU: commands generated on the ground, then sent to the DPU via the ICU and SSI.\n- G-SCU: commands generated on the ground, then sent to the DPU through the SCU and 1553.","15da4c28-a24a-3049-8edf-8ac8575ea61a":"The D_MEM_BLK_DNLD command is used to download data from files located in the EEPROM filesystem. For this operation, only the block number is required, and the entire file corresponding to that block number will be downloaded. If data needs to be downloaded from sources other than the EEPROM filesystem, the D_MEM_DAT_DNLD command should be used. As previously mentioned, downloads are processed in a deferred manner to minimize CPU usage. A single download operation will be split into multiple packets for transmission to the ground, where the original data must be reconstructed by extracting and concatenating these packets.","6485ce43-484d-38ea-a03e-0ba343c56744":"The ccmErrEnq() function monitors the last error that was reported and keeps a count of how often it occurs. After an error code is reported, it is saved as the previous error in ccmErrEnq(). If the same error code is reported consecutively, the function increases a repetition counter for that error. When an error code is reported multiple times within a single high-rate housekeeping reporting period, the function queues a special error, S_ccm_ERR_REPEAT, and includes the number of repetitions in the least significant byte. This process helps prevent the housekeeping telemetry from being overloaded with repeated instances of the same error.","2d98be0f-c7df-3dec-82a6-ade1a628100b":"The CCM Control Task is responsible for starting up the DPU Flight Software (FSW) and ensuring a successful boot. It does this by waiting on temporary semaphores, each with a 5-second timeout, after launching the SCU Interface Task and the CCM Command Task. If both tasks signal that they have initialized successfully by releasing their semaphores, the CCM Control Task updates the BC_INDEX parameter in EEPROM to record the successful boot. If either task fails to signal successful initialization, the CCM Control Task disables the watchdog strobe, causing the DPU to reboot. This approach is used because at least these two tasks need to be running to enable ground contact and command capability. After initialization, the CCM Control Task waits on a binary semaphore, which is released by the SCUI Command ISR when a 1 Hz Clock Message is received; if no Clock Message arrives, the semaphore times out after 1.5 seconds. The CCM Control Task continues running to generate and send DPU housekeeping data at set intervals, carry out periodic processing, and handle memory dump commands. It also makes a final call to ccmErrEnq() so that if an interrupt service routine encounters an error, the global error variable value is queued into the Error/Event Queue during this task's regular processing.","14846b9d-d5bd-32d2-9f02-ee41e8a3797b":"The DPA CSC accesses events from the TMALI_EVENT_QUEUE using an API that includes two functions: tmaliWait() and tmaliNextEvent(). For optimal performance, the DPA CSC will inline the tmaliNextEvent() function to eliminate the overhead of repeated function calls, store each fetched event in a register to process it entirely before obtaining the next one, and rely on tmaliNextEvent() having no internal error checking to increase speed. Consequently, the DPA CSC is responsible for monitoring the count of events it retrieves and ensuring this matches the number reported by tmaliWait().","80150773-c06a-3d3f-9935-9d4bcca2bc9a":"The TMALI CSC gathers housekeeping data, which can be accessed by invoking tmaliHkGet(). The housekeeping information from the TMALI CSC is provided in the TMALI_HK data structure.","663c1163-fd4e-35e2-abb6-4c47fc49bdd4":"To prevent the loss of error counts from exceeding their maximum value, ccmErrEnq() verifies that the error count for any specific error does not surpass 250 during each high-rate housekeeping reporting interval. If the error count goes above 250 within a single reporting period, ccmErrEnq() will queue an S_ccm_ERR_REPEAT error along with the current count, then reset its error tracking system.","1c2e1322-c61a-31cf-9e15-8e3947ca0a16":"The Telescope Module Access Library and Interface (TMALI) CSC is responsible for handling the detector event queue and offers an API that allows data processing algorithms to access and retrieve detector events from this queue.","1e60d487-9892-3a18-a02b-4e5d7aa64259":"This function is invoked by the MIL-STD-1553 Command Interrupt Service Routine once per second (triggered by the arrival of the Clock Message) to signal the CCM Control Task to resume, which waits on a semaphore after it finishes its work.","e74f9800-7d16-3e6b-b471-427abfb20195":"This routine retrieves housekeeping data stored for the TMALI CSC, including certain DCI parameters, and resets the TMALI internal counters to zero. If the pointer to a TMALI_HK structure provided by the caller is NIL, no data is returned, but the internal counters are still reset. Two out of four error counters are updated within an ISR context, so these counters must be implemented in a way that is safe for task switching. While VxWorks could handle this with a counting semaphore, the TMALI CSC uses a faster approach by employing continuously running error counters and carefully updating the reported error count with an additional temporary variable. Since incrementing and assigning 32-bit unsigned integers are atomic operations, the counters are safe for use in tasks, and no error events are missed. As a result, the error totals reported by the tmaliHkGet() function accurately reflect all errors that occurred, with no loss of error information due to internal updates.","d6b7acb6-fab6-3142-a91d-709b94733e22":"Each time the CCM Control runs, it invokes ccmPerProcess() to manage regular processing tasks. These include updating analog-to-digital conversions, monitoring DPU tasks, generating ICU heartbeat messages, and activating the watchdog strobe. The ccmHealthChk() function, which is called within ccmPerProcess(), checks whether other tasks are running properly by tracking the elapsed time since each last checked in. Tasks notify the CCM Control Task of their operation by calling ccmTaskReport() and providing their respective task index. Every task has a defined execution frequency; if a task does not run as scheduled, this is flagged as an error in DPU housekeeping. If the Command Dispatch Task does not report for an extended time, the DPU will reboot, because without it, DPU commands cannot be processed; otherwise, the system will simply strobe the watchdog.","207c506d-8917-34dd-8465-51972c8f0d7c":"This routine allows configuration of the DCI windowing parameters for DCI data acquisition. It first validates the provided window specification before instructing the DCI driver to modify the hardware windowing parameters. If the settings are invalid, the function returns an error and does not enable hardware windowing. Upon successful validation, the function sets the specified hardware windowing parameters and activates the hardware windowing feature.","0607f776-bfb5-30d9-8da4-255be7ea627c":"This function can be invoked by any CSC to log an error or event that needs to be recorded in the DPU housekeeping. If it is called from within an interrupt context, it sets a static global variable, ccmISRError, so that the error can be queued later by ccmCtrlTask(), since the error/event queue is protected by a semaphore and semaphores cannot be used within an ISR. The error queue semaphore uses priority inversion protection to help avoid conflicts if multiple callers with different priorities attempt access at the same time. Additionally, this function substitutes a frequently recurring error with a special repeat error code, which is used to indicate that the same error has occurred multiple times during the most recent high frequency reporting period. This repeat error code is reported following the original error code.","182934c6-09d7-31b0-a5df-fc581c7f1a81":"The ccmErrEnq() function can be invoked from within an interrupt context. However, because using the mutual exclusion method (like a semaphore) is not allowed in this context, the system instead assigns the relevant error code to a global variable, ccmISRerror. When ccmTask() runs next, it will add this error to the error queue. This approach means that if multiple errors happen in interrupt context before ccmTask() has a chance to execute, earlier errors may be lost since each new error code will overwrite the previous one in ccmISRerror.","6c8b8d9e-3d7e-3d38-82cd-1e9d335fd296":"The Telescope Module Access Library and Interface (TMALI) CSC is composed of these elements:\n* A queue called TMALI_EVENT_QUEUE, implemented as a ring buffer, that stores detector events received from the DCI Driver via the data capture interface, which are waiting to be collected by the DPA CSC;\n* An API that allows the DPA CSC to retrieve detector events from this queue, specifically through the tmaliNextEvent() and tmaliWait() functions.\n* A collection of API functions that let the DPA CSC configure the DCI interface, including tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet(), and tmaliDataTimeoutGet().\n* An API function for housekeeping, tmaliHkGet(), which collects CSC status data when requested by the Command and Control Task.\n* The functions tmaliTask() and the interrupt service routine tmaliTransferToQueueISR(), which coordinate using a semaphore to manage moving data from the DCI to the queue.\n* An ISR, tmaliDciErrorReportedISR(), which is installed as a hook routine in the DCI Driver to monitor and track the number of errors the DCI Driver reports.","294a7051-ebd2-3120-95f0-4cc834f4b194":"This function retrieves the current frame depth setting for the Ping-Pong buffers used by the DCI CSC. The frame depth defines how many frames are loaded into the selected Ping-Pong buffer before an interrupt occurs. The initial frame depth is set by the parameter given when starting the tmaliTask. The value returned is the presently active frame depth, which may not match the last set value because the new setting only becomes active when data moves from the hardware Ping-Pong buffer to the TMALI queue, triggered by a frame or timeout interrupt (refer to section 5.13.2.3).","a26057b2-789e-3057-aa8a-a6628ac484fc":"When the tmaliTransferToQueueISR() interrupt service routine is triggered, it releases a semaphore to wake up the tmaliTask(), which is responsible for transferring data to the queue via the VME bus. The tmaliTask() performs this data transfer by calling the read() function provided by the DCI Driver, which uses a high-speed assembly routine. Because the TMALI ring buffer is structured as an array, tmaliTask() must check the TMALI_EVENT_QUEUE to determine if all needed data in the DCI buffer can be read with a single read() operation or if two separate read() actions are necessary to manage the wrap-around at the end of the ring buffer. Additionally, tmaliTask() needs to check for enough available space to accept the data stored in the Ping-Pong buffer. If there is not enough room to accommodate all frames, it discards the entire readable section of the Ping-Pong buffer and reports the S_TMALI_QUEUE_FULL error through the ccmErrEnq mechanism. Only complete CCD frames are discarded, since the DCI hardware ensures Ping-Pong switches coincide with CCD frame boundaries. The strategy of discarding the newer data is chosen because, from a scientific perspective, data collected immediately after a burst are more valuable than data obtained later.","3fedffab-ecd8-364a-8ef0-41e406f67349":"The ccmErrEnq() function monitors the last error that was reported and keeps a count of how often it occurs. After an error code is reported, it is saved as the previous error in ccmErrEnq(). If the same error code is reported consecutively, the function increases a repetition counter for that error. When an error code is reported multiple times within a single high-rate housekeeping reporting period, the function queues a special error, S_ccm_ERR_REPEAT, and includes the number of repetitions in the least significant byte. This system helps prevent the housekeeping telemetry from being overloaded with repeated instances of the same error.","9094754e-cf4a-3fb7-8159-25d10c9e18ae":"The ccmErrEnq() function can be invoked from within an interrupt context. However, because using the mutual exclusion method (like a semaphore) is not allowed in this context, the system instead assigns the relevant error code to a global variable, ccmISRerror. When ccmTask() runs next, it will add this error to the error queue. This approach means that if multiple errors happen in interrupt context before ccmTask() has a chance to execute, earlier errors may be lost since each new error code will overwrite the previous one in the global variable.","7b1d1f25-6ff8-348c-b6bf-5f1705716a0f":"There are two methods available for uploading data to the DPU:\n* Using the Memory Poke command (D_MEM_DAT_POKE), or\n* Using the Memory Upload command (D_MEM_DAT_UPLD).\nThe Memory Poke command should be used when transferring a small amount of data (Z bytes or fewer) to a specific DPU memory location, with the Z-byte limit defined by Company X's maximum command length restriction.","a78cb0f7-4a56-315b-9707-9d1a999b9433":"The CCM Control Task is responsible for processing memory dump commands. When a data dump is requested, the CCM Control Task divides the dump into smaller segments and transfers a part of the data each time it is activated. This deferred approach ensures that large dumps do not monopolize CPU resources or occupy the high-priority CCM Command Dispatch Task for too long.","13a33233-e355-37f6-af42-e3c52ef4a137":"Global Data refers to the data items accessed globally by this CSC.","abb354a7-50a8-3ce4-ba91-99c573f53939":"If there is no data in the TMALI queue, this function will block on a semaphore and wait for the ISR to signal that events are available. If data is already present in the TMALI queue or the semaphore has been acquired, the function checks how many events are in the queue and returns this count to the caller. The function takes a ‘TickstoWait’ parameter, which defines the maximum time in kernel ticks it will wait for data to become available. If this parameter is set to the symbolic value ‘FOREVER,’ the function will wait indefinitely until data is available. If a timeout is specified and no data becomes available within that period, the function returns zero (indicating no events available). If the tmali task has not been initialized, the function returns an error.","144eb452-93dc-337a-a715-b8f0f85648fe":"The DPU receives commands through two interfaces: the MIL-STD-1553 interface from the Spacecraft and the SSI interface from the ICU. Any command intended for the DPU can originate from either the SCU or the ICU. The possible sources for DPU commands are as follows:\n- ICU: commands created and transmitted by the ICU over the SSI interface.\n- SCU: commands created and transmitted by the SCU over the 1553 interface.\n- G-ICU: commands generated on the ground, then sent to the DPU via the ICU and SSI.\n- G-SCU: commands generated on the ground, then sent to the DPU through the SCU and 1553.","47b32ee5-d3c0-3863-b2d3-2eabc3b0fd23":"When the system boots up, there is no error queue because it has not been initialized yet. Any errors that arise during this initial phase are stored in the global task variable errno. For further details about errno, see section 2.3.7 of the VxWorks® Programmer’s Guide. After the error queues have been created, any value set in errno is added to the Error Queue using the ccmErrEnq() function.","00ea49ee-4bb7-391c-9764-6de09ffe3fae":"The tmaliBitArrangementSet() function allows you to configure the bit arrangement of the DCI control and status register.","ed97367d-60ae-37b7-a0bc-1d9d617425cc":"The Telescope Module Access Library and Interface (TMALI) CSC is composed of these elements:\n* A queue called TMALI_EVENT_QUEUE, implemented as a ring buffer, that stores detector events received from the DCI Driver via the data capture interface, which are waiting to be accessed by the DPA CSC;\n* An API that allows the DPA CSC to retrieve detector events from this queue, specifically through the tmaliNextEvent() and tmaliWait() functions;\n* A collection of API functions that let the DPA CSC configure the DCI interface, including tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet(), and tmaliDataTimeoutGet();\n* An API function for housekeeping, tmaliHkGet(), which collects CSC status data when requested by the Command and Control Task;\n* The tmaliTask() task and the tmaliTransferToQueueISR() interrupt service routine, which use a semaphore to coordinate moving data from the DCI to the queue;\n* An error-handling interrupt service routine, tmaliDciErrorReportedISR(), which acts as a hook to the DCI Driver and tracks the number of errors reported by the DCI driver.","42e4ddf0-576a-3f3a-a5b2-5f6ae43043ad":"There are two methods available for uploading data to the DPU:\n* Using the Memory Poke command (D_MEM_DAT_POKE), or\n* Using the Memory Upload command (D_MEM_DAT_UPLD).\nThe Memory Poke command should be used when transferring a small amount of data (Z bytes or fewer) to a specific DPU memory location, with the Z-byte limit defined by Company X's maximum command length restriction.","406d5983-3c5c-3633-9e68-6ca9d74eb433":"This function can be invoked by any CSC to log an error or event that needs to be recorded in the DPU housekeeping. If it is called from within an interrupt context, it sets a static global variable, ccmISRError, so that the error can be added to the queue later (as handled by ccmCtrlTask()), since the queue is protected by a semaphore and semaphores cannot be used within an ISR. The semaphore protecting the error queue is configured with priority inversion protection to minimize issues when multiple callers with different priorities access it. Additionally, this function replaces errors that occur frequently with a dedicated repeat error code, which is used after the initial error code to indicate that the same error has happened multiple times during the most recent high-rate reporting interval.","1ccc0f44-d7cb-363b-8daa-42c9cbda4e48":"When the tmaliTransferToQueueISR() interrupt service routine is triggered, it releases a semaphore to wake up the tmaliTask(), which is responsible for transferring data to the queue via the VME bus. The tmaliTask() performs this data transfer by calling the read() function provided by the DCI Driver, which uses a high-speed assembly routine. Since the TMALI ring buffer is structured as an array, tmaliTask() must check the TMALI_EVENT_QUEUE to determine if all needed data from the DCI buffer can be retrieved with a single read() operation or if two reads are required due to the ring buffer wrapping around at the end. tmaliTask() must also verify that there is enough space available to store all incoming data from the Ping-Pong buffer. If there is not enough space to accommodate all the data frames, tmaliTask() will discard all frames from the readable Ping-Pong buffer and report the S_TMALI_QUEUE_FULL error using the ccmErrEnq mechanism. The discarded data will always consist of a whole number of CCD frames, as the DCI hardware ensures Ping-Pong switches only occur at CCD frame boundaries. This approach, where new data is discarded in favor of retaining older data, follows the scientific preference for preserving data collected immediately after a burst, as it is considered more valuable than data collected later.","8315d7d9-f1bb-3a29-9bb0-7fb8f91034eb":"The CSC uses a FIFO ring buffer to temporarily hold data received from the DCI before processing. This ring buffer is managed with two pointers, pIn and pOut, which track the buffer’s contents. The design of the pointers prioritizes simple buffer reading, requiring only one comparison to determine if the buffer is empty. The buffer stores Events, each four bytes in size, and both pointers reference these four-byte elements. Since all data from the DCI is provided in bytes, size conversions are necessary before data can be read.","5c6dd184-15cf-3b63-93e9-f88e90f97cbb":"To prevent the loss of error counts from rollover, ccmErrEnq() verifies that the number of occurrences for any given error does not exceed 250 during a single high rate housekeeping reporting period. If the error count for a specific period surpasses 250, ccmErrEnq() will queue an S_ccm_ERR_REPEAT error along with the current count, then reset its error tracking system.","f7aecaad-eb17-33cc-b06c-313bb1c98153":"When the system boots up, there is no error queue because it has not been initialized yet. Any errors that arise during this initial phase are stored in the global task variable errno. Further details on errno can be found in section 2.3.7 of the VxWorks® Programmer’s Guide. After the error queues have been created, any subsequent errors that set errno are added to the Error Queue using the ccmErrEnq() function.","677acf9d-95cd-3d75-bbb8-108ae99ab505":"When a command is received from the SCU through the 1553 interface or from the ICU through the SSI interface, the corresponding interrupt service routine (ISR) will place the command packet into the Command Queue and signal the semaphore to wake up ccmCmdTask(). Since the DPU can issue commands to itself, commands may be received either in interrupt context or in task context. As a result, the CCM uses two separate queues: one dedicated to interrupt context that does not use semaphore protection, and another for task context that is protected by a semaphore.","b1a3ea21-45cc-3752-9545-11b23346c0ed":"The S_ccm_ERR_REPEAT error uses its lowest byte to indicate how many times the last error was repeated. When a new error occurs as previously described, ccmErrEnq() will add both a S_ccm_ERR_REPEAT for any prior repeated error and the new error to the queue. To ensure that original error codes and their repeat counts remain grouped within the same error packet, ccmMkHkErr() enqueues a special error code, S_ccm_ERRQ_FLUSH. This serves as a signal to ccmErrEnq() to reset its error tracking system and to enqueue any repeat counts linked to a specific error.","64a62731-7b98-308a-8aa7-6280741deb37":"The S_ccm_ERR_REPEAT error uses its lowest byte to indicate how many times the last error was repeated. When a new error occurs as previously described, ccmErrEnq() will add both a S_ccm_ERR_REPEAT for any prior repeated error and the new error to the queue. To ensure that original error codes and their repeat counts remain in the same error packet, ccmMkHkErr() adds a special error code, S_ccm_ERRQ_FLUSH, which signals to ccmErrEnq() to reset its error tracking and add any repeat counts linked to a specific error.","138ca949-ad6a-35d3-88a4-03abb0ff4794":"This function is invoked by both the MIL-STD-1553 Command ISR and the SSI Interface ISR whenever a command is received from the SCU or the ICU, in order to add the command to the queue and signal the CCM Command Dispatch Task to process the command.","16598da8-f59a-3689-9801-4c35905e8346":"At startup, the TMALI CSC is initialized by creating the tmaliTask() using the default parameters. This task sets up memory for the TMALI_EVENT_QUEUE, configures DCI interrupt service routines, initializes static variables and data structures, and then continuously runs a loop where it moves data from the DCI to the TMALI queue, regulated by the semDciWait semaphore.","77082507-d2bf-3ad7-9ba3-5eb3bc2e6228":"The DPU generates eight different kinds of housekeeping packets for control and monitoring purposes.","d0ccf8ba-3a19-31ec-8ebd-f427be4c23a5":"This function allows retrieval of the current data timeout value utilized by the DCI, returning the value in milliseconds. Details about the timeout can be found in document 036911400, section 4.3.2.4.1.3.","f6d42825-93ff-3c93-97a7-34b7c8a6631b":"During standard operation, the system receives frames roughly every 11 milliseconds. The DCI hardware will issue an interrupt if some event data has arrived in one of the Ping-Pong buffers and a specified, adjustable period has elapsed without any further events. This data timeout interrupt is not considered an error; instead, it usually signifies that the current data collection is finished. The purpose of the data timeout interrupt is to enable the TMALI CSC to access the remaining events in the DCI Ping-Pong buffer. The tmaliDciTimeoutSet() function in the DCI Driver API allows adjustment of this timeout value.","58f96747-3b38-3b87-b88e-6234010d52cb":"Data can be uploaded to various locations, such as DRAM, EEPROM, hardware registers, or the EEPROM filesystem. The D_MEM_DAT_UPLD command determines where the data will be uploaded. When targeting the EEPROM filesystem, a block number is given instead of a memory address; the DPU flight software then generates a filename in the format eefs1:DPU_blk.##, with ## representing the block number. After all the upload data has been received, it is saved to this file in the EEPROM filesystem. If the file already exists, it is replaced. The EEPROM filesystem can be reset using the D_MEM_DISK_INIT command.","71b2fd83-b042-33a9-ab42-cebec7d2b637":"This routine allows configuration of the DCI windowing parameters for DCI data acquisition. It first validates the provided window specification before instructing the DCI driver to modify the hardware windowing parameters. If the specification is invalid, the function returns an error and does not enable hardware windowing. Upon successful validation, the function sets the specified hardware windowing parameters and enables the hardware windowing feature.","5530a803-f64e-34b4-9cd9-4dfc68f401d4":"The DPU generates eight different kinds of housekeeping packets for control and monitoring purposes.","0206f39c-fe52-3c51-827b-55372a174fe0":"The CCM Control Task is responsible for processing memory dump commands. When a data dump is requested, the CCM Control Task divides the dump into smaller segments and transfers a part of the data each time it is activated. This deferred approach ensures that large dumps do not monopolize CPU resources or occupy the high-priority CCM Command Dispatch Task for too long.","b993686e-1a46-3ac5-b2a4-712e34d9774a":"After all events from the Ping-Pong buffer are moved to the TMALI_EVENT_QUEUE, the tamliTask() function must re-enable the hardware so it can swap the Ping-Pong buffer when needed. If TMALI does not finish moving data from the ping buffer before the pong buffer fills up, the DCI Driver will trigger an error interrupt, which calls the tmaliDciErrorReportedISR(). This interrupt service routine sets an error flag so tmaliTask() can perform recovery steps. Additionally, tmaliDciErrorReportedISR() releases the semDciWait semaphore to wake up tmaliTask(), even though it is likely already running, in case tmaliTask() has just finished data transfer at the moment the error occurs. The error occurrence will be recorded in TMALI_HK. Until tmaliTask() finishes the previous data transfer, recognizes the error flag, and manually forces a Ping-Pong buffer swap and re-enables data collection, the DCI hardware will discard incoming events. This ensures that only full frames are stored in the Ping-Pong buffer for processing. Under typical conditions, this error should not occur, as tmaliTask() should be quick enough to retrieve data from the DCI Ping-Pong buffer. If event processing falls behind, it should instead result in a TMALI queue full state, which is logged as an S_TMALI_QUEUE_FULL error using the ccmErrEnq() system.","3d68bfa5-ad37-33b3-8672-d2ef50464c0f":"This function configures the frame depth for the Ping-Pong buffers utilized by the DCI CSC. Frame depth specifies how many frames are loaded into the chosen Ping-Pong buffer before triggering an interrupt. The initial frame depth value is set according to the parameter received when the tmaliTask starts. The maximum frame depth that can be set is 64 frames; if a higher value is requested, the system will default to a timeout value of V frames. Adjusting the frame depth may be slightly delayed if there is ongoing activity on the DCI bus, and changes typically occur when the DCI has just indicated that a frame level has been reached or a timeout has happened. This approach reduces the risk of modifying the setting during a critical frame event. Altering the frame depth while the DCI CSC is actively processing may cause unpredictable behavior. If a new ‘tmaliDciFrameDepthSet’ command is received before the previous change has taken effect, the new command will replace the earlier one, and the DCI will update to the most recent value as soon as possible.","9621ed45-dd12-3a6d-9aa1-db95b4b7fd0a":"If more than 65,535 bytes must be uploaded, the file should be divided into several smaller files, each no larger than 65,535 bytes, and these partial uploads should be transmitted sequentially. The DPU FSW is capable of handling incoming upload commands that arrive out of order due to the use of sequence numbers. There is no specific deadline for completing each partial upload, allowing a long upload to be spread over multiple ground passes. While an upload is ongoing, the last sequence number can be provided to the DPU FSW, and it will return a list of any missing sequence numbers through event S_ccm_MISSING_SEQNO. If it becomes necessary to stop an in-progress upload, the D_MEM_DAT_CNCL command can be used to abort it.","e4f70e1e-8be1-335f-9425-6a23d4108324":"This function allows the user to specify the data timeout for the DCI in milliseconds. The initial frame depth value is set based on the parameter given when starting the tmaliTask. The timeout cannot be set to a value greater than X seconds; if a larger value is requested, the timeout will revert to the default value of X milliseconds.","a8c0bbd3-0871-3761-ae67-a8281a387eb3":"The TMALI CSC acts as an intermediary, managing EVENT data received from the DCI Driver CSC and forwarding it to the DPA CSC. TMALI waits for the DCI CSC to signal that either the frame limit or a data timeout has occurred in the Ping-Pong buffer, indicating that EVENT data is available. Once notified, TMALI retrieves all EVENT data from the DCI and informs the DCI that it is free to switch Ping-Pong buffers when ready. TMALI then releases a semaphore to allow the tmaliWait() call in the DPA to proceed.","f9265c63-7317-3874-a3cd-483e6e041dd8":"The DPA CSC invokes tmaliWait() to check the number of pending EVENTs. If tmaliWait() returns a value above zero, the DPA proceeds to call tmaliNextEvent() once for each EVENT that needs to be retrieved.","c8b8bfe7-d485-3f2e-953b-5a26844e7342":"The DPA CSC accesses events from the TMALI_EVENT_QUEUE using an API that includes two functions: tmaliWait() and tmaliNextEvent(). For optimal performance, the following practices are important:\n* The DPA CSC will use inlining for the tmaliNextEvent() function to eliminate the overhead of calling the function for each event,\n* Each event obtained will be loaded into a register by the DPA CSC, which will then finish processing that event while it remains in the register before moving to the next,\n* Since tmaliNextEvent() does not perform any error checking to ensure maximum speed, the DPA CSC is responsible for tracking the count of events retrieved and verifying it matches the number reported by tmaliWait().","340fcf1b-3d14-3f79-8893-b8ce71433765":"The DPU-CCM CSC offers a centralized error reporting function, ccmErrEnq(), which other FSW tasks can use to log errors. On each activation, ccmTask() determines whether it's time to assemble an error or event packet for ground transmission. If needed, ccmTask() invokes ccmHkMkError() to generate the packet and send it to DPU-SCUI for downlink.","5ddca483-5b28-3e2a-aeec-a06fed997884":"For large memory uploads to the DPU, such as during a software patch or a complete software update, the standard memory upload process is followed. This process involves sending multiple D_MEM_DAT_UPLD commands, which together form a single \"virtual\" upload. CCSDS-like sequence flags are used to enable the DPU flight software to accept up to 65,535 bytes in one \"virtual\" upload. The data received in each D_MEM_DAT_UPLD command is temporarily stored in DRAM until all sequence numbers for the upload have been received. After the final command arrives, the flight software checks that all sequence numbers are accounted for and the overall upload checksum is correct, then writes the entire buffered data to the target memory location specified in the initial upload command.","952110df-29a7-3265-8d24-e7cad92f15c7":"The Command and Control CSC begins its initialization by having the operating system’s startup task, usrRoot(), spawn the CCM Control Task, ccmCtrlTask(). After being started, this task runs ccmInit(), which sets up the error/event queue, creates the required semaphores, and installs various ISRs. It then proceeds to launch the other tasks that make up the DPU flight software. Upon startup, the CCM Control Task retrieves default DPU configuration settings from the SYSTEM_CONFIG_AREA in EEPROM. If the checksum for this area fails, predefined default values are used instead. The CCM Control Task continues by initializing the remaining CSCs, either by directly calling their initialization functions or, if they have their own tasks, by starting those tasks with the VxWorks® taskSpawn() function. During CSC initialization, it passes the startup defaults retrieved from EEPROM to each initialization function as parameters. Additionally, ccmInit() sets up the command length verification table by calling ccmCmdLengthInit(), which the command processor later uses to confirm command lengths for newly received commands.","ca2836cb-29de-39a7-898b-ea1e69059578":"During normal operation, frames are received roughly every 11 milliseconds. The DCI hardware will trigger an interrupt if event data is present in one of the Ping-Pong buffers and a set period passes without any further event arrivals. This data timeout interrupt is not an error; it usually signifies that the current exposure cycle has finished. It enables the TMALI CSC to collect the remaining events from the DCI Ping-Pong buffer. The tmaliDciTimeoutSet() function in the DCI Driver allows this timeout interval to be configured.","f018e08c-525d-3557-a377-b316b27047ab":"When the system boots up, there is no error queue because it has not been initialized yet. Any errors that arise during this initial phase are stored in the global task variable errno. Further details on errno can be found in section 2.3.7 of the VxWorks® Programmer’s Guide. After the error queues have been created, any subsequent errors that set errno are added to the Error Queue using the ccmErrEnq() function.","bcc0333b-e0d8-3b5c-a2ee-2b6503dfde4c":"During initialization, the TMALI CSC sets up an ISR hook function, tmaliTransferToQueueISR(), within the DCI Driver. This routine is called either when the DCI interface hits the specified frame limit in the Ping-Pong buffer or when a data reception timeout occurs on the DCI interface.","5cd610f3-dc90-3662-ab7e-70f344bc19c1":"During regular operation, frames are received roughly every 11 milliseconds. The DCI hardware will trigger an interrupt if event data has arrived in one of the Ping-Pong buffers and a set period has elapsed with no further events being received. This data timeout interrupt is expected behavior and usually signifies that the current exposure cycle is finished. It enables the TMALI CSC to collect any remaining events from the DCI Ping-Pong buffer. The DCI Driver offers the tmaliDciTimeoutSet() function as an API for modifying the timeout duration.","3d3c847c-86be-31b8-a857-0d109e53fa2d":"During initialization, the TMALI CSC sets up an ISR hook function, tmaliTransferToQueueISR(), in the DCI Driver. This routine is called either when the DCI interface hits the configured frame limit in the Ping-Pong buffer or when a data reception timeout occurs on the DCI interface.","662b5d71-25bc-37bf-a61b-37b2c585d794":"This function blocks on a semaphore and waits for events to become available in the TMALI queue if none are present when called, as signaled by the ISR. If data is already in the TMALI queue or the semaphore has already been taken, it calculates and returns the number of available events to the caller. The ‘TickstoWait’ parameter defines the maximum duration (in kernel ticks) the function will wait for data. If ‘TickstoWait’ is set to the symbolic value ‘FOREVER’, the function waits indefinitely until data arrives. If a timeout is specified and no data becomes available within that time, the function returns zero, indicating no events are available. If the TMALI task has not been initialized, the function returns an error.","f7723ed1-c1e3-32e4-80c5-68be98104d52":"This function can be invoked by any CSC to log an error or event that needs to be recorded in the DPU housekeeping. If it is called from within an interrupt context, it sets a static global variable, ccmISRError, so that the error can be added to the queue later (as handled by ccmCtrlTask()), since the queue is protected by a semaphore and semaphores cannot be used within an ISR. The semaphore protecting the error queue is configured with priority inversion protection to minimize issues when multiple callers with different priorities access it. Additionally, this function replaces errors that occur frequently with a dedicated repeat error code, which is used after the initial error code to indicate that the same error has happened multiple times during the most recent high-rate reporting interval.","4cefbc60-9714-3794-821a-983469298eab":"The Telescope Module Access Library and Interface (TMALI) CSC is composed of these elements:\n* A queue called TMALI_EVENT_QUEUE, implemented as a ring buffer, that stores detector events received from the DCI Driver via the data capture interface, which are waiting to be collected by the DPA CSC;\n* An API that allows the DPA CSC to retrieve detector events from this queue, specifically through the tmaliNextEvent() and tmaliWait() functions.\n* A collection of API functions that let the DPA CSC configure the DCI interface, including tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet(), and tmaliDataTimeoutGet().\n* An API function for housekeeping, tmaliHkGet(), which collects CSC status data when requested by the Command and Control Task.\n* The functions tmaliTask() and the interrupt service routine tmaliTransferToQueueISR(), which coordinate using a semaphore to manage moving data from the DCI to the queue.\n* An ISR, tmaliDciErrorReportedISR(), which is installed as a hook routine in the DCI Driver to monitor and track the number of errors the DCI Driver reports.","4f6fb9a6-44f5-325e-8080-636c41718181":"The DPU receives commands through two interfaces: the MIL-STD-1553 interface from the Spacecraft and the SSI interface from the ICU. Any command intended for the DPU can originate from either the SCU or the ICU. The possible sources for DPU commands are as follows:\n* ICU – commands created and transmitted by the ICU over the SSI interface.\n* SCU – commands created and transmitted by the SCU over the 1553 interface.\n* G-ICU – commands generated on the ground and sent to the DPU through the ICU via SSI.\n* G-SCU – commands generated on the ground and sent to the DPU through the SCU via 1553.","69251ec5-bee9-31c3-94c5-4cda07e3e0b9":"For large memory uploads to the DPU, such as during a software patch or a complete software update, the standard memory upload process is followed. This process involves sending multiple D_MEM_DAT_UPLD commands, which together form a single \"virtual\" upload. CCSDS-like sequence flags are used to enable the DPU flight software to accept up to 65,535 bytes in one \"virtual\" upload. The data received in each D_MEM_DAT_UPLD command is temporarily stored in DRAM until all sequence numbers for the upload have been received. After the final command arrives, the flight software checks that all sequence numbers are accounted for and the overall upload checksum is correct, then writes the entire buffered data to the target memory location specified in the initial upload command.","cba4501b-afd7-3efb-a398-b140529b1ff0":"If there is no data in the TMALI queue, this function will block on a semaphore and wait for the ISR to signal that events are available. If data is already present in the TMALI queue or the semaphore has been acquired, the function calculates and returns the number of available events to the caller. The parameter ‘TickstoWait’ defines how long the function can wait for data in terms of kernel ticks. If ‘TickstoWait’ is set to the symbolic value ‘FOREVER’, the function will wait indefinitely until data becomes available. If a timeout is specified and no data arrives within that period, the function returns zero to indicate no events are available. If the tmali task has not been initialized, the function returns an error.","98992ace-c8ef-3eb3-a46d-b1fef3c7f1d8":"The DPA CSC invokes tmaliWait() to check the number of pending EVENTs. If tmaliWait() returns a value above zero, the DPA proceeds to call tmaliNextEvent() once for each EVENT that needs to be retrieved.","f9dfa81c-73bc-321e-8aa5-ec962c36c703":"The Telescope Module Access Library and Interface (TMALI) CSC is responsible for handling the detector event queue and offers an API that allows data processing algorithms to access and retrieve detector events from this queue.","7cf578ce-6a0d-341d-a1f8-5ec45d9ecfd5":"Ring buffer data structure\tThe pIn and pOut pointers are specified as:\n* pIn\t- most recent position where data was written\n* pOut\t- most recent position that was emptied","5b08dde6-f7a9-3837-a419-393fc4a10be3":"Ring buffer data structure\tThe pIn and pOut pointers are specified as:\n* pIn\t- most recent position where data was written\n* pOut\t- most recent position that was emptied","2b53e58b-b3d9-3029-bc71-b192e31f298a":"The ring buffer uses a dedicated pointer, pEnd, to mark the buffer’s final position. This pointer indicates the last accessible spot in the buffer. Whenever a pointer is about to move forward, it must be checked if it is currently at this last position. If so, it should be reset to the buffer’s starting point, indicated by pBuf; if not, it can simply be advanced by one.","51d70ac6-c190-314f-99a9-d33b0c7261f7":"This function configures the frame depth for the Ping-Pong buffers utilized by the DCI CSC. Frame depth specifies how many frames are loaded into the chosen Ping-Pong buffer before triggering an interrupt. The initial frame depth value is set according to the parameter received when the tmaliTask starts. The maximum frame depth that can be set is 64 frames; if a higher value is requested, the system will default to a timeout value of V frames. Adjusting the frame depth may be slightly delayed if there is ongoing activity on the DCI bus, and changes typically occur when the DCI has just indicated that a frame level has been reached or a timeout has happened. This approach reduces the risk of modifying the setting during a critical frame event. Altering the frame depth while the DCI CSC is actively processing may cause unpredictable behavior. If a new ‘tmaliDciFrameDepthSet’ command is received before the previous change has taken effect, the new command will replace the earlier one, and the DCI will update to the most recent value as soon as possible.","7be33dd4-f6b4-31fd-9586-81606064efe7":"To prevent the loss of error counts from rollover, ccmErrEnq() verifies that the error count for any specific error does not exceed 250 within a single high-rate housekeeping reporting period. If the error count surpasses 250 during that period, ccmErrEnq() will enqueue an S_ccm_ERR_REPEAT error along with the current count and reset its error tracking system.","035ea18e-468f-3a98-b85d-561cec40ce84":"The ccmErrEnq() function can be invoked from within an interrupt context. However, because using the mutual exclusion method (like a semaphore) is not allowed in this context, the system instead assigns the relevant error code to a global variable, ccmISRerror. When ccmTask() runs next, it will add this error to the error queue. This approach means that if multiple errors happen in interrupt context before ccmTask() has a chance to execute, only the most recent error will be kept, as any earlier errors in ccmISRerror will be overwritten.","ced8ead4-8286-3925-95b8-15e3287635d3":"This routine allows configuration of the DCI windowing parameters for DCI data acquisition. It first validates the provided window specification before instructing the DCI driver to modify the hardware windowing parameters. If the settings are invalid, the function returns an error and does not enable hardware windowing. Upon successful validation, the function sets the specified hardware windowing parameters and activates the hardware windowing feature.","0f933526-af70-33ce-b341-7b55f7235f97":"The Command and Control (CCM) CSC, a Level 2 reusable component adapted from the INSTRUMENT Y project, encompasses the following key elements:\n* A Control Task, named ccmCtrlTask(), responsible for initializing the DPU flight software during system startup, creating additional tasks, managing the scheduling of DPU housekeeping data packet generation, overseeing the operation of tasks, and coordinating the timing of periodic functions such as sending heartbeat messages and activating the watchdog.\n* A Command Dispatch Task, called ccmCmdTask(), which handles the reception and routing of real-time commands obtained from either the SCU or ICU.\n\nPrimary data structures used include:\n* A Static Data table that records the current operational status, including housekeeping data generation rates, specific CCM flags, and the count of executed commands.\n* A Command Queue that temporarily stores incoming commands—received via interrupt from either the ICU or SCU—awaiting processing.\n* An Error/Event Queue that collects error and event codes generated by the DPU flight software, which are periodically extracted from the queue, compiled into telemetry packets at set intervals, and transmitted as part of the DPU housekeeping information.","97c6dc14-862c-30cd-beba-b9c88ae2133a":"The Command and Control CSC begins initialization by having the operating system’s startup task, usrRoot(), spawn the CCM Control Task, ccmCtrlTask(). Once started, this task invokes ccmInit(), which sets up the error and event queue, creates the required semaphores, and installs various interrupt service routines (ISRs). It then spawns the other tasks that make up the DPU Flight Software. During startup, the CCM Control Task reads the default DPU configuration settings from the SYSTEM_CONFIG_AREA in EEPROM. If the checksum for this area is invalid, it falls back to hardcoded defaults. Initialization of other CSCs is handled by the CCM Control Task, either by directly calling their initialization functions or, if they have their own tasks, by spawning them with the VxWorks® taskSpawn() function. Startup defaults obtained from EEPROM are passed as parameters to the initialization functions. Additionally, ccmInit() sets up the command length verification table by calling ccmCmdLengthInit(), which the command processor later uses to confirm command lengths for newly received commands.","25d78690-834b-3a98-9beb-4f977ccc3125":"Ring buffer data structure\tThe pIn and pOut pointers are specified as follows:\n* pIn – the most recent position where data was written\n* pOut – the most recent position that was left empty","42a80079-ccba-3a00-8019-40a4a59a0c29":"Ring buffer data structure\tThis setup means:\n* the management is straightforward, though one slot remains unused when the buffer is full, with the pIn pointer positioned just before the pOut pointer,\n* the buffer is considered empty when the pIn and pOut pointers have the same value.","fbef9dee-4240-3746-a8e1-dd47c0c8e4d1":"This function allows you to configure the DCI's bit arrangement. If bSpecialArrangement is set to TRUE, the DCI switches to special bit arrangement mode; if FALSE, it uses the default, non-rearranged mode.","a5e45f42-01ea-345f-911e-6230799a5dac":"Each DPU FSW task calls this function to indicate it has run, allowing ccmCtrlTask() to evaluate the operational health of the DPU FSW tasks.","f3fddda1-3520-3ec2-9e6e-41c9753ca5f5":"During initialization, the TMALI CSC sets up an ISR hook function, tmaliTransferToQueueISR(), within the DCI Driver. This routine is called either when the DCI interface hits the configured frame threshold in the Ping-Pong buffer or when a data reception timeout occurs on the DCI interface.","585dfbc2-30a4-37fb-9116-efe4efce2f3d":"The TMALI CSC gathers housekeeping data, which can be accessed by invoking tmaliHkGet(). The housekeeping information from the TMALI CSC is provided in the TMALI_HK data structure.","45dbc082-65e0-3758-ac9c-ec46d159ae10":"The S_ccm_ERR_REPEAT error uses its lowest byte to indicate how many times the last error was repeated. When a new error is detected as previously described, ccmErrEnq() will add a S_ccm_ERR_REPEAT entry to the queue for any error that was repeated, as well as add the new error. To ensure that original error codes and their repeat counts remain grouped in the same error packet, ccmMkHkErr() queues a special error code, S_ccm_ERRQ_FLUSH. This serves as a signal to ccmErrEnq() to reset its error tracking and to enqueue any repeat counts linked to specific errors.","6e194a13-5063-3e26-a2c8-91261c27e517":"The Command and Control (CCM) CSC, adapted from the INSTRUMENT Y project as a Level 2 reusable component, consists of these parts:\n* A Control Task (ccmCtrlTask()), responsible for initializing the DPU flight software during startup, launching other tasks, managing the scheduling of DPU housekeeping data packet generation, overseeing the functioning of various tasks, and handling the scheduling of periodic operations like sending the heartbeat message and activating the watchdog strobe.\n* A Command Dispatch Task (ccmCmdTask()), which collects and routes incoming real-time commands sent from either the SCU or ICU.\nKey data structures are:\n* A Static Data table that records operational status, including housekeeping data rates, CCM-specific indicators, and a count of processed commands.\n* A Command Queue that temporarily stores incoming commands, received via interrupts from the ICU or SCU.\n* An Error/Event Queue that gathers error and event codes generated by the DPU flight software; these codes are periodically extracted from the queue, incorporated into telemetry packets, and included in the DPU’s housekeeping data.","17cf5d55-03c7-3011-b7d7-1072b40292c4":"The CCM Control Task is responsible for starting up the DPU Flight Software (FSW) and ensuring a successful boot. It does this by waiting on temporary semaphores, each with a 5-second timeout, after launching the SCU Interface Task and the CCM Command Task. If both tasks signal that they have initialized successfully by releasing their semaphores, the CCM Control Task updates the BC_INDEX parameter in EEPROM to record the successful boot. If either task fails to signal successful initialization, the CCM Control Task disables the watchdog strobe, causing the DPU to reboot. This approach is used because at least these two tasks need to be running to enable ground contact and command capability. After this initial setup, the CCM Control Task waits on a binary semaphore, which is released by the SCUI Command ISR when the 1 Hz Clock Message is received. If the Clock Message is not received, the semaphore times out after 1.5 seconds. The CCM Control Task continues to operate, generating and sending DPU housekeeping data at set times, performing regular processing activities, and handling memory dump commands. Finally, a call to ccmErrEnq() ensures that if an error arises in an interrupt service routine, the error number is saved to a global variable and then added to the Error/Event Queue during the task’s regular execution.","db03215f-e926-3451-ab93-f2a59e4fbc72":"When a command is received from the SCU through the 1553 interface or from the ICU through the SSI interface, the corresponding interrupt service routine (ISR) will place the command packet into the Command Queue and signal the semaphore to wake up ccmCmdTask(). Since the DPU can issue commands to itself, commands may be received either in interrupt or task context. As a result, the CCM uses two separate queues: one designated for interrupt context that does not use semaphore protection, and another for task context that is protected by a semaphore.","8f72cbad-3883-33f5-b620-a78aa57d7f4e":"Determining the optimal frame depth in DCI will be based on results from benchmark testing. The default setting for frame depth is 10 frames. With the specified data, reading 10 frames of maximum size at the highest data transfer rate will take about 24 milliseconds.","25644cd6-30ef-3273-b131-b348e228ceb4":"Ring buffer data structure\tThis setup means:\n* the management is straightforward, though one slot remains unused when the buffer is full, with the pIn pointer positioned just before the pOut pointer,\n* the buffer is considered empty when the pIn and pOut pointers have the same value.","91c7dd15-734b-3b72-8139-25084df788a5":"The CSC uses a FIFO ring buffer to temporarily hold data received from the DCI before processing. This ring buffer is managed with two pointers, pIn and pOut, which track the buffer’s contents. The design of the pointers prioritizes simple buffer reading, requiring only one comparison to determine if the buffer is empty. The buffer stores Events, each four bytes in size, so the pointers reference these four-byte elements. Since all data from the DCI is provided in bytes, sizes must be converted before the data can be read.","f5a229cf-46ad-38fd-91fb-731287c46123":"This function allows retrieval of the current data timeout value utilized by the DCI, returning the present timeout duration in milliseconds. Details regarding the timeout can be found in document 036911400, section 4.3.2.4.1.3.","e8e16ca3-c084-384b-9315-49d36cfa4a5e":"When the tmaliTransferToQueueISR() interrupt service routine is triggered, it releases a semaphore to wake up the tmaliTask(), which is responsible for transferring data to the queue via the VME bus. The tmaliTask() performs this data transfer by calling the read() function provided by the DCI Driver, which uses a high-speed assembly routine. Because the TMALI ring buffer is structured as an array, tmaliTask() must check the TMALI_EVENT_QUEUE to determine if all needed data in the DCI buffer can be read with a single read() operation or if two separate read() actions are necessary to manage the wrap-around at the end of the ring buffer. Additionally, tmaliTask() needs to verify there is enough available space to receive the complete data from the Ping-Pong buffer. If there isn't enough room for all the frames, all of the data in the readable Ping-Pong buffer is discarded, and the S_TMALI_QUEUE_FULL error is reported through the ccmErrEnq mechanism. The system discards only whole CCD frames, since the DCI hardware ensures that changes between Ping-Pong buffers align with CCD frame boundaries. This approach, where new data is discarded in overflow cases, aligns with scientific priorities by favoring the retention of data collected immediately after a burst, as it is considered more valuable.","a98d05f0-94b8-3ed9-95f7-3f6754a8133b":"The D_MEM_BLK_DNLD command is used to download data from files stored in the EEPROM filesystem. Similar to the upload process, you only need to specify the block number, and the entire file associated with that block number will be downloaded. If you need to download data from anywhere outside the EEPROM filesystem, you should use the D_MEM_DAT_DNLD command. As mentioned earlier, downloads are processed in a deferred manner to prevent high CPU usage. On the ground, a single logical download will be received as multiple download packets, which must be combined in order to reconstruct the original data sequence.","f4fd0784-28c4-3aed-ab43-00450a6c5a64":"The ring buffer uses a dedicated pointer, pEnd, to mark the final position in the buffer. This pointer indicates the buffer’s last valid element. Whenever a pointer is about to move forward, it must be checked against pEnd. If it already points to the last position, it should be reset to the buffer’s starting address, pBuf; otherwise, it is simply incremented.","b9ff6f1c-154a-3a82-b7b9-c8f0b5f886cc":"The TMALI CSC gathers housekeeping data, which can be accessed by invoking tmaliHkGet(). The housekeeping information from the TMALI CSC is provided in the TMALI_HK data structure.","bc4861a9-1d9d-3ab2-9857-d17176bfac3a":"Ring buffer data structure\tThis setup leads to the following:\n* management is straightforward, but one slot is unused when the buffer is full, with the pIn pointer positioned one before the pOut pointer,\n* the buffer is considered empty when the pIn and pOut pointers are at the same position.","d95c7cab-7815-31b3-a6e4-3c31afa2baad":"The ring buffer uses a dedicated pointer, pEnd, to mark the buffer’s final position. This pointer references the buffer’s last valid element. Before moving any pointer forward, it must be checked if it already points to this last position; if so, the pointer should be reset to the buffer’s starting location, indicated by pBuf. If not, the pointer is simply incremented.","35648906-88dd-37b6-b898-9ace097dcebe":"The hardware windowing feature of the DCI can be enabled and managed using the tmaliDciWindowSet() function, which turns on the hardware windowing and sends the defined window parameters to the DCI driver.","78919754-9dba-38c5-b5ba-a65b2059127b":"The DPU-CCM CSC offers a central error reporting function, ccmErrEnq(), which other FSW tasks can use to log errors. Whenever it wakes up, ccmTask() determines if it's time to generate an error or event packet for ground transmission. If needed, ccmTask() invokes ccmHkMkError() to create the packet and send it to DPU-SCUI for forwarding to the ground."}