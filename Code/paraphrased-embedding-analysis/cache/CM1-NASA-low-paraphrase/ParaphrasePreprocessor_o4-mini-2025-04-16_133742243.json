{"a3f78cd6-5aaf-34f8-943c-aa915a15cec7":"This routine provides access to the DCI’s current data timeout setting, returning the timeout in milliseconds. Refer to document 036911400, section 4.3.2.4.1.3 for details.","b05d66ed-652d-3c73-8ee7-881ee2f59cee":"The tmaliHkGet routine retrieves the stored TMALI CSC housekeeping data, including certain DCI parameters, and then resets the internal counters to zero. If the caller’s TMALI_HK pointer is NIL, no data is returned but the counters are still cleared. Two of the four error counters are updated in an ISR context, so they must be safe across task switches. While VxWorks might use a counting semaphore, the TMALI CSC uses a free-running error counter and an extra temporary variable to adjust the reported count. Because 32-bit unsigned integer increments and assignments are atomic, this method is task-safe and no error events are lost. As a result, the sum of errors reported by tmaliHkGet() exactly equals the total errors that occurred.","6ba99380-e944-3655-a83a-02478245bab5":"After all events in the Ping-Pong buffer have been moved into TMALI_EVENT_QUEUE, tamliTask() must rearm the DCI hardware so it can swap to the next buffer when ready. If the pong buffer fills before the transfer from the ping buffer completes, the DCI driver generates an error interrupt that triggers tmaliDciErrorReportedISR(). That ISR sets an error flag and posts semDciWait to wake tamliTask() (even if it is already active) and increments the error count in TMALI_HK. While this flag remains set, the hardware discards incoming events until tamliTask() finishes the pending transfer, detects the error, forces a manual Ping-Pong buffer swap, and restarts data acquisition. This process ensures only complete frames reach the Ping-Pong buffer for processing. Under normal circumstances the TMALI task should keep pace and prevent this error; if it cannot, the system will report an S_TMALI_QUEUE_FULL error via ccmErrEnq() when the TMALI queue fills up.","7798b768-904b-396f-bc02-a6ee2e167bdf":"Any upload exceeding 65535 bytes must be divided into multiple virtual uploads, each no larger than 65535 bytes, and transmitted in series. Because each upload carries a sequence number, the DPU FSW may receive those commands out of order. There is no time limit for a virtual upload, allowing a lengthy transfer to continue across ground contacts. While an upload is in progress, sending the last sequence number to the DPU FSW will prompt it to issue event S_ccm_MISSING_SEQNO with the list of missing sequence numbers. To cancel an ongoing upload, issue the D_MEM_DAT_CNCL command.","417ed1bc-9a98-352d-acbe-4d904941bfe1":"The CCM Control Task is also responsible for handling memory dump commands. When a data dump is requested, it divides the dump into smaller segments and outputs each segment each time the task wakes up. This deferred processing prevents a large dump from monopolizing CPU time or keeping the high-priority CCM Command Dispatch Task occupied for too long.","6adfb5cd-a367-38c7-8bea-79d1726faac7":"This routine sets the DCI data timeout in milliseconds. The initial frame‐depth timeout is taken from the parameter passed when tmaliTask starts. You can command the timeout up to X seconds; if you request a value above X seconds, it resets to the default of X milliseconds.","c5ed74b5-2bc6-3883-95bf-b8f6873e70ee":"Memory data transfers to the DPU can be done in two ways: Memory Poke via the D_MEM_DAT_POKE command or Memory Upload via the D_MEM_DAT_UPLD command. The Memory Poke command is intended for small writes of up to Z bytes, constrained by Company X’s command length limit.","d5788443-4f46-3e64-bdbf-d42c8fdd1229":"The TMALI CSC collects housekeeping data accessible via a call to tmaliHkGet(), which returns the data in a TMALI_HK structure.","768cf777-831a-396b-9e3b-bb5bbb33eb6f":"D_MEM_BLK_DNLD is used to download the entire contents of a file in the EEPROM filesystem by providing just its block number, which defines the filename. To download memory from other locations, use D_MEM_DAT_DNLD. Downloads operate in a deferred mode to minimize CPU load. Each logical download is split into a sequence of packets that must be extracted and concatenated in order to reconstruct the original data.","16a7704a-c956-39ff-8892-04bd43b8537b":"This function is invoked by each DPU FSW task to signal that it has run, allowing ccmCtrlTask() to monitor the health of the DPU FSW execution.","0b4fdce4-7b8d-3d19-a419-465409ed34ca":"The Telescope Module Access Library and Interface (TMALI) CSC oversees the detector event queue and offers an API for data processing algorithms to retrieve events from that queue.","f41ebaa4-a1f1-3e61-89b8-cdb042594f42":"This function lets you configure the DCI bit arrangement: if bSpecialArrangement is TRUE, the DCI uses the special bit arrangement mode, otherwise it uses the default mode with no rearrangement.","28868435-794f-3114-b1ec-087d07f42f87":"This function is invoked by each DPU FSW task to signal that it has run, allowing ccmCtrlTask() to monitor the health of the DPU FSW execution.","39f8a459-5c1d-3158-b596-b81519fb5a6c":"Upon initialization, the TMALI CSC launches tmaliTask() with its default startup parameters. This task allocates memory for the TMALI_EVENT_QUEUE, installs the DCI interrupt service routines, initializes static variables and data structures, and then enters a continuous loop that moves data from the DCI into the TMALI queue, regulated by the semDciWait semaphore.","bcaee947-f60d-3f12-9aab-b7e9b783e9ea":"When the MIL-STD-1553 Command ISR or the SSI Interface ISR receives a command from the SCU or the ICU, this routine enqueues it and awakens the CCM Command Dispatch Task to execute the command.","031093cb-0a52-3b8c-ad13-94fbbdc289b7":"This function retrieves the frame depth of the DCI CSC’s Ping-Pong buffers. The frame depth specifies how many frames are loaded into the selected Ping-Pong buffer before an interrupt occurs. The initial depth is set by the parameter passed when starting the tmaliTask. The returned value is the currently active depth, which may differ from the last commanded depth until the hardware Ping-Pong buffer transfers data to the TMALI queue in response to a frame or timeout interrupt (see section 5.13.2.3).","7191c2cd-a0bb-3822-84f1-17cffece5368":"Commands are handled by ccmCmdTask(), which waits on a semaphore released by ccmCmdEnq() before dequeuing and executing commands. When the semaphore is given, ccmCmdTask() calls ccmCmdProcess() to fetch each queued command, then ccmCmdDispatch() verifies its length and carries out the command. If command echo is enabled, ccmCmdDispatch() calls ccmHkMkCmdEcho() to echo the command back to the ground. The task tracks counts of executed and rejected commands. Incoming 1 Hz clock time messages and spacecraft attitude messages bypass the queue and are executed immediately in interrupt context: attitude data go to dpaCommandSend() and clock time parameters go to tisTimeSync() for time synchronization. Any other non-DPU or non-spacecraft messages are discarded without error. To ensure periodic check-ins with the CCM Control Task when no ground commands arrive, the semaphore wait times out after 20 seconds; on timeout, ccmCmdTask() verifies the Command Queue is empty and then calls ccmTaskReport().","d1069303-0a04-3dff-8339-1d057d488edd":"The S_ccm_ERR_REPEAT error code stores the count of the last repeated error in its low-order byte. Whenever a new error is reported, ccmErrEnq() enqueues an S_ccm_ERR_REPEAT entry for any previously repeated error alongside the newly reported error. To keep each original error code and its repeat count together in the same packet, ccmMkHkErr() enqueues the special code S_ccm_ERRQ_FLUSH, signaling ccmErrEnq() to clear its tracking mechanism and enqueue any outstanding repeat counts for that error.","95fb044f-2046-38f0-b241-fe9fa977900b":"Benchmark testing will determine the optimal frame depth, which defaults to 10 frames; at the maximum data transfer rate, reading ten maximum‐sized frames takes about 24 ms.","6181127f-57bb-3d6c-a693-895ee3b0d075":"The DPU-CCM CSC offers a centralized error-reporting interface, ccmErrEnq(), that other FSW tasks call to log errors. Each time ccmTask() wakes up, it checks whether it’s time to assemble an error/event packet for ground transmission; if so, it invokes ccmHkMkError() to build the packet and forward it to DPU-SCUI for downlink.","f2635035-8f10-32de-92f0-2695c9288a4a":"The CSC uses a ring‐buffer FIFO to hold incoming DCI data until it can be processed. Two pointers, pIn and pOut, track where data enters and exits the buffer, and they’re arranged so that reading requires only one comparison to check for emptiness. Because the buffer stores only four-byte Event objects, the pointers reference those entities, and data sizes must be converted from bytes (as defined by the DCI) before reading.","aaf7e356-ab47-30aa-961f-d572d4844469":"The global data items accessed by this CSC.","7a992a5c-644e-38f2-bece-ed0322d17445":"Data can be uploaded to the DPU in two ways: using the D_MEM_DAT_POKE command to insert small data blocks (up to Z bytes) directly into DPU memory, or using the D_MEM_DAT_UPLD command for larger transfers. The Z-byte limit for the poke command is imposed by Company X’s command length constraint.","426b5ffc-f36a-383f-a8f0-d419a106007b":"In the normal data exchange sequence the DPA CSC invokes tmaliWait() to check how many events are pending; if it returns a positive count, the DPA then calls tmaliNextEvent() for each pending event to retrieve it.","9ee94cc8-ec35-3cd5-9273-c5de5c995a89":"The DPA CSC retrieves events from the TMALI_EVENT_QUEUE using the tmaliWait() and tmaliNextEvent() calls. To maximize performance it inlines tmaliNextEvent() so there’s no per-event function call, loads each event into a register and finishes processing it before fetching the next one, and because tmaliNextEvent() omits error checking, the DPA CSC itself must track the count of events retrieved against the number reported by tmaliWait().","b2b204f1-cd4b-3263-ab15-aecd2828fa58":"The DPA CSC retrieves events from the TMALI_EVENT_QUEUE using tmaliWait() and tmaliNextEvent(). To maximize efficiency, tmaliNextEvent() is inlined to eliminate per-event call overhead, each event is loaded into a register and fully processed there before fetching the next one, and because tmaliNextEvent() omits error checking, the DPA CSC must track how many events it has retrieved versus how many tmaliWait() returned.","5c0f562d-28e5-327c-9721-b08cf6ecc5d3":"This function retrieves the frame depth of the DCI CSC’s Ping-Pong buffers, where frame depth specifies how many frames are loaded into the chosen buffer before an interrupt occurs. The initial frame depth is set by the parameter supplied when starting tmaliTask. The returned value is the currently active frame depth, which may differ from the last commanded value because changes only take effect when data moves from the hardware Ping-Pong buffer to the TMALI queue in response to a frame or timeout interrupt (see section 5.13.2.3).","a20e1ae1-4272-304f-8881-e3f020db35db":"Each DPU FSW task invokes this routine to indicate it has run, enabling ccmCtrlTask() to evaluate the health of the DPU FSW execution.","27da15c7-49e5-3552-b1bd-24108986cbc1":"When the MIL-STD-1553 Command ISR or the SSI Interface ISR receives a command from the SCU or the ICU, this routine enqueues it and awakens the CCM Command Dispatch Task to execute the command.","b6952139-6807-33af-96a9-132935531439":"The TMALI CSC initializes by spawning tmaliTask() with the default startup parameters. This task allocates memory for the TMALI_EVENT_QUEUE, installs DCI ISRs, initializes static variables and data structures, and then enters an endless loop transferring data from the DCI to the TMALI queue, regulated by the semDciWait semaphore.","a4ab6f19-21a3-3628-aae7-c94df16a968c":"The Command and Control CSC is brought up by having the operating system’s startup routine, usrRoot(), spawn the CCM Control Task (ccmCtrlTask()). Once running, that task invokes ccmInit(), which establishes the error/event queue, sets up required semaphores, and registers the necessary ISRs. It then launches the other tasks that implement the DPU flight software. At startup, the CCM Control Task loads the DPU’s configuration defaults from the SYSTEM_CONFIG_AREA in EEPROM; if the checksum check fails, it falls back to built-in defaults. It initializes each remaining CSC either by calling its specific initialization function or, for those with dedicated tasks, by using VxWorks’ taskSpawn(), passing along the startup defaults retrieved from EEPROM. Additionally, ccmInit() calls ccmCmdLengthInit() to build the command length verification table used by the command processor to check incoming command lengths.","45df9dde-c99f-350d-a122-05fe7505d99d":"This routine allows configuring the DCI’s bit arrangement: if bSpecialArrangement is TRUE, the DCI uses the special bit arrangement mode; if FALSE, it uses the default mode with no rearrangement.","94ed76a0-77c2-3757-bea5-779e473c08aa":"Whenever CCM Control runs, it invokes ccmPerProcess() to perform its periodic duties—updating analog-to-digital conversions, monitoring DPU tasks, generating ICU heartbeat messages, and stroking the watchdog. Within ccmPerProcess(), ccmHealthChk() checks each task’s status by measuring how long it has been since that task last reported. Tasks announce their execution by calling ccmTaskReport() with their task index. Each task must run at its expected frequency; if it does not, an error is logged in DPU housekeeping. If the Command Dispatch Task fails to report for an extended period, the DPU will reboot—since it cannot be commanded otherwise—while any other missed report simply triggers a watchdog strobe.","2a21cd73-14d9-37e7-bcb7-a8425e6a95b2":"This function retrieves the frame depth of the DCI CSC Ping-Pong buffers. The frame depth specifies how many frames are loaded into the selected buffer before an interrupt is generated. The initial frame depth is set by the parameter passed when starting the tmaliTask. The value returned is the currently active setting, which may differ from the last commanded value, since changes only take effect when data moves from the hardware Ping-Pong buffer to the TMALI queue in response to a frame or timeout interrupt (see section 5.13.2.3).","09b45c48-1774-3677-a22b-8637ceeb5f69":"The hardware windowing feature of the DCI is enabled and configured via tmaliDciWindowSet(), which activates it and submits the specified window parameters to the DCI driver.","979afca3-c229-34d2-b89c-3d0901eecbea":"At 1 Hz upon receipt of the Clock Message, the MIL-STD-1553 Command ISR calls this routine to release the semaphore and wake the CCM Control Task, which blocks on that semaphore after completing its processing.","1a27332b-3437-3c92-b5f9-beb75241dc53":"ccmErrEnq() can also be called from interrupt context. Because it’s illegal to take a semaphore in an interrupt, the mutual exclusion used by the Error Queue can’t be applied there. Instead, the appropriate error code is stored in the global variable ccmISRerror, and that error is added to the queue the next time ccmTask() runs. However, if more than one error occurs in interrupt context before ccmTask() executes, the earlier error is overwritten by the new one, so errors can be lost.","9d071f3e-dd42-33c1-86ee-afa2e3812ba2":"After all events in the Ping-Pong buffer have been moved into TMALI_EVENT_QUEUE, tamliTask() must re-arm the hardware to swap buffers when ready. If tamliTask() fails to transfer data from the ping buffer before the pong buffer fills, the DCI driver triggers an error interrupt and calls tmaliDciErrorReportedISR(). That ISR sets an error flag so tamliTask() can recover, gives semDciWait to wake tamliTask() even if it’s already running, and increments the error count in TMALI_HK. The DCI hardware then discards incoming events until tamliTask() completes the prior transfer, spots the error flag, forces a manual buffer swap, and restarts data acquisition. This ensures only complete frames are buffered and processed. Under normal operation this error should not occur because tamliTask() should empty the DCI Ping-Pong buffer in time; if it can’t, the TMALI_EVENT_QUEUE will fill up and report an S_TMALI_QUEUE_FULL error via ccmErrEnq().","15da4c28-a24a-3049-8edf-8ac8575ea61a":"The D_MEM_BLK_DNLD command retrieves the entire contents of a file in the EEPROM filesystem by specifying only its block number, which is used to construct the filename. To download data from any other memory region, the D_MEM_DAT_DNLD command is used. Downloads are performed in a deferred manner to minimize CPU load. Although each transfer appears as a single “virtual” download, the data are actually sent as multiple packets whose payloads must be extracted and concatenated in order to reconstruct the original data sequence.","6485ce43-484d-38ea-a03e-0ba343c56744":"ccmErrEnq() keeps track of the last error reported and how many times it occurs. When an error code is reported, it’s saved as the current previous error and each immediately repeated instance increments a repetition counter. If the same error code appears more than once within a single high-rate housekeeping cycle, ccmErrEnq() enqueues a special S_ccm_ERR_REPEAT error with the repetition count encoded in its least significant byte. This prevents the housekeeping telemetry from being flooded by a stream of identical errors.","e8838baa-ac31-34e8-9780-ca3d4f650c35":"The Telescope Module Access Library and Interface (TMALI) CSC consists of a ring-buffer event queue called TMALI_EVENT_QUEUE that holds detector events received from the DCI driver’s data capture interface until the DPA CSC retrieves them; an API with tmaliNextEvent() and tmaliWait() that lets the DPA CSC pull events from the queue; a group of configuration functions—tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet() and tmaliDataTimeoutGet()—for setting up the DCI interface; a housekeeping function, tmaliHkGet(), that gathers CSC status data when requested by the Command and Control Task; the tmaliTask() and its ISR tmaliTransferToQueueISR(), which use a semaphore to coordinate moving data from the DCI into the queue; and an error-handling ISR, tmaliDciErrorReportedISR(), hooked into the DCI driver to count reported errors.","14846b9d-d5bd-32d2-9f02-ee41e8a3797b":"Events are fetched from the TMALI_EVENT_QUEUE by the DPA CSC using two API calls—tmaliWait() and tmaliNextEvent(). To maximize performance, the DPA CSC inlines tmaliNextEvent() to remove call overhead, places each returned event in a register and fully processes it there before retrieving the next, and, because tmaliNextEvent() does no error checking, tracks how many events have been retrieved versus the count returned by tmaliWait().","b83f3c39-911b-3832-b084-23b7b3f61729":"This routine allows setting the DCI windowing parameters for data acquisition. It validates the requested window specification before instructing the DCI driver to update the hardware; if the specification is invalid, it returns an error without enabling windowing. Otherwise, it applies the specified hardware window and activates the windowing function.","ce9de193-c02e-3a88-9d8a-6cdc2510de57":"ccmErrEnq() can be invoked from interrupt context. Because taking a semaphore in an interrupt context is illegal, the Error Queue’s mutual exclusion mechanism cannot be used. Instead, the error code is stored in the global variable ccmISRerror, and the error is queued the next time ccmTask() runs. If another error occurs in interrupt context before ccmTask() executes, the previous error will be overwritten and lost.","1c2e1322-c61a-31cf-9e15-8e3947ca0a16":"The Telescope Module Access Library and Interface (TMALI) CSC controls the detector event queue and offers an API that allows data processing algorithms to retrieve events from it.","3ed849e9-12d4-330e-b285-684432a3a375":"Ring buffer data structure: pIn refers to the buffer position most recently filled with data, and pOut refers to the buffer position most recently emptied.","1e60d487-9892-3a18-a02b-4e5d7aa64259":"This routine is invoked by the MIL-STD-1553 Command ISR at 1 Hz upon Clock Message arrival to signal the semaphore and wake the CCM Control Task, which had blocked after completing its processing.","dcd5cc51-f018-309e-b472-3df0ab38b4de":"Once all events in the Ping-Pong buffer have been moved into TMALI_EVENT_QUEUE, tamliTask() must re-arm the hardware so it can swap buffers when ready. If TMALI hasn’t emptied the ping buffer before the pong buffer fills, the DCI driver issues an error interrupt that calls tmaliDciErrorReportedISR(). That ISR sets an error flag so tamliTask() can recover and gives the semDciWait semaphore to wake tamliTask() even if it’s already active, since the error might occur just as a transfer finishes. TMALI_HK logs the error. Meanwhile, the DCI hardware discards incoming events until tamliTask() completes the prior transfer, notices the error flag, forces a Ping-Pong swap manually, and restarts data acquisition. This ensures only full frames ever reach the Ping-Pong buffer for processing. Under normal conditions this error should not occur, as tamliTask() should keep pace with the DCI buffer. If it cannot, the overflow appears as a full TMALI queue and is reported as an S_TMALI_QUEUE_FULL error via ccmErrEnq().","294a7051-ebd2-3120-95f0-4cc834f4b194":"This function returns the frame depth of the DCI CSC’s Ping-Pong buffers—that is, the number of frames loaded into the chosen buffer before an interrupt occurs. The initial frame depth is set by the parameter passed when starting the tmaliTask. The value returned is the currently active frame depth, which may differ from the most recently commanded value, since changes only take effect when data moves from the hardware Ping-Pong buffer into the TMALI queue in response to a frame or timeout interrupt (see section 5.13.2.3).","a26057b2-789e-3057-aa8a-a6628ac484fc":"When tmaliTransferToQueueISR() runs, it signals tmaliTask() via a semaphore to begin moving data over the VME bus into the queue. tmaliTask() then calls the DCI driver’s read() function, which uses a high-speed assembly routine. Because the TMALI ring buffer is an array, tmaliTask() first inspects TMALI_EVENT_QUEUE to decide whether the DCI buffer’s contents can be fetched in one read() or require two reads to handle wrap-around at the buffer’s end. It also verifies that there is enough space in the ring buffer for all frames in the Ping-Pong buffer; if there isn’t, it discards the entire readable Ping-Pong buffer and reports S_TMALI_QUEUE_FULL via ccmErrEnq. Since the hardware only switches Ping-Pong buffers at CCD frame boundaries, the discarded data always comprises whole frames. Discarding newer data in this way reflects the scientific preference for preserving events collected immediately after a burst over later ones.","7b1d1f25-6ff8-348c-b6bf-5f1705716a0f":"Data can be loaded into the DPU in two ways: via the D_MEM_DAT_POKE command (Memory Poke) or via the D_MEM_DAT_UPLD command (Memory Upload). The Memory Poke command is intended for small data transfers of up to Z bytes, a restriction imposed by Company X’s command‐length limit.","9fd1b944-c848-3036-a3f6-441f055401c4":"To prevent rollover-related loss, ccmErrEnq() ensures that any given error count remains at or below 250 within a single high-rate housekeeping reporting period; if it exceeds 250, ccmErrEnq() enqueues an S_ccm_ERR_REPEAT error with the current count and resets its error tracking.","144eb452-93dc-337a-a715-b8f0f85648fe":"The DPU receives commands through two channels—the spacecraft MIL-STD-1553 interface and the ICU SSI link—and these commands may originate from the ICU or the spacecraft control unit, whether generated locally or on the ground, with ground-generated commands relayed via either the ICU/SSI path or the SCU/1553 path.","406d5983-3c5c-3633-9e68-6ca9d74eb433":"This public routine lets any CSC log an error or event for inclusion in DPU housekeeping. If it’s invoked in an interrupt, it sets a static global (ccmISRError) so ccmCtrlTask() can enqueue the error afterward, since ISRs cannot take the semaphore guarding the error/event queue. That semaphore uses priority inversion protection to prevent conflicts among callers. The routine also handles rapidly recurring errors by issuing a special “repeat” code after the initial error to indicate the same fault happened multiple times in the last high-rate reporting period.","1ccc0f44-d7cb-363b-8daa-42c9cbda4e48":"When tmaliTransferToQueueISR() is invoked, it gives a semaphore that wakes tmaliTask(), which then transfers data over the VME bus to the queue. tmaliTask() calls the DCI driver’s read() function, which uses a high-speed assembly routine to move the data. Because the TMALI ring buffer is an array, tmaliTask() first inspects TMALI_EVENT_QUEUE to determine whether the contents of the DCI buffer can be retrieved in one read() call or require two calls to handle wrap-around. It then checks that there is enough free space in the queue to accommodate all frames in the Ping-Pong buffer. If there isn’t sufficient space for the complete set of frames, tmaliTask() discards the entire readable Ping-Pong buffer—always an integral number of CCD frames, since Ping-Pong switches occur only at frame boundaries—and reports S_TMALI_QUEUE_FULL via the ccmErrEnq mechanism. This approach ensures that, in the event of overflow, older data collected immediately after a burst (which is considered more scientifically valuable) is retained over newer data.","d27a7e60-15a4-3cf5-9654-4c679444a6e4":"Data uploads can be directed to DRAM, EEPROM, hardware registers, or the EEPROM filesystem by specifying the destination with the D_MEM_DAT_UPLD command. When the EEPROM filesystem is chosen, a block number replaces the memory address; the DPU flight software then creates a filename in the format eefs1:DPU_blk.##, where ## is the block number. Once all data is received, it is written to that file, overwriting any existing file with the same name. The EEPROM filesystem can be reinitialized using the D_MEM_DISK_INIT command.","8315d7d9-f1bb-3a29-9bb0-7fb8f91034eb":"The CSC maintains a first-in, first-out queue implemented as a ring buffer to hold incoming data from the DCI until it’s processed. Two pointers, pIn and pOut, track where data enters and exits the buffer, and they’re arranged so that checking for an empty buffer requires only one comparison. The buffer stores only four-byte Event objects, so both pointers reference those units, and because the DCI reports sizes in bytes, any size values must be converted before data is read.","f7aecaad-eb17-33cc-b06c-313bb1c98153":"During system startup, before the error queue is created, any errors are stored directly in the global task variable errno. For more details on errno, see VxWorks® Programmer’s Guide section 2.3.7. Once the error queue exists, any time errno is set the error is added to the queue via ccmErrEnq().","677acf9d-95cd-3d75-bbb8-108ae99ab505":"When the SCU (via the 1553 interface) or the ICU (via the SSI interface) issues a command, the corresponding ISR places the command packet into a Command Queue and posts a semaphore to wake the ccmCmdTask(). Because the DPU can send commands to itself, they may arrive in either interrupt or task context. As a result, the CCM uses two queues—one without semaphore protection for interrupt context and one with semaphore protection for task context.","b1a3ea21-45cc-3752-9545-11b23346c0ed":"The S_ccm_ERR_REPEAT error stores the count of the last repeated error in its low‐order byte. When a new error is reported, ccmErrEnq() enqueues a S_ccm_ERR_REPEAT entry for any error that had repeated, then enqueues the new error. To keep the original error codes and their repeat counts together in one packet, ccmMkHkErr() enqueues the special S_ccm_ERRQ_FLUSH code, signaling ccmErrEnq() to reset its tracking and enqueue any accumulated repeat counts for that error.","138ca949-ad6a-35d3-88a4-03abb0ff4794":"Called by the MIL-STD-1553 Command ISR and the SSI Interface ISR whenever a command arrives from the SCU or ICU, this routine enqueues the command and wakes up the CCM Command Dispatch Task so it can be executed.","aa58c74e-b31f-34e5-9ded-cec39bec6dcb":"ccmErrEnq() maintains the most recently reported error code and a consecutive repetition counter. When an error is reported, it becomes the “previous” error and if the same code is reported again immediately afterward, the counter increments. If this error code appears more than once during a single high‐rate housekeeping reporting period, ccmErrEnq() enqueues the special error S_ccm_ERR_REPEAT, encoding the repetition count in its least significant byte. This prevents a flood of identical errors from overwhelming housekeeping telemetry.","16598da8-f59a-3689-9801-4c35905e8346":"During initialization, the TMALI CSC launches tmaliTask() with its default startup parameters. This task allocates memory for the TMALI_EVENT_QUEUE, installs the DCI interrupt service routines, initializes static variables and data structures, and then enters an infinite loop that moves data from the DCI into the TMALI queue, paced by the semDciWait semaphore.","05c1a239-fbf4-34e5-8e50-30e7b784626d":"When no events are in the TMALI queue, this function waits on a semaphore until the ISR signals that events have arrived. If events are already in the queue or the semaphore is taken, it counts and returns the number of events. The TickstoWait parameter sets the maximum wait time in kernel ticks or can be set to FOREVER to wait indefinitely for data. If the timeout expires without any data, the function returns zero. If the TMALI task hasn’t been initialized, it returns an error.","d0ccf8ba-3a19-31ec-8ebd-f427be4c23a5":"This routine retrieves the current data timeout value used by the DCI and returns it in milliseconds. The timeout is described in document 036911400, section 4.3.2.4.1.3.","44ef0ca2-314d-36ea-ae04-38249c275303":"Data can be uploaded to DRAM, EEPROM, hardware registers, or the EEPROM filesystem by using the D_MEM_DAT_UPLD command to specify the destination. When targeting the EEPROM filesystem, a block number is provided instead of a memory address; the DPU FSW uses that number to generate a filename eefs1:DPU_blk.##, where ## is the block number. Once the DPU FSW has received all the data, it writes it to that file in the EEPROM filesystem, overwriting any existing file with the same name. The EEPROM filesystem can be reinitialized with the D_MEM_DISK_INIT command.","54f34b98-be67-37e3-8e9c-e31db163f4ce":"The Telescope Module Access Library and Interface (TMALI) CSC oversees the detector event queue and offers an API that enables data processing algorithms to retrieve events from it.","71b2fd83-b042-33a9-ab42-cebec7d2b637":"This routine configures the DCI hardware windowing parameters used for data acquisition. It first validates the requested window specification, and if validation fails, it returns an error without activating hardware windowing. If the specification is correct, it programs the hardware with the new window parameters and enables windowing.","5530a803-f64e-34b4-9cd9-4dfc68f401d4":"The DPU generates eight distinct types of housekeeping packets for control and monitoring.","64588724-a738-3bea-9db6-2f0115ace737":"The MIL-STD-1553 Command ISR and the SSI Interface ISR invoke this function whenever they receive a command from the SCU or ICU, enqueuing it and waking the CCM Command Dispatch Task to process it.","3d68bfa5-ad37-33b3-8672-d2ef50464c0f":"This function configures the number of frames loaded into the DCI CSC’s ping-pong buffers before an interrupt occurs. The initial depth is set by the parameter passed to tmaliTask at startup. You cannot set a depth higher than 64 frames; any request above this limit resets the depth to the default V frames. Because the DCI bus may be active, applying a new depth may be delayed slightly and usually happens right after a frame-level reached or timeout event is reported, reducing the risk of changing settings while the hardware is about to detect a frame. Changing the depth during data processing can cause unpredictable behavior. If a tmaliDciFrameDepthSet command is issued before the previous setting takes effect, the new request replaces the old one and is applied at the next available opportunity.","9621ed45-dd12-3a6d-9aa1-db95b4b7fd0a":"If an upload exceeds 65 535 bytes, it must be divided into multiple virtual uploads of 65 535 bytes or less and sent one after another. Because each segment uses sequence numbers, the DPU FSW may receive upload commands out of order. There is no time limit on any single virtual upload, so a large transfer can span multiple ground contacts. While an upload is underway, sending the last sequence number to the DPU FSW causes it to issue an S_ccm_MISSING_SEQNO event listing any missing sequence numbers. If an upload in progress needs to be cancelled, issuing the D_MEM_DAT_CNCL command will discard it.","1025b126-173f-3c93-967c-d598d9225068":"For a normal data exchange sequence, the DPA CSC calls tmaliWait() to find out how many events are pending, and if tmaliWait() returns a positive number, the DPA then calls tmaliNextEvent() for each event to retrieve them.","15b92528-b260-374c-83f8-12cacce0f551":"Upon initialization, the TMALI CSC launches tmaliTask() with its default startup settings, which allocates memory for the TMALI_EVENT_QUEUE, installs DCI ISRs, initializes static variables and data structures, and then enters an endless loop that transfers data from the DCI to the TMALI queue, regulated by the semDciWait semaphore.","f9265c63-7317-3874-a3cd-483e6e041dd8":"The DPA CSC calls tmaliWait() to determine how many events are queued for reading. If tmaliWait() returns a count greater than zero, the DPA then calls tmaliNextEvent() for each event to collect it.","340fcf1b-3d14-3f79-8893-b8ce71433765":"The DPU-CCM CSC offers a unified error-reporting interface called ccmErrEnq() that other FSW tasks invoke to log errors. Each time ccmTask() wakes up, it checks whether it’s time to assemble an error/event packet for ground transmission; if so, it calls ccmHkMkError() to build the packet and hand it off to DPU-SCUI for sending to the ground.","5ddca483-5b28-3e2a-aeec-a06fed997884":"When large amounts of memory must be uploaded to the DPU, such as for a software patch or full software update, the standard memory upload process is used. This involves sending a sequence of D_MEM_DAT_UPLD commands that together form a single “virtual” upload. CCSDS-like grouping flags allow the DPU flight software to accept up to 65,535 bytes in one virtual upload. Data from each command is buffered in DRAM until every sequence number in the upload has been received. Once the final command arrives, the flight software checks that all sequence numbers are present, validates the end-to-end checksum, and writes the buffered data to the target address specified in the first command.","ee538b3e-2f19-3efb-a0a3-58dacca1f2d0":"The TMALI CSC collects housekeeping data, which can be obtained by calling tmaliHkGet(), and returns it in a TMALI_HK data structure.","952110df-29a7-3265-8d24-e7cad92f15c7":"In the operating system’s startup sequence, usrRoot() spawns the CCM Control Task (ccmCtrlTask()) to initialize the Command and Control CSC. Once running, ccmCtrlTask() invokes ccmInit(), which creates the error/event queue, allocates required semaphores, and installs necessary ISRs. It then launches all remaining tasks that make up the DPU flight software. When the CCM Control Task starts, it reads default configuration values from the SYSTEM_CONFIG_AREA in EEPROM, reverting to hard-coded defaults if the checksum is invalid. It initializes each CSC by calling its initialization routine or, for those with dedicated tasks, by spawning them via VxWorks® taskSpawn(), passing the EEPROM defaults as parameters. Additionally, ccmInit() calls ccmCmdLengthInit() to build the command length verification table used by the command processor to validate incoming command lengths.","efa5f642-1518-3a32-a124-37511891b291":"The CCM Control Task also processes memory dump requests. When a dump command is received, it divides the data into smaller chunks and outputs one chunk each time it is activated. This deferred approach ensures that a large dump does not monopolize CPU resources or keep the high-priority CCM Command Dispatch Task occupied for too long.","466805a7-c015-3239-af59-64c22e9ad072":"Under normal operation, frames arrive roughly every 11 ms. The DCI hardware issues an interrupt when event data is placed into a Ping-Pong buffer and then no further events arrive for a configurable timeout period. This data timeout interrupt is not an error but typically signifies that the current exposure has ended, allowing the TMALI CSC to retrieve any remaining events from the DCI Ping-Pong buffer. The tmaliDciTimeoutSet() function provides an API for the DCI driver to adjust this timeout setting.","693b64ea-6ce9-3b47-a146-289053880748":"Benchmark testing will determine the optimal frame depth, which defaults to 10 frames, and based on the data, reading ten maximum-sized frames at the maximum data transfer rate takes approximately 24 ms.","ca2836cb-29de-39a7-898b-ea1e69059578":"In normal operation, frames arrive about every 11 ms. The DCI hardware issues an interrupt when event data has been placed into one of the ping-pong buffers and a user-configurable interval passes with no new events. This timeout interrupt isn’t an error but usually marks the end of the current exposure and lets the TMALI CSC collect the remaining events from the buffer. The tmaliDciTimeoutSet() function in the DCI driver API allows adjustment of this timeout setting.","5cd610f3-dc90-3662-ab7e-70f344bc19c1":"During normal operation, frames arrive about every 11 ms. If the DCI hardware has placed events in a Ping-Pong buffer and no new events arrive within a configurable timeout period, it issues a data timeout interrupt. This interrupt isn’t an error but instead signals that the current exposure has finished and lets the TMALI CSC fetch any remaining events from the Ping-Pong buffer. The tmaliDciTimeoutSet() function provides an API for the DCI driver to adjust this timeout.","f67c9f1c-63f1-36c3-bd38-0c22f9e4f050":"When larger amounts of memory need to be uploaded to the DPU, such as for a software patch or a full software upload, the standard memory upload process is used. Multiple D_MEM_DAT_UPLD commands are sent to form a single logical upload. CCSDS-style grouping flags let the DPU flight software accept up to 65,535 bytes in one logical upload. The data from each command is stored in a temporary DRAM buffer until all sequence numbers for the upload have been received. When the final command arrives, the flight software verifies that every sequence number is present, checks the end-to-end upload checksum, and then writes the entire buffered data to the target location specified in the first command.","aae17ef5-72f4-332d-8a67-0f16785ff3b4":"The CSC uses a FIFO implemented as a ring buffer to temporarily hold data received from the DCI until it is processed. Two pointers, pIn and pOut, track the positions in the buffer and are defined so that reading only requires a single comparison to check for emptiness. The buffer stores only four-byte Event items, so the pointers reference those entities, and DCI data sizes given in bytes must be converted into event counts before reading.","98992ace-c8ef-3eb3-a46d-b1fef3c7f1d8":"The DPA CSC invokes tmaliWait() to determine how many EVENTs are pending, and if tmaliWait() returns a value greater than zero, it invokes tmaliNextEvent() once for each pending EVENT to collect them.","3051e081-e1d4-3b40-a474-a835dcfedf8d":"The ring buffer design simplifies management but sacrifices one slot when full (with pIn one position behind pOut) and is considered empty when pIn and pOut are equal.","f9dfa81c-73bc-321e-8aa5-ec962c36c703":"The Telescope Module Access Library and Interface (TMALI) CSC handles the detector event queue and provides an API that allows data processing algorithms to retrieve events from that queue.","a7f12faa-ee7a-3cce-8cdb-3626e60f0584":"The DPU-CCM CSC offers a centralized error-reporting interface, ccmErrEnq(), that other FSW tasks call to log errors. Each time ccmTask() wakes, it checks whether it’s time to assemble an error or event packet for ground transmission. If so, ccmTask() invokes ccmHkMkError() to build the packet and send it to DPU-SCUI for downlink.","7cb73b59-a903-33f0-bb85-f471f84bac5d":"The DPU generates eight distinct types of housekeeping packets.","2b53e58b-b3d9-3029-bc71-b192e31f298a":"A dedicated pointer, pEnd, marks the buffer’s last slot. Before moving either pointer, check if it’s at pEnd; if it is, reset it to the buffer start at pBuf, otherwise advance it by one.","51d70ac6-c190-314f-99a9-d33b0c7261f7":"This function configures how many frames the DCI CSC’s ping-pong buffers will fill before generating an interrupt. The initial frame-depth value comes from the parameter passed when tmaliTask starts. You can set the frame depth up to 64 frames; if you specify a higher value, it reverts to the default of V frames. Applying a new depth setting may be delayed briefly if the DCI bus is busy, and it usually takes effect right after the DCI reports a frame-level reached or timeout event to avoid interfering with frame detection. Changing the depth while the DCI CSC is processing data can cause unpredictable results. If you issue another tmaliDciFrameDepthSet command before the prior setting has been applied, the new request replaces the old one and is applied at the next available opportunity.","8cbb5cd3-7111-33f6-8bd8-9061b6ed48e6":"This routine is invoked by the MIL-STD-1553 Command ISR and the SSI Interface ISR whenever a command arrives from the SCU or ICU, queues the command, and signals the CCM Command Dispatch Task to execute it.","035ea18e-468f-3a98-b85d-561cec40ce84":"The function ccmErrEnq() can be called from interrupt context. Because semaphores cannot be taken in an interrupt, the Error Queue’s mutual exclusion mechanism cannot be used there. To work around this, the appropriate error code is stored in the global variable ccmISRerror, and the error is actually added to the queue the next time ccmTask() runs. Since only one global error code is held, if multiple errors occur before ccmTask() executes, each new error will overwrite the previous one and earlier errors may be lost.","ced8ead4-8286-3925-95b8-15e3287635d3":"This routine allows you to configure the DCI hardware windowing parameters for data acquisition. It first verifies the provided window settings and, if they are invalid, returns an error and does not enable hardware windowing. If the settings are valid, the function applies them and activates hardware windowing.","0f933526-af70-33ce-b341-7b55f7235f97":"The Command and Control (CCM) CSC is a Level 2 reusable component from the INSTRUMENT Y project. It consists of two tasks: ccmCtrlTask(), which initializes the DPU flight software, starts other tasks at boot, schedules housekeeping data packet generation, monitors task execution, and sets up recurring activities such as heartbeat messages and the watchdog strobe; and ccmCmdTask(), which handles the reception and dispatch of real-time commands from the SCU or ICU. The component uses three main data structures: a Static Data table that records the current operational state (including housekeeping rates, CCM flags, and the count of executed commands), a Command Queue that buffers incoming interrupt-driven commands from the ICU and SCU, and an Error/Event Queue that gathers error and event codes from the DPU flight software for inclusion in periodic housekeeping telemetry packets.","97c6dc14-862c-30cd-beba-b9c88ae2133a":"The Command and Control CSC begins initialization when the OS startup task usrRoot() launches the CCM Control Task, ccmCtrlTask(). Once spawned, ccmCtrlTask() invokes ccmInit(), which creates the error/event queue, allocates required semaphores, and installs the necessary interrupt service routines. After that, it launches the other tasks that form the DPU flight software. On startup, the CCM Control Task reads the DPU configuration defaults from the SYSTEM_CONFIG_AREA in EEPROM, falling back to built-in defaults if the checksum fails. It then initializes each CSC by either calling its initialization function directly or spawning its task with VxWorks® taskSpawn(), supplying the EEPROM startup defaults as arguments. Additionally, ccmInit() sets up the command length verification table by calling ccmCmdLengthInit(), which the command processor uses to validate the lengths of incoming commands.","25d78690-834b-3a98-9beb-4f977ccc3125":"In the ring buffer structure, pIn points to the most recently filled slot and pOut points to the most recently emptied slot.","42a80079-ccba-3a00-8019-40a4a59a0c29":"In this ring buffer design, management is straightforward but one slot remains unused when the buffer is full, since pIn sits immediately before pOut, and the buffer is empty whenever pIn and pOut are equal.","fbef9dee-4240-3746-a8e1-dd47c0c8e4d1":"This routine lets you configure the DCI’s bit ordering: setting bSpecialArrangement to TRUE enables the special arrangement mode, while FALSE restores the default, unaltered arrangement.","e29fa6a0-9ef6-355c-b9ec-b3b173fd41e5":"The optimal frame depth will be determined by benchmark testing, with a default of 10 frames. According to the data above, it takes approximately 24 ms to read 10 maximum-sized frames at the maximum data transfer rate.","a5e45f42-01ea-345f-911e-6230799a5dac":"Each DPU FSW task calls this routine to indicate it has run, enabling ccmCtrlTask() to evaluate the health of the DPU FSW execution.","9fbc8be6-3db0-3a3f-9cb4-dd535f7c6461":"The TMALI CSC acts as an intermediary for EVENT data provided by the DCI Driver CSC before passing it to the DPA CSC. It waits for the DCI CSC to signal that the Ping-Pong buffer has reached its frame limit or timed out, indicating the EVENT data is ready. TMALI then retrieves all EVENT data from the DCI, notifies the DCI that it may swap the Ping-Pong buffers, and releases a semaphore to unblock the DPA’s tmaliWait() call.","e40f4c48-43f0-3bbf-9585-cfad02fe0e8d":"In a normal data exchange sequence, the DPA CSC invokes tmaliWait() to find out how many EVENTs are waiting, and if tmaliWait() returns a value greater than zero, the DPA calls tmaliNextEvent() for each pending EVENT to collect them.","8f84230c-2ac8-3561-ba1c-59e91be612e7":"If an upload exceeds 65 535 bytes, it must be split into multiple files of 65 535 bytes or less and sent one after another as virtual uploads. Due to sequence numbers, the DPU flight software may receive these fragments out of order. There is no deadline for completing a virtual upload, so a lengthy transfer can span multiple ground contacts. At any time during an upload, sending the final sequence number to the DPU flight software causes it to issue event S_ccm_MISSING_SEQNO with any missing sequence numbers. To cancel an ongoing upload, the D_MEM_DAT_CNCL command is used.","add081e7-9216-337a-a0a2-592a64545bb6":"To prevent error totals from rolling over, ccmErrEnq() ensures that no error’s count exceeds 250 during a single high-rate housekeeping report interval. If any error count goes above 250, ccmErrEnq() enqueues an S_ccm_ERR_REPEAT error with the current count and then resets its error tracking.","42d8ad4f-1326-3fc3-a011-ea03de3168e6":"If no data is present in the TMALI queue, the function blocks on a semaphore until the ISR signals that events have arrived. If events are already queued or the semaphore has been acquired, it counts and returns the number of events in the queue. The TickstoWait parameter specifies the maximum wait time in kernel ticks, or can be set to FOREVER to wait indefinitely until data arrives. If a finite timeout expires without any data, the function returns zero. If the TMALI task has not been initialized, it returns an error.","585a8414-f4b1-32ca-92f0-1ce4ab0d774c":"When a software patch or full application requires uploading a large block of memory to the DPU, the standard memory upload procedure is used. Multiple D_MEM_DAT_UPLD commands, marked with CCSDS‐style sequence flags, form a single “virtual” upload that can total up to 65 535 bytes. The data from each command is kept in a temporary DRAM buffer until all packets in the sequence have been received. Once the final packet arrives, the DPU flight software checks that no sequence numbers are missing, validates the overall upload checksum, and then writes the complete buffer to the destination address specified in the first upload command.","7c209b5b-691f-3ee9-8d2b-b5cc5b0321b9":"This public function retrieves the DCI’s current data timeout value and returns it in milliseconds, as defined in document 036911400, section 4.3.2.4.1.3.","6e194a13-5063-3e26-a2c8-91261c27e517":"The Command and Control (CCM) component is a Level 2 reusable module from the INSTRUMENT Y project. It consists of two primary tasks: ccmCtrlTask(), which initializes the DPU flight software, starts other tasks at bootup, manages the generation of housekeeping data packets, monitors task execution, and schedules recurring activities like heartbeat messages and watchdog strobes; and ccmCmdTask(), which accepts and routes real-time commands from the SCU or ICU. The component relies on several data structures: a static data table that records operational state information such as housekeeping production rates, CCM-specific flags, and the count of executed commands; a command queue that holds incoming commands delivered via interrupts; and an error/event queue that collects error and event codes reported by the DPU flight software for periodic inclusion in telemetry housekeeping packets.","17cf5d55-03c7-3011-b7d7-1072b40292c4":"The CCM Control Task initializes the DPU FSW and ensures a successful boot. It spawns the SCU Interface Task and the CCM Command Task, then blocks on temporary semaphores with five-second timeouts. If both tasks report successful initialization by releasing their semaphores, the Control Task toggles the BC_INDEX EEPROM parameter to record a successful boot; if either fails to report success, it disables the watchdog strobe to reboot the DPU. These two tasks represent the minimal functions required by the DPU FSW for ground contact and commandability.\n\nOnce initialization is complete, the Control Task blocks on a binary semaphore given by the SCUI Command ISR when a 1 Hz Clock Message arrives; if no Clock Message arrives, the semaphore times out after 1.5 seconds. The Control Task then remains active to generate and transmit DPU housekeeping at the appropriate intervals, perform periodic processing tasks, and process memory dump commands.\n\nAt the end of its cycle, the task calls ccmErrEnq() so that any error occurring in an interrupt service routine—recorded in the global errno—will be enqueued into the Error/Event Queue during normal task processing.","db03215f-e926-3451-ab93-f2a59e4fbc72":"When a command is received from the SCU via the 1553 interface or from the ICU via the SSI interface, the corresponding ISR places the command packet into the Command Queue and then signals the semaphore to wake the ccmCmdTask(). Because the DPU can send commands to itself, they may arrive in either interrupt context or task context. To accommodate this, the CCM uses two separate queues: one unprotected queue for interrupt-context commands and one semaphore-protected queue for task-context commands.","8f72cbad-3883-33f5-b620-a78aa57d7f4e":"The optimal frame depth will be established through benchmark testing, with a default of 10 frames; based on the data above, reading ten maximum-sized frames at the highest transfer rate takes about 24 ms.","f53fc2c5-bfe9-39ab-89ab-15cee367d95a":"When tmaliTransferToQueueISR() runs, it gives a semaphore that wakes tmaliTask(), which then moves data onto the VME bus queue. tmaliTask() invokes the DCI driver’s high-speed assembly read() routine. Because the TMALI ring buffer is an array, tmaliTask() first checks TMALI_EVENT_QUEUE to see if all the data in the DCI buffer can be fetched in one read() or if two reads are needed to handle wrap-around at the buffer’s end. It also verifies there is enough free space to accommodate the frames in the Ping-Pong buffer. If there isn’t room for the entire set of frames, tmaliTask() discards the whole readable Ping-Pong buffer and reports S_TMALI_QUEUE_FULL via ccmErrEnq. The discarded data always represents a whole number of CCD frames, since the hardware only switches Ping-Pong buffers at frame boundaries. This policy of dropping newer data preserves the earlier events, which are considered more scientifically valuable.","25644cd6-30ef-3273-b131-b348e228ceb4":"This ring buffer design makes management simple but wastes one slot when full, since the pIn pointer sits one position behind the pOut pointer, and the buffer is empty whenever pIn and pOut are equal.","b7662ead-110f-3eac-9007-870722160727":"This function returns the current frame depth of the DCI CSC’s Ping-Pong buffers. Frame depth is the number of frames loaded into the selected Ping-Pong buffer before an interrupt is generated. The initial depth comes from the parameter supplied when starting tmaliTask. The value returned is the active depth, which may differ from the last requested setting because changes only take effect when data moves from the hardware Ping-Pong buffer into the TMALI queue in response to a frame or timeout interrupt (see section 5.13.2.3).","f5a229cf-46ad-38fd-91fb-731287c46123":"This public function allows retrieving the DCI’s current data timeout value in milliseconds. The timeout is defined in document 036911400, section 4.3.2.4.1.3.","e8e16ca3-c084-384b-9315-49d36cfa4a5e":"When tmaliTransferToQueueISR() is invoked, it gives a semaphore to wake tmaliTask(), which then transfers data over the VME bus to the queue using the DCI driver’s read() function backed by a high-speed assembly routine. Because the TMALI ring buffer is an array, tmaliTask() first inspects TMALI_EVENT_QUEUE to determine whether it can retrieve the entire DCI buffer in a single read() or must perform two read() calls to handle wrap-around at the buffer’s end. It also checks that there is enough free space to receive the full ping-pong buffer; if there isn’t, it discards the entire readable ping-pong buffer and reports an S_TMALI_QUEUE_FULL error via ccmErrEnq. Since the DCI hardware only flips between ping and pong at CCD frame boundaries, any discarded data always consists of whole CCD frames. Discarding the newer data in this way ensures that the earlier events, which are scientifically more valuable immediately after a burst, are retained.","b9ff6f1c-154a-3a82-b7b9-c8f0b5f886cc":"Housekeeping data is collected by the TMALI CSC and can be obtained through the tmaliHkGet() function, which returns the information in the TMALI_HK data structure.","4f09bd49-5265-37c3-b718-d51599f02543":"Whenever the CCM Control task runs, it calls ccmPerProcess() to carry out its periodic duties—updating analog-to-digital conversions, monitoring DPU tasks, producing ICU heartbeat messages and stroking the watchdog. Inside ccmPerProcess(), ccmHealthChk() checks on other tasks by measuring how long it’s been since each last reported. Tasks report in by calling ccmTaskReport() with their index. Each task must meet its expected execution rate; if one misses its deadline, a DPU housekeeping error is logged. If the Command Dispatch Task fails to report for an extended interval, the DPU reboots because it cannot be commanded; otherwise the watchdog is strobed.","bc4861a9-1d9d-3ab2-9857-d17176bfac3a":"Ring buffer data structure that offers simple management while sacrificing one slot when full—since pIn sits one position behind pOut—and considers the buffer empty whenever pIn equals pOut.","d95c7cab-7815-31b3-a6e4-3c31afa2baad":"A dedicated pointer, pEnd, marks the buffer’s last slot. Before advancing either pointer, check if it’s at pEnd; if so, reset it to pBuf (the buffer’s start), otherwise simply increment it.","61b2591f-13d9-3b10-940e-2522f79b0e89":"Any CSC can call this routine to log an error or event for DPU housekeeping. When it’s invoked from an interrupt context, it sets a static global variable, ccmISRError, so the error can be enqueued later by ccmCtrlTask(), since the error/event queue is protected by a semaphore that cannot be acquired in an ISR. The semaphore uses priority-inversion mitigation to minimize contention among callers. If the same error happens repeatedly in a high-rate reporting period, the routine replaces subsequent occurrences with a special repeat error code that follows the original error code to indicate multiple occurrences.","0632eaf7-bc30-3e29-bf6e-e62711e0b914":"This routine enables configuring the DCI data acquisition window parameters by validating the requested settings before passing them to the DCI driver; if the validation fails, it returns an error and leaves hardware windowing disabled, and if it succeeds, it applies the settings and activates hardware windowing.","18bf5d9b-1436-36de-a166-a996d645230d":"This function configures how many frames the DCI CSC’s ping-pong buffers load before triggering an interrupt. The initial depth is set by the parameter passed to tmaliTask at startup, and it cannot exceed 64 frames—any request over 64 reverts to the default V-frame timeout. If the DCI bus is busy, the change may be briefly delayed and normally takes effect right after a frame-level or timeout event is reported, minimizing the risk of altering settings close to a hardware detection. Changing the depth while the CSC is processing data may cause unpredictable results. If a new tmaliDciFrameDepthSet command arrives before the previous one is applied, it replaces the earlier request and is enforced at the first available opportunity.","6306ea9a-5e36-3db6-9888-08f5f65849a5":"Memory uploads and downloads can target various destinations—DRAM, EEPROM, hardware registers, or the EEPROM filesystem. The D_MEM_DAT_UPLD command designates the target. When the EEPROM filesystem is chosen, a block number is sent instead of a memory address; the DPU FSW uses that number to create a filename in the form eefs1:DPU_blk.##, where ## is the block number. Once all upload data is received, it is written to that file, overwriting any existing file of the same name. The EEPROM filesystem can be reinitialized with the D_MEM_DISK_INIT command.","35c05af7-4ad3-3aff-9fef-1ca76b881940":"The global data items that are accessed by this CSC.","7ab71504-6bbc-3089-a3f6-e4d78f156dbe":"If an upload exceeds 65 535 bytes, it must be split into multiple parts of no more than 65 535 bytes each and sent one after another. Because each part carries a sequence number, the DPU FSW may receive them out of order. There is no time restriction on completing a single virtual upload, so lengthy transfers can span multiple ground contacts. While an upload is underway, sending the final sequence number causes the DPU FSW to issue event S_ccm_MISSING_SEQNO with any missing sequence numbers. To cancel an ongoing upload, issue the D_MEM_DAT_CNCL command.","a517e921-2c94-3e2e-94c5-9eec6a100106":"The bit layout of the DCI control/status register is configurable using tmaliBitArrangementSet().","aee05ebe-70d6-3fa6-bf04-908fed5ee77b":"Commands are pulled from the Command Queue and handled by ccmCmdTask(), which blocks on a semaphore signaled by ccmCmdEnq(). When the semaphore is released, ccmCmdTask() invokes ccmCmdProcess() to fetch each pending command and calls ccmCmdDispatch() to verify its length and execute it. If command echo is enabled, ccmCmdDispatch() calls ccmHkMkCmdEcho() to send the command back to the ground. The system keeps count of both executed and rejected commands. If ccmCmdEnq() receives a 1 Hz Clock Time message or a spacecraft Attitude message, these are not queued but are processed immediately in interrupt context: Attitude messages are forwarded to dpaCommandSend(), and the clock time parameters go to tisTimeSync() for time synchronization. Any other messages that are not from the DPU or the spacecraft observatory are quietly discarded. To ensure ccmCmdTask() still reports in to the CCM Control Task when no ground commands arrive, the semaphore has a 20 second timeout; if it expires, the task checks that the queue is empty and then calls ccmTaskReport().","277f0370-f6a2-3ae9-a75e-2683d446a347":"The DPU provides eight distinct types of housekeeping packets for control and monitoring.","46a47c92-0a83-34be-b468-1143774393e2":"In DCI, the optimal frame depth will be determined by benchmark testing and defaults to ten frames. Based on the above data, reading ten maximum-sized frames at the maximum transfer rate takes approximately 24 milliseconds.","f0cc222b-4d06-3f55-a85f-77b8cc1b5e0e":"Commands are removed from the Command Queue and executed by the ccmCmdTask() dispatch task, which blocks on a semaphore released by ccmCmdEnq(). When the semaphore is given, ccmCmdTask() wakes up and calls ccmCmdProcess() to retrieve waiting commands. Each command is then passed to ccmCmdDispatch(), which checks its expected length and runs it; if command echo is enabled, ccmCmdDispatch() calls ccmHkMkCmdEcho() to echo the command back to the ground. The system maintains counts of executed and rejected commands. If ccmCmdEnq() receives a 1 Hz Clock Time message or a spacecraft Attitude message, that message is not queued but is handled immediately in the interrupt context: Attitude messages are forwarded to dpaCommandSend(), and 1 Hz Clock Time messages supply parameters to tisTimeSync() for time synchronization. Any other messages not from the DPU or the spacecraft observatory are discarded without error. To ensure ccmCmdTask() still reports periodically in the absence of ground commands, its semaphore has a 20-second timeout. If the semaphore times out, the task verifies the Command Queue is empty and then calls ccmTaskReport() to check in with the CCM Control Task.","b3d600d2-cf3e-35e7-ba9d-73e1b90b302a":"Data can be uploaded to DRAM, EEPROM, hardware registers, or the EEPROM filesystem by issuing the D_MEM_DAT_UPLD command to specify the target. If the EEPROM filesystem is chosen, a block number is provided instead of a memory address, and the DPU FSW creates a filename eefs1:DPU_blk.## using that block number. After receiving the complete data, the DPU FSW writes it into the file, overwriting any existing file with the same name. The EEPROM filesystem can be reinitialized using D_MEM_DISK_INIT.","c08eb2e4-b3fa-359c-8f57-d2ee1889e360":"This ring buffer design makes management straightforward, but when it’s full one slot remains unused so that pIn is immediately behind pOut, and the buffer is empty when pIn and pOut point to the same location.","1ca8a9c9-d97c-38e2-8e1a-72241ec0228b":"The DCI’s hardware windowing feature is enabled and configured via tmaliDciWindowSet(), which activates the function and sends the specified window parameters to the DCI driver.","1d34025f-a3fb-3da6-a26f-4725c52ac084":"The ccmCmdTask() function waits on a semaphore signaled by ccmCmdEnq(), and when released it calls ccmCmdProcess() to pull commands from the Command Queue and pass them to ccmCmdDispatch() for length verification and execution. If command echo is on, ccmCmdDispatch() calls ccmHkMkCmdEcho() to send the command back to ground. Counts of accepted and rejected commands are maintained. If ccmCmdEnq() receives a 1 Hz Clock Time message or a spacecraft Attitude message, that message bypasses the queue and is handled immediately in interrupt context: Attitude messages are sent to dpaCommandSend(), and the clock time parameters go to tisTimeSync() for time synchronization. All other messages not from the DPU or the observatory are dropped silently. To ensure periodic check-ins with the CCM Control Task even without ground commands, the semaphore times out after 20 seconds; on timeout, ccmCmdTask() confirms the queue is empty and then calls ccmTaskReport().","d2a9c9b3-60a4-33ea-8be0-b9c583f74036":"This function lets you set the DCI data timeout in milliseconds.  The initial frame depth value comes from the parameter supplied when tmaliTask is started.  You can command a timeout up to X seconds; if you specify a value above that limit, the timeout is reset to the default of X milliseconds.","5bd67670-29bd-3756-928e-ba01196ad5f0":"Once all events in the Ping-Pong buffer have been transferred to the TMALI_EVENT_QUEUE, tamliTask() must re-arm the DCI hardware to permit the next buffer swap. If tamliTask() fails to move the data from the ping buffer before the pong buffer fills, the DCI driver issues an error interrupt that invokes tmaliDciErrorReportedISR(). That ISR sets an error flag so tamliTask() can recover, and it gives the semDciWait semaphore to wake tamliTask()—even if it’s already running—to cover the case where the transfer just completed as the error occurred. The error is also recorded in TMALI_HK. Meanwhile the DCI hardware discards incoming events until tamliTask() finishes the prior transfer, detects the error flag, manually forces a Ping-Pong swap, and re-enables acquisition. This guarantees that only complete frames remain in the Ping-Pong buffer for processing. Under normal conditions this error should not occur because tamliTask() should keep up with data retrieval; if it cannot, the TMALI queue will fill and trigger an S_TMALI_QUEUE_FULL error via ccmErrEnq().","0c11996b-fb22-3be5-96a2-18b6f06945d3":"When a file to be uploaded exceeds 65 535 bytes, it must be divided into multiple parts, each no larger than 65 535 bytes, and those virtual uploads sent in sequence. Because each part carries a sequence number, the DPU FSW may receive upload commands out of order. There is no time limit on completing a single virtual upload, allowing a long transfer to continue across ground contacts. If an upload is in progress, sending the last sequence number to the DPU FSW will trigger event S_ccm_MISSING_SEQNO, which lists any missing sequence numbers. To cancel an ongoing upload, issue the D_MEM_DAT_CNCL command.","a216bd7b-d315-3ab9-89a4-a6f926b45fe7":"This public routine is invoked by each DPU FSW task to signal it has executed, allowing ccmCtrlTask() to evaluate the health of DPU FSW execution.","975b1774-03bf-336c-ae7e-ffff46169a9d":"The TMALI CSC acts as an intermediary for EVENT data sent by the DCI Driver CSC on its way to the DPA CSC. It waits for a signal from the DCI CSC that the Ping-Pong buffer has reached its frame limit or timed out, indicating data readiness. Then it retrieves all EVENT data, informs the DCI that it may swap the Ping-Pong buffers, and releases a semaphore to resume the tmaliWait() call in the DPA.","1668125c-e5cf-3214-9a19-ff08fc6a3b2c":"The bit layout of the DCI control/status register is configurable using tmaliBitArrangementSet().","d79334e6-dfaf-3c3e-8091-c92ccfc7f0be":"This routine allows configuring the DCI data timeout in milliseconds. The initial frame depth is set by the parameter passed when tmaliTask starts. If a requested timeout exceeds the maximum of X seconds, it will be reset to the default of X milliseconds.","ca7de908-1c8f-3002-be00-239b447a3fc6":"This routine retrieves the TMALI CSC’s housekeeping data, including certain DCI parameters, and resets its internal counters to zero. If the caller’s TMALI_HK pointer is NIL, no data are returned but the counters are still reset. Two of the four error counters are updated within an ISR, so they must be task-safe. Instead of a VxWorks counting semaphore, the TMALI CSC uses a free-running 32-bit error counter and a temporary variable to update the reported count. Because incrementing and assigning 32-bit unsigned integers are atomic operations, this method is task-safe and no error events are lost. Consequently, the total errors reported by tmaliHkGet() exactly match the actual errors that occurred.","2888db66-3ffd-3485-8be8-8076a586865f":"The Command and Control CSC (CCM) is a Level 2 reusable component from the INSTRUMENT Y project. It comprises a Control Task, ccmCtrlTask(), which initializes the DPU flight software at startup, spawns and monitors other tasks, schedules periodic activities such as generating housekeeping data packets, sending heartbeat messages, and strobing the watchdog, and oversees overall task execution; and a Command Dispatch Task, ccmCmdTask(), which receives real-time commands from the SCU or ICU and dispatches them for processing.\n\nKey data structures include a Static Data table that records the system’s operational state—such as housekeeping production rates, CCM-specific flags, and the number of commands executed—a Command Queue that holds incoming commands delivered by interrupt from the ICU or SCU, and an Error/Event Queue that accumulates error and event codes reported by the DPU flight software and periodically transfers them into telemetry packets for inclusion in the housekeeping data.","aa84b30f-c6b4-347d-aeaa-ff9e26f53084":"The bit layout of the DCI control/status register can be configured using tmaliBitArrangementSet().","27ff9481-9811-341e-893e-3af6324612d3":"Commands are pulled from the Command Queue and handled by ccmCmdTask(), which blocks on a semaphore released by ccmCmdEnq(). When the semaphore is given, ccmCmdTask() invokes ccmCmdProcess() to retrieve queued commands and pass them to ccmCmdDispatch(), which verifies each command’s length, executes it, updates counts of accepted and rejected commands, and—if echo is enabled—calls ccmHkMkCmdEcho() to send the command back to the ground. If a 1 Hz Clock Time or Attitude message arrives via ccmCmdEnq(), it is not enqueued but executed immediately in interrupt context: Attitude messages go to dpaCommandSend(), and 1 Hz Clock Time messages go to tisTimeSync() for time synchronization. Any other non-DPU or non-spacecraft observatory messages are discarded without error. To ensure periodic status reporting when no ground commands arrive, the semaphore in ccmCmdTask() times out after 20 seconds; on timeout, the task checks that the queue is empty and then calls ccmTaskReport() to report in with the CCM Control Task.","a56431fb-e16d-3fbe-9fa7-9b728a5d9301":"When large amounts of memory must be uploaded to the DPU, for example to apply a software patch or perform a complete software upload, the standard memory upload procedure is used. Uploads consist of a series of individual D_MEM_DAT_UPLD commands that together form one logical upload. CCSDS‐style sequence flags allow the DPU flight software to accept up to 65,535 bytes in a single logical upload. Each command’s data is stored in a temporary DRAM buffer until all sequence numbers have been received. When the last command arrives, the flight software verifies that every sequence number has been received, checks the end-to-end upload checksum, and then writes the entire buffer to the target location specified in the first command.","034821fa-e846-3d5f-a712-2cab3aab6cc4":"Events are retrieved from the TMALI_EVENT_QUEUE by the DPA CSC using an API made up of tmaliWait() and tmaliNextEvent(). To optimize performance, tmaliNextEvent() is inlined to eliminate the overhead of a function call, each event is loaded into a register and fully processed there before fetching the next one, and because tmaliNextEvent() performs no error checking, the DPA CSC is responsible for tracking the number of events retrieved against the number returned by tmaliWait().","caf39fb3-5550-3e2d-9d7b-0a369f1b0948":"The bit arrangement of the DCI control/status register can be configured using tmaliBitArrangementSet().","98f777a5-8d50-3772-a55b-abd45958b813":"TMALI CSC functions as an intermediary for EVENT data coming from the DCI Driver CSC and going to the DPA CSC. It waits for a notification from the DCI CSC that the Ping-Pong buffer has reached its frame limit or data timeout, indicating the EVENT data is ready. TMALI then reads all the EVENT data from the DCI and signals the DCI that it can swap the Ping-Pong buffers when ready. Finally, TMALI releases a semaphore to unblock the tmaliWait() call in the DPA.","31310305-81b9-3860-b8d7-087a5e789bd6":"This routine retrieves the DCI’s current data timeout value and returns it in milliseconds. See document 036911400, section 4.3.2.4.1.3 for details.","b35d2bcd-847d-397a-92ad-b8714eac445f":"The CCM Control Task initializes the DPU flight software and ensures a successful startup by launching the SCU Interface Task and the CCM Command Task, then waiting up to five seconds on temporary semaphores for each to signal successful initialization. If both signals are received, it toggles the BC_INDEX parameter in EEPROM; if either fails, it disables the watchdog strobe to trigger a DPU reboot. These two tasks are deemed essential for establishing ground contact and commandability. Once initialization finishes, the CCM Control Task blocks on a binary semaphore provided by the SCUI Command ISR when the 1 Hz Clock Message arrives, with a 1.5 second timeout. The task then remains active to generate and transmit DPU housekeeping at set intervals, carry out periodic processing, and handle memory dump commands. Finally, it invokes ccmErrEnq() so that any errors from interrupt routines update a global errno variable and are enqueued in the Error/Event Queue during the task’s regular processing.","3c62a5be-6021-3217-bbf6-e225d1e89e3b":"Whenever the CCM Control task runs, it calls ccmPerProcess() to perform periodic duties such as updating analog-to-digital conversions, monitoring DPU tasks, generating ICU heartbeat messages, and stroking the watchdog. Within ccmPerProcess(), ccmHealthChk() verifies other tasks’ operation by tracking the time since each last reported. Tasks signal their execution to the CCM Control Task via ccmTaskReport(), supplying their task index. If any task fails to run at its expected frequency, an error is logged in DPU housekeeping. If the Command Dispatch Task does not report for an extended period—preventing any commands from reaching the DPU—the system reboots; otherwise the watchdog continues to be strobed.","0b4bb7d4-ab4a-3536-807b-cdeb5579a6bd":"This function configures the frame depth of the Ping-Pong buffers used by the DCI CSC, determining how many frames are loaded into the selected buffer before triggering an interrupt. The initial depth is set by the parameter provided when tmaliTask starts. You can command the frame depth up to a maximum of 64 frames; any attempt to exceed this maximum causes it to revert to the default value of V frames. Applying the new frame depth may be delayed slightly if there is activity on the DCI bus and typically takes effect immediately after the DCI reports that a frame threshold or timeout condition has occurred. This minimizes the risk of changing the setting while the hardware is about to detect a frame event, since modifying the depth during DCI CSC data processing could lead to unpredictable results. If a new tmaliDciFrameDepthSet command is issued before the previous setting is activated, the latest request overwrites the earlier one and the DCI will adopt the new value at the first available opportunity.","3bffeba3-2c78-3628-ab1e-e8ad0e595c1d":"This function retrieves the TMALI CSC’s housekeeping data, including selected DCI parameters, then zeroes all internal TMALI counters. If the caller passes a NIL pointer for a TMALI_HK structure, no data is returned, but the counters are still reset. Two of the four error counters are incremented in an ISR, so they must be protected against task switches. Although VxWorks could use a counting semaphore for this, the TMALI CSC employs a faster technique: it maintains a free‐running error counter and updates the reported count using an extra temporary variable. Because 32-bit unsigned integer increments and assignments are atomic, the counters remain safe across tasks and no error events are dropped. As a result, the total errors reported by tmaliHkGet() exactly matches the actual number of errors recorded.","47c13b41-538f-356c-a7de-59ca84d0b120":"When a command arrives from the SCU over the 1553 interface or from the ICU over the SSI interface, the corresponding ISR enqueues the packet into the Command Queue and signals the semaphore to wake ccmCmdTask(). Because the DPU can send commands to itself, commands may be received in interrupt context or in task context. To handle this, the CCM uses two queues: an unprotected one for interrupt context and a semaphore-protected one for task context.","36a3d67a-5efb-356f-89fa-34069ee1a724":"The CCM Control Task initializes the DPU flight software by launching the SCU Interface Task and the CCM Command Task, then waits on temporary semaphores with five-second timeouts. If both tasks signal successful initialization, it toggles the BC_INDEX parameter in EEPROM to record a successful boot; if either fails to report success, it disables the watchdog strobe to reboot the DPU. These two tasks are deemed the minimum required for ground contact and commandability. Once initialized, the task blocks on a binary semaphore released by the SCUI Command ISR when the 1 Hz Clock Message arrives, timing out after 1.5 seconds if no message is received. The CCM Control Task then remains active to generate and send DPU housekeeping data at the proper intervals, perform periodic processing, and handle memory dump commands. Finally, it calls ccmErrEnq() so that any error occurring in an interrupt service routine sets the global errno and is enqueued into the Error/Event Queue during its normal processing.","538575b2-0798-3439-bfdf-f36375d23a83":"At startup the TMALI CSC spawns tmaliTask() with default parameters; this task allocates memory for the TMALI_EVENT_QUEUE, installs DCI interrupt handlers, initializes static variables and data structures, and then runs an endless loop that moves data from the DCI into the TMALI queue, throttled by the semDciWait semaphore.","c15544ec-0a76-3779-8098-5095d8b1a935":"The ccmErrEnq() function keeps track of the most recent error code and how many times it occurs in a row. When an error is reported, it becomes the “previous” error and each immediately following occurrence of that same code increments a repeat counter. If the same error appears more than once during a single high-rate housekeeping cycle, the function enqueues a special S_ccm_ERR_REPEAT error, embedding the repeat count in its least significant byte. This prevents housekeeping telemetry from being flooded by a single recurring error.","5233365f-9b83-3955-ba6b-6538d1f40a91":"This routine is invoked by the MIL-STD-1553 Command ISR once per second upon Clock Message arrival to signal the CCM Control Task, which is waiting on a semaphore after finishing its processing.","135782dc-e228-3b2c-9534-6f645acae157":"This function sets the bit arrangement for the DCI: if bSpecialArrangement is TRUE, the DCI uses a special bit arrangement mode; otherwise, it remains in the default no-rearrangement mode.","4e4d0e01-f3e0-3be1-bf88-a7b0c61b37cd":"This routine allows configuring the DCI’s bit arrangement: if bSpecialArrangement is TRUE, the DCI uses the special bit arrangement mode; if FALSE, it uses the default mode with no rearrangement.","25827c10-2881-3b70-9724-65b4b4d6d11c":"The DPU accepts commands through two links—the Spacecraft’s MIL-STD-1553 interface and the ICU’s SSI interface—and any command may originate from either the SCU or the ICU. Commands can be generated and sent directly by the ICU via SSI, by the SCU via 1553, or by ground stations routed through the ICU over SSI (G-ICU) or through the SCU over 1553 (G-SCU).","2d98be0f-c7df-3dec-82a6-ade1a628100b":"At startup, the CCM Control Task initializes the DPU Flight Software and ensures a successful boot by launching the SCU Interface Task and the CCM Command Task, then blocking on temporary semaphores with five-second timeouts. If both tasks signal success by releasing their semaphores, the CCM Control Task toggles the BC_INDEX parameter in EEPROM to mark the successful boot; if either fails to signal in time, it disables the watchdog strobe to force a DPU reboot. These two tasks define boot success because they are the minimum required for ground contact and commandability. Afterward, the task waits on a binary semaphore given by the SCUI Command ISR upon receiving the 1 Hz Clock Message, timing out after 1.5 seconds if no message arrives. The CCM Control Task remains active to generate and transmit DPU housekeeping data at scheduled intervals, perform periodic processing, and handle memory dump commands. Finally, it invokes ccmErrEnq() so that any error occurring in an interrupt service routine sets a global errno and enqueues it into the Error/Event Queue during its normal processing.","80150773-c06a-3d3f-9935-9d4bcca2bc9a":"The TMALI CSC gathers housekeeping data that can be obtained by calling tmaliHkGet(), and this data is provided within the TMALI_HK data structure.","663c1163-fd4e-35e2-abb6-4c47fc49bdd4":"To prevent rollover loss, ccmErrEnq() monitors each error’s count during a high-rate housekeeping period to ensure it doesn’t exceed 250. If an error count goes over 250 in that period, ccmErrEnq() enqueues an S_ccm_ERR_REPEAT error with the current count and then resets its tracking.","03478262-130f-3964-8fa8-3479f3f418fb":"The Command and Control (CCM) component is a Level 2 reusable module from the INSTRUMENT Y project. It consists of two primary tasks: ccmCtrlTask(), which initializes the DPU flight software, starts other tasks at bootup, manages the generation of housekeeping data packets, monitors task execution, and schedules recurring activities like heartbeat messages and watchdog strobes; and ccmCmdTask(), which accepts and routes real-time commands from the SCU or ICU. The component relies on several data structures: a static data table that records operational state information such as housekeeping production rates, CCM-specific flags, and the count of executed commands; a command queue that holds incoming commands delivered via interrupts; and an error/event queue that collects error and event codes reported by the DPU flight software for periodic inclusion in telemetry housekeeping packets.","031e14d2-bb27-3d48-be0a-48a59748bc70":"The CSC uses a ring buffer to implement a FIFO that temporarily stores data received from the DCI until it is processed. Two pointers, pIn and pOut, track the buffer’s contents. They are arranged so that reading requires only a single comparison to check if the buffer is empty. The buffer holds only four-byte Events, so the pointers move in four-byte increments, and because the DCI specifies sizes in bytes, those byte counts must be converted before reading.","e74f9800-7d16-3e6b-b471-427abfb20195":"This function retrieves the TMALI CSC’s housekeeping data—including certain DCI parameters—and then resets the internal tmali counters to zero. If the caller passes a NIL pointer for the TMALI_HK structure, no data is returned but the counters are still cleared. Two of the four error counters are updated in an interrupt context, so they must be safe against task switches. Instead of using a counting semaphore in VxWorks, the TMALI CSC uses a free‐running error counter plus a temporary variable to update the reported error count. Since incrementing and assigning 32‐bit unsigned integers are atomic operations, this method is task‐safe and no error events are lost, ensuring that the tmaliHkGet() function reports exactly the total number of errors that occurred.","e1ddcd17-1a3e-3a6b-a66d-1b059a98d643":"When a command is received from the SCU via the 1553 interface or the ICU via the SSI interface, the corresponding ISR enqueues the command packet into a Command Queue and gives the semaphore to wake the ccmCmdTask(). Because the DPU can send commands to itself, commands may arrive in either interrupt or task context. Consequently, the CCM maintains two queues—one unprotected for interrupt context and one semaphore-protected for task context.","9204e391-11e9-38b5-952b-bc5987df80c9":"Public Functions This routine is invoked by the MIL-STD-1553 Command ISR at 1 Hz on each Clock Message arrival to signal the semaphore and wake the CCM Control Task, which blocks on that semaphore after completing its processing.","dc15d9eb-624a-389f-b3e0-e9ac943f90d5":"This routine retrieves the TMALI CSC housekeeping data, including certain DCI parameters, and then resets all internal TMALI counters to zero. If the caller passes a NIL pointer for the TMALI_HK structure, no data is returned but the counters are still cleared. Two of the four error counters are incremented inside an ISR, so they must be safe against task switches. Instead of using a counting semaphore as one might in VxWorks, the TMALI CSC employs a continuously running error counter and uses a temporary variable to adjust the reported error count. Because incrementing and assigning 32-bit unsigned integers are atomic operations, these counters remain task-safe and no error events are lost. As a result, the total errors reported by tmaliHkGet() exactly match the actual number of errors that occurred.","d6b7acb6-fab6-3142-a91d-709b94733e22":"Each time the CCM Control task runs, it invokes ccmPerProcess() to carry out periodic duties such as updating analog-to-digital conversions, monitoring DPU tasks, generating ICU heartbeat messages, and stroking the watchdog. Within ccmPerProcess(), ccmHealthChk() checks that other tasks are running by measuring how long it has been since each last reported. Tasks report their activity by calling ccmTaskReport() with their task index. Each task must meet a defined execution rate, and if one misses its schedule, an error is logged in DPU housekeeping. If the Command Dispatch Task goes unreported for too long—making it impossible to issue commands—the DPU reboots; otherwise it simply strobes the watchdog.","207c506d-8917-34dd-8465-51972c8f0d7c":"This routine lets you configure and activate DCI hardware windowing parameters for data acquisition. It first validates the requested window settings, and if they’re invalid it returns an error without enabling windowing. If they’re valid, it applies the new hardware window specification and turns on the windowing function.","0607f776-bfb5-30d9-8da4-255be7ea627c":"This routine is invoked by any CSC to log an error or event for DPU housekeeping. If it’s called from an interrupt, it sets the static global ccmISRError so the error can be queued later by ccmCtrlTask(), since the error/event queue is protected by a semaphore that can’t be taken in an ISR. The queue’s semaphore uses priority inversion handling to minimize conflicts among callers. The routine also replaces frequently recurring errors with a special repeat error code, which follows the original error code to indicate it occurred more than once during the last high-rate reporting period.","182934c6-09d7-31b0-a5df-fc581c7f1a81":"ccmErrEnq() can also be invoked from interrupt context. Since taking a semaphore is illegal in an interrupt, the Error Queue’s mutual exclusion mechanism cannot be used there. Instead, the appropriate error code is stored in the global variable ccmISRerror, and the error is enqueued the next time ccmTask() runs. Because only the latest interrupt-context error is saved in ccmISRerror, any earlier error occurring before ccmTask() executes will be overwritten.","6c8b8d9e-3d7e-3d38-82cd-1e9d335fd296":"The TMALI CSC comprises several components. It maintains the TMALI_EVENT_QUEUE, a ring buffer that stores detector events received from the DCI Driver via the data capture interface until the DPA CSC retrieves them. The DPA CSC accesses these events through an API consisting of tmaliNextEvent() and tmaliWait() functions. Additional API functions—tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet() and tmaliDataTimeoutGet()—allow the DPA CSC to configure the DCI interface. The tmaliHkGet() function collects housekeeping data for the CSC at the Command and Control Task’s request. Data transfer from the DCI to the queue is coordinated by the tmaliTask() and the tmaliTransferToQueueISR(), which use a semaphore for synchronization. Finally, the tmaliDciErrorReportedISR() hook, installed in the DCI Driver, monitors and records the number of errors reported.","a3467d51-caa1-37cd-929b-8bf38158672f":"When tmaliTransferToQueueISR() runs, it releases a semaphore that wakes tmaliTask(), which then moves data onto the VME bus queue. tmaliTask() calls the DCI driver’s read() routine, which uses a fast assembly-language transfer. Because the TMALI buffer is a ring implemented as an array, tmaliTask() first checks TMALI_EVENT_QUEUE to see if all the data in the DCI buffer can be read in one call or if it must split the transfer into two calls to handle wrap-around at the end of the buffer. It then verifies there is enough free space for all frames in the Ping-Pong buffer. If there isn’t room for the complete set, tmaliTask() discards the entire readable Ping-Pong buffer and reports S_TMALI_QUEUE_FULL via ccmErrEnq. The discarded data always corresponds to whole CCD frames because the hardware only switches Ping-Pong buffers at frame boundaries. By dropping newer data, this policy preserves the earliest post-burst events, which have the greatest scientific value.","735654db-72ea-373d-8b36-3413989a2303":"In the ring buffer data structure, a separate pointer pEnd marks the last available slot in the buffer. Before advancing either pointer, check whether it currently points to this final location; if it does, reset it to the start of the buffer at pBuf, otherwise increment it.","15b45ceb-ddf7-358d-8bea-d721192df5d3":"The DCI’s hardware windowing feature is enabled and managed through tmaliDciWindowSet(), which activates hardware windowing and transfers the specified window parameters to the DCI driver.","3fedffab-ecd8-364a-8ef0-41e406f67349":"The ccmErrEnq() function records the most recent error and counts how many times it occurs in a row. When an error is reported, it becomes the “previous” error and each identical, consecutive report increments a repetition counter. If the same error appears more than once within a single high‐rate housekeeping reporting cycle, the function enqueues a special error code, S_ccm_ERR_REPEAT, with the repeat count placed in its least significant byte. This prevents the housekeeping telemetry from being overwhelmed by a flood of identical errors.","a84c1785-8432-388f-b894-2b2546dc63b6":"At boot time, since the error queue hasn’t been created yet, any errors that occur are recorded directly in the global task variable errno. For more details on errno, refer to section 2.3.7 of the VxWorks® Programmer’s Guide. Once the error queues are established, if errno is set it is added to the queue by invoking ccmErrEnq().","9094754e-cf4a-3fb7-8159-25d10c9e18ae":"ccmErrEnq() can also be called from interrupt context. Because it’s illegal to take a semaphore in an interrupt, the mutual exclusion used by the Error Queue can’t be applied there. Instead, the appropriate error code is stored in the global variable ccmISRerror, and the error is added to the queue the next time ccmTask() runs. However, if more than one error occurs in interrupt context before ccmTask() executes, the earlier error is overwritten by the new one, so errors can be lost.","a78cb0f7-4a56-315b-9707-9d1a999b9433":"The CCM Control Task also manages memory dump commands. When such a command is received, it divides the dump into smaller segments and transfers one segment each time the task is activated. This deferred approach prevents a large dump from monopolizing CPU time or keeping the high-priority CCM Command Dispatch Task busy for too long.","13a33233-e355-37f6-af42-e3c52ef4a137":"The global data elements accessed by this CSC.","abb354a7-50a8-3ce4-ba91-99c573f53939":"If the TMALI queue is empty, the function blocks on a semaphore until the ISR signals that events have arrived; if there are already events in the queue or the semaphore is immediately available, it counts and returns the number of events. The TickstoWait parameter sets the maximum wait time in kernel ticks, or can be set to FOREVER to wait indefinitely. If a finite timeout expires with no data, the function returns zero. If the TMALI task has not been initialized, it returns an error.","47b32ee5-d3c0-3863-b2d3-2eabc3b0fd23":"During system startup, before the error queue is created, any errors are stored directly in the global task variable errno. For more details on errno, see section 2.3.7 of the VxWorks® Programmer’s Guide. Once the error queue exists, any errno value that is set is added to the Error Queue by calling ccmErrEnq().","00ea49ee-4bb7-391c-9764-6de09ffe3fae":"The bit layout of the DCI control/status register can be configured using tmaliBitArrangementSet().","ed97367d-60ae-37b7-a0bc-1d9d617425cc":"The TMALI CSC comprises a ring‐buffer queue named TMALI_EVENT_QUEUE that holds detector events received over the DCI Driver’s data capture interface until they’re retrieved by the DPA CSC. It offers an API—tmaliNextEvent() and tmaliWait()—to let the DPA CSC pull events from the queue. A set of configuration APIs—tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet(), and tmaliDataTimeoutGet()—allows the DPA CSC to configure the DCI interface. The tmaliHkGet() function gathers CSC housekeeping data at the Command and Control Task’s request. The tmaliTask() and the tmaliTransferToQueueISR() coordinate via a semaphore to move data from the DCI into the queue. An error‐handling ISR, tmaliDciErrorReportedISR(), hooks into the DCI Driver to track the number of errors reported.","42e4ddf0-576a-3f3a-a5b2-5f6ae43043ad":"There are two ways to upload data to the DPU: using the D_MEM_DAT_POKE command for small transfers of Z bytes or fewer, or using the D_MEM_DAT_UPLD command for larger uploads. The Z-byte limit on the poke operation is due to Company X’s command length constraint.","fd7aa5fa-c04d-3e66-bcda-30b9d15cc032":"Whenever the CCM Control task runs, it calls ccmPerProcess() to carry out its regular duties—updating analog-to-digital conversions, monitoring DPU tasks, generating ICU heartbeat messages, and stroking the watchdog. Inside ccmPerProcess(), ccmHealthChk() ensures other tasks are running by checking how much time has passed since each one last reported. Tasks report in by calling ccmTaskReport() with their task index. Each task must execute at a defined rate; if it misses its expected interval, a DPU housekeeping error is logged. If the Command Dispatch Task fails to report for an extended period, the DPU reboots—since commands cannot be processed otherwise—otherwise it simply strobes the watchdog.","5c6dd184-15cf-3b63-93e9-f88e90f97cbb":"To prevent rollover losses, ccmErrEnq() ensures that no error count exceeds 250 in a single high-rate housekeeping reporting period; if an error count does exceed 250, it enqueues an S_ccm_ERR_REPEAT error with the current count and resets its error tracking.","64a62731-7b98-308a-8aa7-6280741deb37":"The S_ccm_ERR_REPEAT error uses its low-order byte to encode how many times the last error has recurred. When a new error is reported, ccmErrEnq() will enqueue a S_ccm_ERR_REPEAT entry for any previously repeated error and then enqueue the new error itself. To keep each original error code paired with its repeat count in the same packet, ccmMkHkErr() enqueues a special code, S_ccm_ERRQ_FLUSH, signaling ccmErrEnq() to reset its error-tracking state and enqueue any pending repeat counts for that error.","77082507-d2bf-3ad7-9ba3-5eb3bc2e6228":"The DPU generates eight distinct types of housekeeping packets.","5c8d6104-5e61-3177-827d-0722aa6f3271":"When a command is received from the SCU via the 1553 interface or the ICU via the SSI interface, the appropriate ISR enqueues the command packet into the Command Queue and releases the semaphore to wake ccmCmdTask(). Because the DPU can issue commands to itself, commands may arrive in either interrupt or task context. Therefore, the CCM uses two queues: one unprotected for interrupt context and one semaphore-protected for task context.","f6d42825-93ff-3c93-97a7-34b7c8a6631b":"During normal operation, frames arrive about every 11 ms. The DCI hardware issues an interrupt when event data has been received into a Ping-Pong buffer and no further events occur within a configurable timeout period. This data timeout interrupt is not an error but typically indicates the end of the current exposure and enables the TMALI CSC to retrieve any trailing events from the DCI buffer. The tmaliDciTimeoutSet() function provides an API for the DCI driver to adjust this timeout setting.","d9317a0c-60a6-36cf-a4df-64a224616f6a":"Ring buffer data structure: pIn points to the last position written with data, and pOut points to the last position freed for new data.","58f96747-3b38-3b87-b88e-6234010d52cb":"Data uploads via the D_MEM_DAT_UPLD command can target DRAM, EEPROM, hardware registers, or the EEPROM filesystem. When the EEPROM filesystem is selected, a block number is supplied instead of a memory address, and the DPU FSW builds a filename “eefs1:DPU_blk.##” where ## is the block number. After receiving the complete upload, the software writes the data to that file in the EEPROM filesystem, overwriting any existing file of the same name. The EEPROM filesystem can be reinitialized with the D_MEM_DISK_INIT command.","82a50d85-b9e4-30fa-988b-9ad4076af19e":"The D_MEM_BLK_DNLD command retrieves a file from the EEPROM filesystem by specifying its block number, automatically forming the filename and downloading its entire contents. To download data from any other memory area, the D_MEM_DAT_DNLD command is used. Downloads are performed in a deferred manner to minimize CPU usage, and each logical download is delivered as a sequence of packets whose data must be extracted and concatenated in order to reconstruct the original data stream.","0206f39c-fe52-3c51-827b-55372a174fe0":"The CCM Control Task also handles memory dump requests by splitting a dump into manageable chunks and sending out one chunk each time it is invoked. This deferred approach ensures a large dump doesn’t monopolize CPU resources or keep the higher-priority CCM Command Dispatch Task occupied for too long.","b993686e-1a46-3ac5-b2a4-712e34d9774a":"Once all events in the Ping-Pong buffer have been transferred to TMALI_EVENT_QUEUE, tamliTask() must re-arm the hardware so it can swap buffers when ready. If tamliTask() fails to move data from the ping buffer before the pong buffer fills, the DCI driver issues an error interrupt that calls tmaliDciErrorReportedISR(). That ISR sets an error flag to allow recovery, posts semDciWait to awaken tamliTask() (even if it’s already running), and logs the error in TMALI_HK. Meanwhile, the DCI hardware drops incoming events until tamliTask() finishes the outstanding transfer, detects the error flag, forces a Ping-Pong swap manually, and restarts data acquisition. This ensures only complete frames are placed in the Ping-Pong buffer for processing. Under normal conditions this error should not occur because tamliTask() is expected to keep pace with the DCI buffer; if it cannot, the TMALI queue will fill and trigger an S_TMALI_QUEUE_FULL error via ccmErrEnq().","e4f70e1e-8be1-335f-9425-6a23d4108324":"This routine lets you set the DCI data timeout in milliseconds. The initial frame depth setting comes from the parameter passed when starting tmaliTask. You can command the timeout up to X seconds; if you request a value above that, the timeout will revert to the default of X milliseconds.","a8c0bbd3-0871-3761-ae67-a8281a387eb3":"In the normal data exchange sequence, the TMALI CSC acts as an intermediary for EVENT data received from the DCI Driver CSC and passed on to the DPA CSC. TMALI waits for the DCI CSC to signal that the ping-pong buffer has reached a frame limit or data timeout, indicating the EVENT data is ready. TMALI then reads all EVENT data from the DCI, tells the DCI when it can swap ping-pong buffers, and releases a semaphore to unblock the DPA’s tmaliWait() call.","c8b8bfe7-d485-3f2e-953b-5a26844e7342":"Events are fetched from the TMALI_EVENT_QUEUE by the DPA CSC using two API functions, tmaliWait() to obtain the number of available events and tmaliNextEvent() to retrieve each one. To maximize efficiency, tmaliNextEvent() is inlined to eliminate call overhead, each event is loaded into a register and fully processed there before the next fetch, and because tmaliNextEvent() performs no error checking, the DPA CSC must track the count of events retrieved against the count returned by tmaliWait().","58f9caa6-b404-3226-b740-8d07bb15ce1d":"In the ring buffer, a dedicated pointer pEnd designates the last valid slot. Before moving either pointer, check if it equals pEnd; if it does, wrap it around to the buffer start at pBuf, otherwise simply increment it.","57c1ffd3-3858-3277-a857-88f0a767ba13":"This function configures the frame depth of the DCI CSC’s ping-pong buffers, specifying how many frames are read into the selected buffer before raising an interrupt. The initial depth comes from the parameter given to tmaliTask at startup. You can set the depth up to 64 frames; requesting a larger value resets the timeout to the default V-frame setting. Applying a new depth may be briefly deferred if the DCI bus is active, and it normally takes effect right after the DCI signals a frame-level reached or a timeout, preventing changes when the hardware is about to detect a frame event—which could otherwise cause unpredictable results. If a new tmaliDciFrameDepthSet command is issued before the previous one is activated, the new request replaces the old one and is applied at the first available opportunity.","c7cd0f75-1de3-3eb1-ad6f-788bbd9270b4":"The Command and Control (CCM) component is a Level 2 reusable module from the INSTRUMENT Y project. It consists of two primary tasks: ccmCtrlTask(), which initializes the DPU flight software, starts other tasks at bootup, manages the generation of housekeeping data packets, monitors task execution, and schedules recurring activities like heartbeat messages and watchdog strobes; and ccmCmdTask(), which accepts and routes real-time commands arriving from the SCU or ICU. The component also maintains several key data structures: a static data table that records operational state information—such as housekeeping packet rates, CCM flags, and the count of commands executed—a command queue that holds incoming commands delivered via interrupts, and an error/event queue that collects error and event codes reported by the DPU flight software for inclusion in telemetry packets at scheduled intervals.","e0027008-781c-3c57-952d-d88d710682c1":"The set of global data items accessed by this CSC.","f018e08c-525d-3557-a377-b316b27047ab":"At system startup, no error queue exists until it is created, so any errors occurring at this stage are stored in the global task variable errno. For more information on errno, see section 2.3.7 of the VxWorks® Programmer’s Guide. Once the error queues are established, any errno value that is set is added to the Error Queue by calling ccmErrEnq().","bcc0333b-e0d8-3b5c-a2ee-2b6503dfde4c":"During initialization, the TMALI CSC installs the ISR hook routine tmaliTransferToQueueISR() into the DCI Driver; this routine is invoked whenever the DCI interface reaches its configured frame limit in the ping-pong buffer or encounters a data receipt timeout.","3c9e5b7a-bb30-3111-8cc4-650de63db83a":"Upon startup, the CCM Control Task initializes the DPU flight software and is responsible for ensuring a successful boot. It spawns the SCU Interface Task and the CCM Command Task, then waits on two temporary semaphores, each with a five-second timeout. If both tasks signal successful initialization by releasing their semaphores, the CCM Control Task toggles the BC_INDEX flag in EEPROM to record a successful boot; if not, it disables the watchdog strobe to force a DPU reboot. These tasks are considered the minimum required for ground contact and commandability. Afterward, the task waits on a binary semaphore that the SCUI Command ISR gives upon receipt of the 1 Hz clock message; if no clock message arrives within 1.5 seconds, the wait times out. Throughout operation, the CCM Control Task remains active to generate and transmit DPU housekeeping data at scheduled intervals, perform periodic processing, and handle memory dump commands. Finally, each invocation of ccmErrEnq() ensures that any errno set by an interrupt service routine is stored in a global variable and enqueued into the Error/Event Queue as part of the task’s normal processing.","e9627548-70f6-388b-82d6-a0be65101628":"During system startup, no error queue exists yet, so any errors that occur are recorded directly in the global task variable errno. For more details on errno, see section 2.3.7 of the VxWorks® Programmer’s Guide. Once the error queues have been created, any errno value is added to the Error Queue by calling ccmErrEnq().","bc03785b-4b3e-356f-91ab-8c0ec53f1af9":"The Telescope Module Access Library and Interface CSC controls the detector event queue and offers an API for data processing algorithms to retrieve events from that queue.","d58624ec-d67c-3316-83c2-54a32727e3f3":"During initialization, the TMALI CSC registers the tmaliTransferToQueueISR() interrupt hook with the DCI Driver so that it is invoked whenever the DCI interface reaches its configured frame limit in the ping-pong buffer or detects a data receipt timeout.","3d3c847c-86be-31b8-a857-0d109e53fa2d":"Upon initialization, the TMALI CSC installs the ISR hook tmaliTransferToQueueISR() into the DCI driver, and this hook is triggered when the DCI interface either reaches the configured frame limit in the ping-pong buffer or detects a data receipt timeout.","662b5d71-25bc-37bf-a61b-37b2c585d794":"If no data is in the TMALI queue, this routine blocks on a semaphore until the ISR signals that events are available. If data is already in the queue or the semaphore can be taken immediately, it counts the events in the TMALI queue and returns that count. The ‘TickstoWait’ parameter specifies in kernel ticks the maximum time the function will wait for data; if set to ‘FOREVER,’ it only returns when data becomes available. If a timeout occurs without data arriving, the function returns zero. If the TMALI task has not been initialized, the function returns an error.","f7723ed1-c1e3-32e4-80c5-68be98104d52":"This function may be invoked by any CSC to log an error or event for DPU housekeeping. If it’s called from an interrupt context, it sets a static global flag, ccmISRError, so the error can be queued later in ccmCtrlTask(), because the error/event queue uses a semaphore that cannot be taken in an ISR. The semaphore is configured with priority-inversion handling to minimize conflicts when multiple callers compete. This function also consolidates repeated errors by issuing a special repeat error code immediately after the original error code when the same error has occurred more than once in the last high-rate reporting period.","4cefbc60-9714-3794-821a-983469298eab":"The Telescope Module Access Library and Interface CSC comprises a ring‐buffer queue called TMALI_EVENT_QUEUE that holds detector events received from the DCI Driver’s data capture interface until the DPA CSC retrieves them; an API with tmaliNextEvent() and tmaliWait() functions to enable the DPA CSC to pull events from that queue; a group of DPA‐CSC‐used functions for configuring the DCI interface—tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet() and tmaliDataTimeoutGet(); a housekeeping API, tmaliHkGet(), to collect CSC housekeeping data for the Command and Control Task; the tmaliTask() thread together with the tmaliTransferToQueueISR() interrupt service routine, which use a semaphore to coordinate moving data from the DCI into the queue; and an error‐handling ISR, tmaliDciErrorReportedISR(), hooked into the DCI Driver to track the number of driver‐reported errors.","4f6fb9a6-44f5-325e-8080-636c41718181":"The DPU receives commands through two interfaces—MIL-STD-1553 from the spacecraft and SSI from the ICU—and any DPU command may originate from either the SCU or the ICU. Commands can come from one of four sources: ICU (generated and sent by the ICU via SSI), SCU (generated and sent by the SCU via 1553), G-ICU (ground-generated and forwarded through the ICU/SSI), or G-SCU (ground-generated and forwarded through the SCU/1553).","69251ec5-bee9-31c3-94c5-4cda07e3e0b9":"When large blocks of memory need to be uploaded to the DPU, such as for a software patch or a full software upload, the standard memory upload process is used. A series of D_MEM_DAT_UPLD commands are sent to form a single logical upload, with CCSDS-style grouping flags allowing the DPU flight software to accept up to 65,535 bytes in one logical upload. Each command’s data is held in a temporary DRAM buffer until all sequence numbers have been received. When the final command arrives, the flight software confirms that every sequence number is present, validates the end-to-end upload checksum, and then writes the entire buffer to the target location specified in the first upload command.","9cdff20a-bb96-342f-936b-fe4c1e26249f":"The MIL-STD-1553 Command ISR calls this routine at 1 Hz upon Clock Message arrival to wake up the CCM Control Task, which blocks on a semaphore after finishing its processing.","285cd0e8-f807-32c5-868b-13dd993cd351":"This routine lets you specify the DCI data timeout in milliseconds.  At startup, the timeout is set from the parameter passed to tmaliTask.  You can set the timeout up to X seconds; if you request a larger value, it resets to the default of X milliseconds.","6f0e1349-8e23-381d-9656-bcfedb33d374":"The D_MEM_BLK_DNLD command retrieves the full contents of a file in the EEPROM filesystem by supplying only its block number, which is used to form the filename. To download data from any other location, the D_MEM_DAT_DNLD command is used. Downloads are performed in a deferred manner to minimize CPU usage. What represents a single “virtual” download on the ground is actually delivered as a sequence of packets whose payloads must be extracted and concatenated to reconstruct the original data.","28f2771e-b40f-3c2e-b13b-b47aca31bfe1":"On initialization, the TMALI CSC registers the tmaliTransferToQueueISR() interrupt hook with the DCI Driver, which is called whenever the DCI interface hits its configured frame limit in the ping-pong buffer or encounters a data-receive timeout.","cba4501b-afd7-3efb-a398-b140529b1ff0":"If the TMALI queue is empty, the function blocks on a semaphore until the ISR signals that events are available; if data is already queued or the semaphore is taken, it counts and returns the number of events. The TickstoWait parameter specifies the maximum wait time in kernel ticks or can be set to FOREVER to wait indefinitely until data arrives. If the timeout expires with no data, the function returns zero. If the TMALI task has not been initialized, it returns an error.","06c8b0f2-2c73-38a8-8f44-09041839c809":"The S_ccm_ERR_REPEAT code stores the number of times the last error was repeated in its low‐order byte. Whenever a new error is reported, ccmErrEnq() enqueues a S_ccm_ERR_REPEAT entry for any error that had been repeated, in addition to the new error itself. To ensure each original error code and its repeat count are sent in the same packet, ccmMkHkErr() inserts a special S_ccm_ERRQ_FLUSH code, which tells ccmErrEnq() to reset its tracking and include any accumulated repeat counts for a given error.","7cf578ce-6a0d-341d-a1f8-5ec45d9ecfd5":"In the ring buffer data structure, pIn points to the most recently filled slot and pOut points to the most recently emptied slot.","961d49ee-069c-33c4-a9a7-e10bfe6b31b4":"The DPU receives commands through two interfaces—MIL-STD-1553 from the spacecraft and SSI from the ICU—and any command may originate from either the SCU or the ICU, whether generated locally or relayed from the ground. Command sources include the ICU via SSI, the SCU via 1553, ground-generated commands sent through the ICU over SSI (G-ICU), and ground-generated commands sent through the SCU over 1553 (G-SCU).","5b08dde6-f7a9-3837-a419-393fc4a10be3":"In the ring buffer data structure, pIn refers to the most recently filled position, and pOut refers to the most recently emptied position.","7be33dd4-f6b4-31fd-9586-81606064efe7":"To prevent error counts from rolling over, ccmErrEnq() ensures that no error count exceeds 250 in any single high-rate housekeeping reporting period; if an error count does exceed 250, ccmErrEnq() enqueues the S_ccm_ERR_REPEAT error with the current count and resets its error tracking.","ec7cf292-9875-3dec-a85d-6940a7a9172c":"The Command and Control CSC is brought up by having the operating system’s startup task, usrRoot(), spawn the CCM Control Task (ccmCtrlTask()). Once spawned, ccmCtrlTask() invokes ccmInit(), which sets up the error/event queue, creates necessary semaphores, and installs the required ISRs. After that, it launches the rest of the tasks that make up the DPU flight software. Upon startup, the CCM Control Task retrieves DPU configuration defaults from the SYSTEM_CONFIG_AREA in EEPROM, falling back to built-in defaults if the EEPROM checksum is invalid. It then initializes each remaining CSC either by calling its initialization routine or, for those with dedicated tasks, by spawning them with VxWorks®’ taskSpawn(), supplying the EEPROM-read defaults as parameters. In addition, ccmInit() calls ccmCmdLengthInit() to build the command length verification table used by the command processor for validating incoming command sizes.","3f07605a-3475-3af2-a5e9-bd3f86b56cee":"The TMALI CSC provides a ring‐buffer queue called TMALI_EVENT_QUEUE to hold detector events received from the DCI Driver until the DPA CSC retrieves them. It offers two retrieval functions, tmaliNextEvent() and tmaliWait(), for the DPA CSC to pull events from the queue. It also supplies a set of configuration APIs for the DCI interface—tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet(), and tmaliDataTimeoutGet()—and a housekeeping API, tmaliHkGet(), to collect CSC health data when requested by the Command and Control Task. Data moves from the DCI into the queue under the coordination of tmaliTask() and the tmaliTransferToQueueISR(), which synchronize via a semaphore. An error‐handling ISR, tmaliDciErrorReportedISR(), is hooked into the DCI Driver to track the number of errors reported.","d41f642f-e09e-30d9-b108-539149fc492e":"The DPU receives commands through two interfaces—MIL-STD-1553 from the spacecraft and SSI from the ICU—and any command may originate from either the spacecraft command unit or the instrument control unit. Command sources include the ICU (generated by the ICU and sent via SSI), the SCU (generated by the spacecraft and sent via 1553), G-ICU (ground-generated and sent through the ICU/SSI), and G-SCU (ground-generated and sent through the SCU/1553).","f3fddda1-3520-3ec2-9e6e-41c9753ca5f5":"During initialization the TMALI CSC installs an ISR hook routine named tmaliTransferToQueueISR() into the DCI Driver, which is invoked when the DCI interface either reaches the programmed frame limit in its ping-pong buffer or detects a data receipt timeout.","585dfbc2-30a4-37fb-9116-efe4efce2f3d":"The TMALI CSC gathers housekeeping data that can be obtained by calling tmaliHkGet(), which returns the data in a TMALI_HK structure.","cc9454ef-0f5d-3eec-8ab5-0dd8faf86329":"Global Data comprises the global data items accessed by this CSC.","a1a05137-907f-3234-83ef-d19f7cbabee0":"The DPU-CCM CSC provides a unified error-reporting interface, ccmErrEnq(), that other FSW tasks call to log errors. Each time ccmTask() wakes up, it checks whether it should build an error/event packet for ground transmission, and if so, invokes ccmHkMkError() to create the packet and forward it to DPU-SCUI for downlink.","45dbc082-65e0-3758-ac9c-ec46d159ae10":"The S_ccm_ERR_REPEAT code stores the count of the most recent repeated error in its low-order byte. Whenever a new error is reported, ccmErrEnq() enqueues a S_ccm_ERR_REPEAT entry for any error that had been repeated, along with the new error itself. To keep each original error code and its repeat count together in the same packet, ccmMkHkErr() enqueues a special S_ccm_ERRQ_FLUSH code to signal ccmErrEnq() to clear its tracking and enqueue any pending repeated-error counts.","94716b76-6c8b-3431-952c-5e5c5de4c10b":"The TMALI CSC acts as an intermediary for EVENT data from the DCI Driver CSC before delivering it to the DPA CSC. It waits for the DCI CSC to signal that the Ping-Pong buffer has hit its frame limit or timed out, indicating the EVENT data is ready. TMALI then reads all the EVENT data, informs the DCI it may swap the Ping-Pong buffers, and posts a semaphore to unblock the tmaliWait() call from the DPA.","a46e4abe-4ab7-31e4-9e33-afcbe4614936":"Control and Monitoring: the DPU generates eight distinct types of housekeeping packets.","aea5eff3-fa99-3c9d-956b-b3b88277d15c":"Upon operating system startup, usrRoot() spawns the CCM Control Task (ccmCtrlTask()), which then calls ccmInit() to create the error/event queue, set up required semaphores and install interrupt service routines, and finally launches the remaining DPU flight software tasks. Once running, the CCM Control Task reads configuration defaults from the SYSTEM_CONFIG_AREA in EEPROM, reverting to built-in defaults if the checksum is invalid. It then initializes each remaining CSC either by invoking its initialization function or, for those with dedicated tasks, by spawning them via the VxWorks taskSpawn() call, passing the EEPROM-loaded defaults as arguments. In addition to organizing task startup, ccmInit() invokes ccmCmdLengthInit() to build the command length verification table used by the command processor to validate incoming command lengths.","c71421cd-4379-310c-bd29-8883d2fc869a":"Data can be uploaded to the DPU in two ways: the D_MEM_DAT_POKE command for inserting small chunks of up to Z bytes into DPU memory, and the D_MEM_DAT_UPLD command for regular memory uploads. The Z-byte limit for the poke operation is due to Company X’s command length restriction.","91c7dd15-734b-3b72-8139-25084df788a5":"The CSC uses a ring‐buffer FIFO to temporarily hold data received from the DCI until it’s processed. Two pointers, pIn and pOut, track where data enters and leaves the buffer, and they’re arranged so that checking for an empty buffer requires only a single comparison, making reads as simple as possible. Since the buffer stores only Events (each four bytes), the pointers refer to these four‐byte units, and because the DCI reports all sizes in bytes, any necessary size conversions are done before reading the data.","aa14c948-22f4-3808-8cbd-e1746474afb3":"The CCM Control Task also processes memory dump commands. When a dump request arrives, it divides the data into smaller chunks and outputs one chunk each time it is activated. This deferred approach prevents a large dump from monopolizing CPU time or tying up the high-priority CCM Command Dispatch Task for an extended period.","a98d05f0-94b8-3ed9-95f7-3f6754a8133b":"The D_MEM_BLK_DNLD command downloads data from a file in the EEPROM filesystem by specifying only the block number, causing the full contents of the file named after that block to be retrieved. For downloading data from locations outside the EEPROM filesystem, the D_MEM_DAT_DNLD command is used. To minimize CPU usage, downloads are handled in a deferred manner. A single “virtual” download arrives as a series of packets whose payloads must be extracted and concatenated in order to reconstruct the original data.","f4fd0784-28c4-3aed-ab43-00450a6c5a64":"In the ring buffer, a dedicated pointer pEnd marks the last slot. Whenever either pointer is advanced, check if it equals pEnd; if it does, reset it to the buffer start (pBuf), otherwise simply increment it.","0a7a30e6-a197-39b2-91d2-858be8857fb0":"The DCI’s hardware windowing feature is enabled and configured via tmaliDciWindowSet(), which activates the function and sends the specified window parameters to the DCI driver.","42eb5731-5c84-32a3-8083-802e466a223d":"The ccmErrEnq() function keeps track of the most recently reported error and how many times it occurs in succession. When an error code is first reported, it becomes the “previous” error and its repeat count starts at one. Each time the same code appears consecutively, that count is incremented. If the same error is reported more than once during a single high‐rate housekeeping interval, ccmErrEnq() queues a single special error, S_ccm_ERR_REPEAT, with the repeat count stored in its least significant byte. This prevents the housekeeping telemetry from being overwhelmed by repeated instances of the same error.","35648906-88dd-37b6-b898-9ace097dcebe":"The hardware windowing feature of the DCI is enabled and configured via tmaliDciWindowSet(), which activates it and submits the specified window parameters to the DCI driver.","5ab728f2-bf00-360b-80cb-ba4feeebb66f":"During normal operation frames arrive about every 11 ms. The DCI hardware issues an interrupt when event data has been placed into a Ping-Pong buffer and no further events occur within a configurable timeout period. This data timeout interrupt is not an error but usually signals that the current exposure has finished. It lets the TMALI CSC retrieve the trailing events from the DCI Ping-Pong buffer. The tmaliDciTimeoutSet() function provides an API for the DCI driver to adjust this timeout.","78919754-9dba-38c5-b5ba-a65b2059127b":"The DPU-CCM CSC provides a centralized error‐reporting interface called ccmErrEnq() that other FSW tasks use to report errors. Each time ccmTask() wakes up, it checks whether it’s time to assemble an error/event packet for transmission to the ground, and if so, calls ccmHkMkError() to build the packet and forward it to DPU-SCUI for sending.","34b335d5-7b5f-3009-aef3-6900fff6200d":"This function may be called by any CSC to log an error or event for inclusion in DPU housekeeping. If invoked from an interrupt context, it sets a static global variable, ccmISRError, so the error is enqueued later in ccmCtrlTask(), because the error/event queue is semaphore‐protected and semaphores cannot be acquired in an ISR. The queue’s semaphore uses priority inversion handling to minimize conflicts when multiple callers contend. The function also collapses repeated errors by issuing a special repeat error code after the original error code whenever the same error has occurred more than once during the last high-rate reporting period."}