{"6306ea9a-5e36-3db6-9888-08f5f65849a5":"Data can be uploaded to various locations, including DRAM, EEPROM, hardware registers, and the EEPROM filesystem. The D_MEM_DAT_UPLD command designates the target location. If the target location is the EEPROM filesystem, a \"block number\" is provided instead of a memory address. The DPU FSW uses this block number to generate a filename in the format eefs1:DPU_blk.##, where ## represents the block number. Once all the data is uploaded and received by the DPU FSW, it writes the data to the corresponding file in the EEPROM filesystem. If a file with the same name already exists, it will be overwritten. The EEPROM filesystem can be reinitialized using the D_MEM_DISK_INIT command.","35c05af7-4ad3-3aff-9fef-1ca76b881940":"The global data elements that this CSC interacts with.","aee05ebe-70d6-3fa6-bf04-908fed5ee77b":"Command Handling: Commands are removed from the Command Queue and executed by the Command Dispatch Task, ccmCmdTask(). This task waits on a semaphore provided by ccmCmdEnq(). When the semaphore is triggered, ccmCmdTask() wakes up and calls ccmCmdProcess() to handle pending commands. ccmCmdProcess() retrieves commands from the Command Queue and passes them to ccmCmdDispatch(), which ensures the command length is correct and executes it. If command echoing is enabled, ccmCmdDispatch() invokes ccmHkMkCmdEcho() to echo the command back to the ground without validation. Counts for both accepted and rejected commands are tracked. Commands sent to ccmCmdEnq() that are either 1 Hz Clock Time messages or spacecraft Attitude messages bypass the Command Queue and are executed immediately in interrupt context. Attitude messages are sent to dpaCommandSend(), while 1 Hz Clock Time messages have their parameters passed to tisTimeSync() for time synchronization. Any other non-DPU or non-spacecraft messages are quietly discarded without reporting errors. To ensure ccmCmdTask() periodically checks in with the CCM Control Task when no ground commands are received, the semaphore has a 20-second timeout. If the timeout occurs, the task ensures the Command Queue is empty, then reports to the CCM Control Task through ccmTaskReport().","277f0370-f6a2-3ae9-a75e-2683d446a347":"The DPU generates eight varieties of housekeeping packets.","b05d66ed-652d-3c73-8ee7-881ee2f59cee":"The function retrieves housekeeping data for the TMALI CSC, including certain DCI parameters, and resets TMALI's internal counters to zero. If the provided pointer to a TMALI_HK structure is NULL, no data is returned, but the internal counters are still reset. Two of the four error counters are updated within an ISR context, requiring a task-switch-safe implementation. In VxWorks, this could use a counting semaphore, but the TMALI CSC design employs a faster approach with a free-running error counter and careful updating of the reported error count using a temporary variable. Since the increment and assignment of 32-bit unsigned integers are atomic operations, the counters are task-safe, ensuring no error events are missed. Thus, the total errors reported by tmaliHkGet() match the actual errors that occurred, with no loss of error data during internal updates.","46a47c92-0a83-34be-b468-1143774393e2":"Determining Frame Depth in DCI: Benchmark testing will establish the optimal frame depth. The default frame depth is set to 10 frames, and based on the provided data, reading 10 maximum-sized frames at the highest data transfer rate will take about 24 milliseconds.","f0cc222b-4d06-3f55-a85f-77b8cc1b5e0e":"Command Handling: Commands are removed from the Command Queue and executed by the Command Dispatch Task, ccmCmdTask(). This task waits on a semaphore triggered by ccmCmdEnq(). When the semaphore is triggered, ccmCmdTask() wakes up and calls ccmCmdProcess() to handle pending commands. ccmCmdProcess() retrieves commands from the Command Queue and passes them to ccmCmdDispatch(), which ensures the command length is correct and executes it. If command echoing is enabled, ccmCmdDispatch() invokes ccmHkMkCmdEcho() to echo the command back to the ground without validation. Counts for both accepted and rejected commands are tracked. If a command sent to ccmCmdEnq() is either a 1 Hz Clock Time message or an Attitude message from the spacecraft, it bypasses the Command Queue and is executed immediately within the interrupt context. Attitude messages are sent to dpaCommandSend(), while the 1 Hz Clock Time message parameters are passed to tisTimeSync() to update the current time. Any other unrelated messages from the DPU or spacecraft are discarded without error reporting. To ensure periodic updates from ccmCmdTask() to the CCM Control Task in the absence of ground commands, the semaphore is set with a 20-second timeout. If the timeout occurs, the task confirms the absence of commands in the Command Queue and reports to the CCM Control Task by invoking ccmTaskReport().","b3d600d2-cf3e-35e7-ba9d-73e1b90b302a":"Data can be uploaded to various locations, including DRAM, EEPROM, hardware registers, and the EEPROM filesystem. The D_MEM_DAT_UPLD command designates the target location. If the destination is the EEPROM filesystem, a \"block number\" is provided instead of a memory address. The DPU FSW uses this block number to create a filename in the format eefs1:DPU_blk.##, where ## represents the block number. After receiving all the uploaded data, the DPU FSW writes it to the specified file in the EEPROM filesystem, overwriting any existing file with the same name. The EEPROM filesystem can be reinitialized using the D_MEM_DISK_INIT command.","1ca8a9c9-d97c-38e2-8e1a-72241ec0228b":"The hardware windowing feature of the DCI can be enabled and managed using tmaliDciWindowSet(), which activates the hardware windowing functionality and sends the defined window parameters to the DCI driver.","1d34025f-a3fb-3da6-a26f-4725c52ac084":"Command Handling: Commands are removed from the Command Queue and executed by the Command Dispatch Task, ccmCmdTask(). This task waits on a semaphore triggered by ccmCmdEnq(). When the semaphore is triggered, ccmCmdTask() wakes up and calls ccmCmdProcess() to handle pending commands. ccmCmdProcess() retrieves commands from the Command Queue and passes them to ccmCmdDispatch(), which ensures the command length is correct and executes it. If command echoing is enabled, ccmCmdDispatch() invokes ccmHkMkCmdEcho() to echo the command back to the ground without validation. Counts for both accepted and rejected commands are tracked. If a command sent to ccmCmdEnq() is either a 1 Hz Clock Time message or an Attitude message from the spacecraft, it bypasses the Command Queue and is executed immediately within the interrupt context. Attitude messages are sent to dpaCommandSend(), while the 1 Hz Clock Time message parameters are passed to tisTimeSync() to update the current time. Any other unrelated messages not meant for the DPU or the spacecraft observatory are discarded silently without error reporting. To ensure the ccmCmdTask() task regularly communicates with the CCM Control Task in the absence of ground commands, the semaphore includes a 20-second timeout. If the semaphore times out, the task verifies that no commands are waiting in the Command Queue and reports its status to the CCM Control Task by calling ccmTaskReport().","d2a9c9b3-60a4-33ea-8be0-b9c583f74036":"This function allows setting the data timeout for the DCI, specified in milliseconds. The initial timeout value is determined by the parameter provided during the startup of the tmaliTask. The maximum allowable timeout is X seconds; if a value exceeding this limit is requested, the timeout will be set to the default value of X milliseconds.","7798b768-904b-396f-bc02-a6ee2e167bdf":"If an upload requires more than 65,535 bytes, the file must be divided into smaller files, each no larger than 65,535 bytes, and sent sequentially. The DPU FSW can process individual upload commands even if they are received out of order due to sequence numbers. There is no time constraint for completing a single virtual upload, allowing long uploads to span multiple ground contacts. During an ongoing upload, the last sequence number can be requested from the DPU FSW, which will identify any missing sequence numbers via event S_ccm_MISSING_SEQNO. If an ongoing upload needs to be terminated, it can be canceled by sending the D_MEM_DAT_CNCL command.","5bd67670-29bd-3756-928e-ba01196ad5f0":"After all events in the Ping-Pong buffer have been fully transferred to the TMALI_EVENT_QUEUE, the tamliTask() function must reset the hardware to prepare for the next Ping-Pong buffer swap when ready. If TMALI fails to transfer data from the ping buffer before the pong buffer becomes full, the DCI Driver will trigger an error interrupt, calling the tmaliDciErrorReportedISR(). This ISR will set an error flag to allow the tamliTask() to recover and will also signal the semDciWait semaphore to wake up the tamliTask(), even if it may already be active, as the error could occur right after data transfer is completed. The error will be logged in TMALI_HK. The DCI hardware will discard events until the tamliTask() finalizes the ongoing transfer, detects the error flag, manually initiates a Ping-Pong buffer swap, and reactivates data acquisition. This ensures the Ping-Pong buffer only holds complete frames for processing. Under normal conditions, this error should not occur, as the TMALI task is expected to process data from the Ping-Pong buffer quickly enough. If events cannot be processed fast enough, the issue would typically result in a TMALI queue full condition, reported as an S_TMALI_QUEUE_FULL error via the ccmErrEnq() mechanism.","0c11996b-fb22-3be5-96a2-18b6f06945d3":"If an upload requires more than 65,535 bytes, the file must be divided into smaller files, each no larger than 65,535 bytes, and sent sequentially. The DPU FSW can process individual upload commands even if they are received out of order due to sequence numbers. There is no time restriction for completing a single upload, allowing long uploads to extend across multiple ground contacts. During an ongoing upload, the last sequence number can be requested from the DPU FSW, which will identify any missing sequence numbers via event S_ccm_MISSING_SEQNO. If an ongoing upload needs to be terminated, it can be canceled by sending the D_MEM_DAT_CNCL command.","417ed1bc-9a98-352d-acbe-4d904941bfe1":"The CCM Control Task is responsible for processing memory dump commands. When a data dump is requested, the task divides the dump into smaller, manageable portions and processes each piece incrementally whenever it is activated. This deferred processing approach ensures that large dumps do not monopolize CPU resources and allows the high-priority CCM Command Dispatch Task to remain responsive.","6adfb5cd-a367-38c7-8bea-79d1726faac7":"This function allows setting the data timeout for the DCI, specified in milliseconds. The initial timeout value is determined by the parameter provided during the startup of the tmaliTask. The maximum allowable timeout is X seconds; if a value exceeding this limit is requested, the timeout will be set to the default value of X milliseconds.","975b1774-03bf-336c-ae7e-ffff46169a9d":"The TMALI CSC acts as an intermediary for managing EVENT data, which is provided by the DCI Driver CSC and eventually sent to the DPA CSC. TMALI waits for a signal from the DCI CSC indicating that a frame limit or data timeout has been reached in the Ping-Pong buffer, signifying the EVENT data is ready for processing. TMALI retrieves all EVENT data from the DCI and informs the DCI that it can swap the Ping-Pong buffers when ready. TMALI then releases a semaphore to unblock the tmaliWait() call for the DPA.","1668125c-e5cf-3214-9a19-ff08fc6a3b2c":"The DCI control/status register's bit arrangement can be configured using the tmaliBitArrangementSet() function.","2888db66-3ffd-3485-8be8-8076a586865f":"The Command and Control (CCM) CSC, a Level 2 reusable component derived from the INSTRUMENT Y project, consists of the following elements:  \n- A Control Task, ccmCtrlTask(), responsible for initializing the DPU flight software (FSW), creating tasks during system boot, managing the generation of housekeeping data packets from the DPU, supervising task execution, and scheduling periodic tasks such as the heartbeat message and watchdog strobe.  \n- A Command Dispatch Task, ccmCmdTask(), that handles the reception and processing of real-time commands from the SCU or ICU.\n\nKey data structures include:  \n- A Static Data table that records the operational state, containing housekeeping production rates, specific CCM flags, and the count of executed commands.  \n- A Command Queue to store incoming commands, which are received via interrupt from either the ICU or SCU.  \n- An Error/Event Queue that gathers error and event codes generated by the DPU FSW. These codes are later retrieved, included in telemetry packets at defined intervals, and incorporated into DPU housekeeping data.","768cf777-831a-396b-9e3b-bb5bbb33eb6f":"The D_MEM_BLK_DNLD command facilitates downloading data from a file stored in the EEPROM filesystem. Similar to the upload command, only the block number is required, and the file corresponding to that block number will be entirely downloaded. For downloading data from sources outside the EEPROM filesystem, the D_MEM_DAT_DNLD command is used. As previously mentioned, downloads are processed in a deferred manner to minimize CPU usage. A single download operation will appear on the ground as multiple download packets, which must be extracted and combined to reconstruct the original data sequence.","16a7704a-c956-39ff-8892-04bd43b8537b":"Each DPU FSW task calls this function to indicate its execution, enabling ccmCtrlTask() to evaluate the health of the DPU FSW operation.","0b4fdce4-7b8d-3d19-a419-465409ed34ca":"The Telescope Module Access Library and Interface (TMALI) CSC handles the management of the detector event queue and offers an API for data processing algorithms to retrieve detector events from the queue.","28868435-794f-3114-b1ec-087d07f42f87":"Each DPU FSW task calls this function to indicate its execution, enabling ccmCtrlTask() to evaluate the health of the DPU FSW operation.","a56431fb-e16d-3fbe-9fa7-9b728a5d9301":"For larger memory uploads to the DPU, such as software patches or complete software uploads, the standard memory upload process is utilized. This process involves sending multiple D_MEM_DAT_UPLD commands, collectively forming a single \"virtual\" upload. CCSDS-like sequence flags are used to enable the DPU firmware to handle a maximum of 65535 bytes in one \"virtual\" upload. Data from each D_MEM_DAT_UPLD command is stored in a temporary DRAM buffer until all sequence numbers for the entire upload are received. Once the final command in the sequence is received, the DPU firmware verifies the reception of all sequence numbers, checks the end-to-end upload checksum, and then writes the entire temporary buffer to the target location specified in the initial upload command.","034821fa-e846-3d5f-a712-2cab3aab6cc4":"Events are retrieved from the TMALI_EVENT_QUEUE by the DPA CSC through an API with two functions: tmaliWait() and tmaliNextEvent(). To ensure efficiency, the following points apply:\n* The DPA CSC will integrate the tmaliNextEvent() function directly into its code to eliminate the overhead of a function call for each event,\n* The DPA CSC will store each retrieved event in a register and complete its processing while the event remains in the register before fetching the next event, and\n* Error checking is omitted in the tmaliNextEvent() function for performance optimization, so the DPA CSC must track the number of events retrieved against the count provided by tmaliWait().","bcaee947-f60d-3f12-9aab-b7e9b783e9ea":"This function is invoked by the MIL-STD-1553 Command ISR and the SSI Interface ISR whenever a command is received from the SCU or ICU, to add the command to the queue and activate the CCM Command Dispatch Task for execution.","caf39fb3-5550-3e2d-9d7b-0a369f1b0948":"The bit configuration of the DCI control/status register can be configured using tmaliBitArrangementSet().","95fb044f-2046-38f0-b241-fe9fa977900b":"Determining the optimal frame depth in DCI will be based on benchmark testing. The default frame depth is set to 10 frames. Based on this, reading 10 maximum-sized frames at the highest data transfer rate will take approximately 24 milliseconds.","6181127f-57bb-3d6c-a693-895ee3b0d075":"The DPU-CCM CSC includes a centralized error reporting function, ccmErrEnq(), which other FSW tasks utilize to log errors. On wake-up, ccmTask() verifies whether it is time to generate an error/event packet for ground transmission. If necessary, ccmTask() invokes ccmHkMkError() to create the packet and send it to DPU-SCUI for transmission to the ground.","f2635035-8f10-32de-92f0-2695c9288a4a":"The CSC uses a FIFO ring buffer to temporarily hold data from the DCI before processing. The ring buffer employs two pointers, pIn and pOut, to track the stored data. These pointers are designed such that checking if the buffer is empty requires only a single comparison, making reading from the buffer straightforward. Since the buffer exclusively stores Events, which are four-byte entities, the pointers reference these entities. As all DCI data is in bytes, size conversions are necessary before reading.","98f777a5-8d50-3772-a55b-abd45958b813":"The TMALI CSC acts as an intermediary for managing EVENT data, receiving it from the DCI Driver CSC and forwarding it to the DPA CSC. The TMALI CSC waits for the DCI CSC to indicate that a frame limit or data timeout has been reached in the Ping-Pong buffer, signaling that the EVENT data is ready to be processed by TMALI. TMALI retrieves all EVENT data from the DCI and informs the DCI that it can switch Ping-Pong buffers when ready. TMALI then provides a semaphore to release the tmaliWait() call in the DPA.","31310305-81b9-3860-b8d7-087a5e789bd6":"This function allows retrieval of the current data timeout value utilized by the DCI. The returned value represents the timeout duration in milliseconds, as described in document 036911400, section 4.3.2.4.1.3.","aaf7e356-ab47-30aa-961f-d572d4844469":"The global data elements that this CSC interacts with.","7a992a5c-644e-38f2-bece-ed0322d17445":"Data Upload and Download Management: Data can be uploaded to the DPU through two methods:  \n* Using the Memory Poke command (D_MEM_DAT_POKE), or  \n* Using the Memory Upload command (D_MEM_DAT_UPLD).  \nThe Memory Poke command is intended for inserting a small amount of data (up to Z bytes) into a specific DPU memory location. The Z-byte limit is determined by the command length restriction set by Company X.","b35d2bcd-847d-397a-92ad-b8714eac445f":"The CCM Control Task is responsible for initializing the DPU Flight Software (FSW) and ensuring a successful boot. It achieves this by spawning the SCU Interface Task and the CCM Command Task, then waiting on temporary semaphores, each with a 5-second timeout. If both tasks signal successful initialization by releasing their semaphores, the CCM Control Task updates the BC_INDEX parameter in EEPROM to indicate success. If either task fails to initialize successfully, the CCM Control Task halts the watchdog strobe, triggering a DPU reboot. This definition of a successful boot is based on the necessity of these tasks to establish ground communication and provide command capability. After initialization, the CCM Control Task waits on a binary semaphore, signaled by the SCUI Command ISR upon receiving the 1 Hz Clock Message. If no Clock Message arrives, the semaphore times out after 1.5 seconds. The CCM Control Task continues running to transmit DPU housekeeping at set intervals, handle periodic operations, and execute memory dump commands. Additionally, it performs a final call to ccmErrEnq() so that if an error occurs in an interrupt service routine, the errno value is stored in a global variable and enqueued into the Error/Event Queue during the task’s standard processing.","426b5ffc-f36a-383f-a8f0-d419a106007b":"The DPA CSC invokes tmaliWait() to check the number of EVENTs available to be read. If tmaliWait() returns a value greater than zero, the DPA uses tmaliNextEvent() to retrieve each available EVENT.","5c0f562d-28e5-327c-9721-b08cf6ecc5d3":"This function retrieves the frame depth of the Ping-Pong buffers utilized by the DCI CSC. The frame depth specifies the number of frames loaded into the selected Ping-Pong buffer before triggering an interrupt. The initial frame depth value is set based on the parameter provided during the startup of the tmaliTask. The function returns the currently active frame depth value, which may differ from the previously commanded value, as the commanded value only takes effect when data is moved from the hardware Ping-Pong buffer to the TMALI queue in response to a frame interrupt or timeout, as described in section 5.13.2.3.","3c62a5be-6021-3217-bbf6-e225d1e89e3b":"The CCM Control task calls the ccmPerProcess() function during each execution to manage periodic processing tasks, which include updates for analog-to-digital conversion, monitoring DPU tasks, generating ICU heartbeat messages, and stroking the watchdog. The ccmPerProcess() function invokes ccmHealthChk() to monitor the time elapsed since other tasks last reported, ensuring proper execution. Other tasks confirm their activity by calling the ccmTaskReport() function and providing their task index. Each task has a defined execution frequency, and if a task fails to execute as expected, an error is logged in the DPU housekeeping data. If the Command Dispatch Task does not report for an extended duration, the DPU will perform a reboot as this task is critical for receiving commands. Otherwise, the watchdog will be stroked.","0b4bb7d4-ab4a-3536-807b-cdeb5579a6bd":"This function configures the frame depth of the Ping-Pong buffers used by the DCI CSC, determining how many frames are loaded into the selected buffer before triggering an interrupt. The initial frame depth is set based on the parameter provided when initiating the tmaliTask. The maximum allowable frame depth is 64 frames, and any attempt to set a higher value will result in the timeout being reset to the default value of V frames. The adjustment to the frame depth may experience a slight delay if the DCI bus is active and is typically made when the DCI has just reported either a frame level reached or a timeout condition, reducing the likelihood of altering the value during a critical frame detection event. Changing the frame depth while the DCI CSC is still processing data could lead to unpredictable behavior. If a new 'tmaliDciFrameDepthSet' command is issued before the previous one is applied, the new request will overwrite the prior one, and the DCI will be updated with the new value at the earliest available opportunity.","3bffeba3-2c78-3628-ab1e-e8ad0e595c1d":"The function retrieves housekeeping data for the TMALI CSC, including certain DCI parameters, and resets TMALI's internal counters to zero. If the provided pointer to a TMALI_HK structure is NULL, no data is returned, but the internal counters are still reset. Two of the four error counters are updated within an ISR context, requiring a task-switch-safe implementation. In VxWorks, this could use a counting semaphore, but the TMALI CSC design employs a faster approach with a free-running error counter and careful updating of the reported error count using a temporary variable. Since the increment and assignment of 32-bit unsigned integers are atomic operations, the counters are task-safe, ensuring no error events are missed. Thus, the total errors reported by the tmaliHkGet() function accurately reflect all errors that occurred without loss due to structure updates.","47c13b41-538f-356c-a7de-59ca84d0b120":"When a command is received from the SCU through the 1553 interface or from the ICU through the SSI interface, the corresponding ISR will add the command packet to a Command Queue and signal a semaphore to wake up the ccmCmdTask(). Since the DPU can issue commands to itself, commands may be received in either interrupt context or task context. To handle this, the CCM utilizes two separate queues: one for interrupt context that does not use semaphore protection and another for task context that is semaphore protected.","27da15c7-49e5-3552-b1bd-24108986cbc1":"This function is invoked by the MIL-STD-1553 Command ISR and the SSI Interface ISR whenever a command is received from the SCU or ICU, to add the command to the queue and activate the CCM Command Dispatch Task for execution.","b6952139-6807-33af-96a9-132935531439":"The initialization of the TMALI CSC involves creating the tmaliTask() using the default startup parameters. This task is responsible for allocating memory for the TMALI_EVENT_QUEUE, setting up DCI ISRs, initializing static variables and data structures, and then entering an infinite loop where it manages data transfer from the DCI to the TMALI queue, controlled by the semaphore semDciWait.","a4ab6f19-21a3-3628-aae7-c94df16a968c":"The Command and Control CSC is initialized by creating the CCM Control Task, ccmCtrlTask(), from the operating system's startup task, usrRoot(). Once created, the task executes ccmInit(), which sets up the error/event queue, creates necessary semaphores, and sets up various ISRs. It then launches the other tasks that make up the DPU flight software. Upon starting, the CCM Control Task retrieves default startup configurations for the DPU from the SYSTEM_CONFIG_AREA in EEPROM. If the checksum in the SYSTEM_CONFIG_AREA is invalid, hardcoded defaults are used. The CCM Control Task initializes the other CSCs by either calling their initialization functions or spawning their associated tasks using the VxWorks® function, taskSpawn(), passing the startup defaults as parameters. Additionally, ccmInit() sets up the command length verification table by executing ccmCmdLengthInit(), which the command processor utilizes to validate the lengths of newly received commands.","538575b2-0798-3439-bfdf-f36375d23a83":"The initialization of the TMALI CSC involves creating the tmaliTask() with the default startup parameters. This task is responsible for allocating memory for the TMALI_EVENT_QUEUE, setting up DCI ISRs, initializing static variables and data structures, and then entering an infinite loop where it manages data transfer from the DCI to the TMALI queue, controlled by the semaphore semDciWait.","45df9dde-c99f-350d-a122-05fe7505d99d":"This function allows configuring the bit arrangement used by the DCI. When bSpecialArrangement is set to TRUE, the DCI operates in special bit arrangement mode; otherwise, it defaults to normal mode with no rearrangement.","94ed76a0-77c2-3757-bea5-779e473c08aa":"The CCM Control task calls the ccmPerProcess() function during each execution to perform periodic processing tasks, which include updating analog to digital conversions, monitoring DPU tasks, generating ICU heartbeat messages, and strobing the watchdog. The ccmPerProcess() function invokes ccmHealthChk() to check the execution of other tasks by tracking the elapsed time since each task last reported. Other tasks report their execution status to the CCM Control Task by using the ccmTaskReport() function and providing their task index. Each task has a predefined execution frequency, and if a task fails to execute as expected, an error is logged in the DPU housekeeping. If the Command Dispatch Task does not report for an extended duration, the DPU will initiate a reboot because the DPU cannot be commanded without this task. Otherwise, the DPU will strobe the watchdog.","c15544ec-0a76-3779-8098-5095d8b1a935":"The ccmErrEnq() function monitors the most recently reported error and tracks how often it occurs. After an error code is reported, it is recorded as the last reported error by ccmErrEnq(), and a repetition counter is incremented for each subsequent consecutive occurrence of the same error. If this error code is reported multiple times within a single high-rate housekeeping reporting period, a special error, S_ccm_ERR_REPEAT, is queued with the repetition count included in the least significant byte. This approach minimizes the risk of housekeeping telemetry being overwhelmed by a single recurring error.","5233365f-9b83-3955-ba6b-6538d1f40a91":"The MIL-STD-1553 Command ISR invokes this routine at a 1 Hz rate (upon receiving the Clock Message) to signal the CCM Control Task, which remains blocked on a semaphore until its processing is finished.","135782dc-e228-3b2c-9534-6f645acae157":"This function allows configuring the bit arrangement used by the DCI. When bSpecialArrangement is set to TRUE, the DCI operates in special bit arrangement mode; otherwise, it defaults to normal mode with no rearrangement.","2a21cd73-14d9-37e7-bcb7-a8425e6a95b2":"This function retrieves the frame depth of the Ping-Pong buffers utilized by the DCI CSC. The frame depth specifies the number of frames loaded into the selected Ping-Pong buffer before triggering an interrupt. The initial frame depth value is set based on the parameter provided during the startup of the tmaliTask. The function returns the currently active frame depth value, which may differ from the previously commanded value, as the commanded value only takes effect when data is moved from the hardware Ping-Pong buffer to the TMALI queue in response to a frame interrupt or timeout, as described in section 5.13.2.3.","09b45c48-1774-3677-a22b-8637ceeb5f69":"The hardware windowing feature of the DCI can be enabled and managed using tmaliDciWindowSet(), which activates the hardware windowing functionality and sends the defined window parameters to the DCI driver.","979afca3-c229-34d2-b89c-3d0901eecbea":"The MIL-STD-1553 Command ISR invokes this routine at a 1 Hz rate (upon receiving the Clock Message) to signal the CCM Control Task, which remains blocked on a semaphore until its processing is finished.","9d071f3e-dd42-33c1-86ee-afa2e3812ba2":"After all events in the Ping-Pong buffer have been fully transferred to the TMALI_EVENT_QUEUE, the tamliTask() function must reset the hardware to prepare for swapping the Ping-Pong buffer when it becomes ready. If the transfer from the ping buffer is not completed before the pong buffer fills up, the DCI Driver will trigger an error interrupt, calling the tmaliDciErrorReportedISR(). This ISR will set an error flag to allow the tamaliTask() to recover and will also signal the semDciWait semaphore to wake up the tamaliTask(), even if it may already be active, as it’s possible the tamaliTask() had just finished transferring data when the error occurred. The error will also be recorded in TMALI_HK. Until the tamaliTask() finishes the ongoing transfer, detects the error flag, manually forces a Ping-Pong swap, and re-enables data acquisition, the DCI hardware will discard incoming events. This ensures that only complete frames are stored in the Ping-Pong buffer for processing. Under normal circumstances, this error should not occur as the tamaliTask() is generally fast enough to retrieve the data from the DCI Ping-Pong buffer. If events cannot be processed quickly enough, the issue will result in a TMALI queue full condition, which will be logged as an S_TMALI_QUEUE_FULL error using the ccmErrEnq() mechanism.","25827c10-2881-3b70-9724-65b4b4d6d11c":"The DPU processes commands received through two interfaces: the MIL-STD-1553 interface from the Spacecraft and the SSI interface from the ICU. Commands to the DPU can originate from either the SCU or the ICU. The possible sources of commands to the DPU are as follows:\n* ICU – the command is created and transmitted by the ICU via the SSI interface.\n* SCU – the command is created and transmitted by the SCU via the 1553 interface.\n* G-ICU – the command is created on the ground and sent to the DPU via the ICU/SSI interface.\n* G-SCU – the command is created on the ground and sent to the DPU via the SCU/1553 interface.","15da4c28-a24a-3049-8edf-8ac8575ea61a":"The D_MEM_BLK_DNLD command facilitates downloading data from a file stored in the EEPROM filesystem. Similar to the upload command, only the block number is required, and the file corresponding to that block number will be entirely downloaded. For downloading data from sources outside the EEPROM filesystem, the D_MEM_DAT_DNLD command is used. As previously mentioned, downloads are processed in a deferred manner to minimize CPU usage. A single download operation will appear on the ground as multiple download packets, which must be extracted and combined to reconstruct the original data sequence.","6485ce43-484d-38ea-a03e-0ba343c56744":"The ccmErrEnq() function monitors the most recently reported error and tracks how often it occurs. After an error code is reported, it is recorded as the last reported error by ccmErrEnq(), and a repetition counter is incremented for each subsequent consecutive occurrence of the same error. If this error code is reported multiple times within a single high-rate housekeeping reporting period, a special error, S_ccm_ERR_REPEAT, is queued with the repetition count included in the least significant byte. This approach helps prevent housekeeping telemetry from being overwhelmed by repeated instances of a single error.","2d98be0f-c7df-3dec-82a6-ade1a628100b":"The CCM Control Task is responsible for initializing the DPU FSW and ensuring a successful boot. It achieves this by waiting on temporary semaphores with a 5-second timeout after starting the SCU Interface Task and the CCM Command Task. If both tasks signal successful initialization by releasing their semaphores, the CCM Control Task updates the BC_INDEX parameter in EEPROM to confirm the successful boot. If either task fails to initialize successfully, the CCM Control Task disables the watchdog strobe to trigger a DPU reboot. These two tasks' successful initialization is considered essential for a successful boot because they are required to establish ground contact and enable commandability for the DPU FSW. Once the initialization is done, the CCM Control Task waits on a binary semaphore, which is released by the SCUI Command ISR upon receiving the 1 Hz Clock Message. If the Clock Message is not received, the semaphore times out after 1.5 seconds. The CCM Control Task continues running to generate and transmit DPU housekeeping data at scheduled intervals, execute various periodic tasks, and handle memory dump commands. Finally, a call to ccmErrEnq() ensures that if an error arises in an interrupt service routine, its associated errno value is stored in a global variable and added to the Error/Event Queue during the task’s regular processing.","14846b9d-d5bd-32d2-9f02-ee41e8a3797b":"Events are retrieved from the TMALI_EVENT_QUEUE by the DPA CSC through an API with two functions: tmaliWait() and tmaliNextEvent(). To ensure efficiency, the following points apply:\n- The DPA CSC will integrate the tmaliNextEvent() function directly into its code to eliminate the overhead of a function call for each event.\n- Each event will be stored in a register by the DPA CSC, which will complete processing the event while it remains in the register before fetching the next event.\n- The tmaliNextEvent() function does not include error checking to optimize performance, so the DPA CSC is responsible for tracking the number of events retrieved compared to the count provided by tmaliWait().","80150773-c06a-3d3f-9935-9d4bcca2bc9a":"The TMALI CSC gathers housekeeping data, which can be accessed through the function tmaliHkGet(). The housekeeping information for TMALI CSC is provided in the TMALI_HK data structure.","663c1163-fd4e-35e2-abb6-4c47fc49bdd4":"To prevent the loss of error counts due to rollover, ccmErrEnq() ensures that the error count for a specific error does not exceed 250 within a single high-rate housekeeping reporting period. If the error count surpasses 250 during this period, ccmErrEnq() will enqueue an S_ccm_ERR_REPEAT error with the current error count and reset its error tracking system.","1c2e1322-c61a-31cf-9e15-8e3947ca0a16":"The Telescope Module Access Library and Interface (TMALI) CSC handles the management of the detector event queue and offers an API for data processing algorithms to retrieve detector events from the queue.","1e60d487-9892-3a18-a02b-4e5d7aa64259":"Public Functions: This routine is invoked by the MIL-STD-1553 Command ISR once per second (triggered by the arrival of the Clock Message) to signal the CCM Control Task to wake up, which remains blocked on a semaphore until its processing is completed.","e74f9800-7d16-3e6b-b471-427abfb20195":"The function retrieves housekeeping data for the TMALI CSC, including certain DCI parameters, and resets TMALI's internal counters to zero. If the provided pointer to a TMALI_HK structure is NULL, no data is returned, but the internal counters are still reset. Two of the four error counters are updated within an ISR context, requiring a task-switch-safe implementation. In VxWorks, this could use a counting semaphore, but the TMALI CSC design employs a faster approach with a free-running error counter and careful updating of the reported error count using a temporary variable. Since the increment and assignment of 32-bit unsigned integers are atomic operations, the counters are task-safe, ensuring no error events are missed. Thus, the total errors reported by the tmaliHkGet() function always match the actual number of errors, with no data loss during internal updates.","d6b7acb6-fab6-3142-a91d-709b94733e22":"The CCM Control task calls the ccmPerProcess() function during each execution to perform periodic processing tasks, which include updating analog to digital conversions, monitoring DPU tasks, generating ICU heartbeat messages, and strobing the watchdog. The ccmPerProcess() function invokes ccmHealthChk() to monitor the execution of other tasks by checking the elapsed time since each task last reported. Tasks report their activity to the CCM Control Task using the ccmTaskReport() function, providing their task index. Each task has a defined execution frequency, and any deviation results in an error being logged in DPU housekeeping. If the Command Dispatch Task fails to report for an extended duration, the DPU will reboot to ensure it remains controllable, otherwise, it will strobe the watchdog.","207c506d-8917-34dd-8465-51972c8f0d7c":"This function allows configuring DCI windowing parameters utilized in DCI data acquisition. Before instructing the DCI driver to adjust the DCI hardware windowing parameters, the specified window settings are validated. If the settings are invalid, the function returns an error, and the hardware windowing functionality is not enabled. The function both configures the specified hardware window settings and activates the hardware windowing feature.","0607f776-bfb5-30d9-8da4-255be7ea627c":"This function is used by any CSC to report errors or events that need to be included in DPU housekeeping. If called from an interrupt context, a static global variable, ccmISRError, is set to ensure the error can be added to the queue later (refer to ccmCtrlTask()), because the error/event queue is protected by a semaphore, which cannot be accessed in an ISR. To handle potential priority inversion issues, the semaphore for the error queue is configured with priority inversion handling. Additionally, the function substitutes frequently recurring errors with a special repeat error code, which is a unique code that follows a previously reported error to indicate that the same error has occurred multiple times within the last high-rate reporting period.","182934c6-09d7-31b0-a5df-fc581c7f1a81":"The function ccmErrEnq() can be called from an interrupt context, but using the mutual exclusion mechanism on the Error Queue is not possible in this context because taking a semaphore in an interrupt context is prohibited. To address this, the global variable ccmISRerror is assigned the relevant error code. This error will be added to the queue during the next execution of ccmTask(). However, since errors in interrupt context are managed in this way, multiple errors occurring before ccmTask() runs could result in overwriting previous errors with new ones, leading to potential loss of errors.","6c8b8d9e-3d7e-3d38-82cd-1e9d335fd296":"The TMALI CSC comprises the following elements:\n* A ring buffer-based queue, TMALI_EVENT_QUEUE, which stores detector events received through the data capture interface from the DCI Driver until they are retrieved by the DPA CSC.\n* An API enabling the DPA CSC to access detector events from the queue, including the functions tmaliNextEvent() and tmaliWait().\n* A set of API functions for configuring the DCI interface, including tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet(), and tmaliDataTimeoutGet().\n* A housekeeping API function, tmaliHkGet(), that collects CSC housekeeping data upon request from the Command and Control Task.\n* The tmaliTask() task functions in conjunction with the ISR tmaliTransferToQueueISR(), using a semaphore to coordinate the transfer of data from the DCI to the queue.\n* An error handling ISR, tmaliDciErrorReportedISR(), is registered as a hook routine with the DCI Driver and tracks the number of errors reported by the DCI Driver.","294a7051-ebd2-3120-95f0-4cc834f4b194":"This function retrieves the frame depth of the Ping-Pong buffers utilized by the DCI CSC. The frame depth specifies the number of frames loaded into the selected Ping-Pong buffer before triggering an interrupt. The initial frame depth value is set based on the parameter provided during the startup of the tmaliTask. The function returns the currently active frame depth value, which may differ from the previously commanded value, as the commanded value only takes effect when data is moved from the hardware Ping-Pong buffer to the TMALI queue in response to a frame interrupt or timeout, as described in section 5.13.2.3.","a26057b2-789e-3057-aa8a-a6628ac484fc":"When the tmaliTransferToQueueISR() ISR is triggered, it signals a semaphore to wake up the tmaliTask(), which is responsible for transferring data to the queue via the VME bus. The tmaliTask() utilizes the read() function from the DCI Driver, which performs the data transfer using a high-speed assembly routine. Since the TMALI ring buffer is structured as an array, the tmaliTask() must first check the TMALI_EVENT_QUEUE to determine whether data in the DCI buffer can be retrieved with a single read() operation or if two read() calls are required to handle cases where the buffer wraps around. Additionally, the tmaliTask() must verify that there is sufficient space to store all the data available in the Ping-Pong buffer. If there isn't enough space to accommodate the full set of frames, the entire contents of the readable Ping-Pong buffer are discarded, and the error S_TMALI_QUEUE_FULL is reported through the 'ccmErrEnq' mechanism. The discarded data always consists of an integral number of CCD frames, as the DCI hardware ensures Ping-Pong transitions align with CCD frame boundaries. This approach prioritizes retaining scientific data with higher value, assuming events captured immediately after a burst are more significant than those collected later.","3fedffab-ecd8-364a-8ef0-41e406f67349":"The ccmErrEnq() function monitors the most recently reported error and tracks how often it occurs. After an error code is reported, it is recorded as the last reported error by ccmErrEnq(), and a repetition counter is incremented for each subsequent consecutive occurrence of the same error. If this error is reported multiple times within a single high-rate housekeeping reporting period, a special error, S_ccm_ERR_REPEAT, is enqueued, with the repetition count embedded in its least significant byte. This approach helps prevent housekeeping telemetry from being overwhelmed by a single recurring error.","9094754e-cf4a-3fb7-8159-25d10c9e18ae":"The function ccmErrEnq() can be called from an interrupt context, but using the mutual exclusion mechanism on the Error Queue is not possible in this context because taking a semaphore in an interrupt context is prohibited. To address this, the global variable ccmISRerror is assigned the relevant error code. This error will be added to the queue during the next execution of ccmTask(). However, since errors in interrupt context are managed in this way, multiple errors occurring before ccmTask() runs could result in overwriting previous errors with new ones, leading to potential loss of errors.","7b1d1f25-6ff8-348c-b6bf-5f1705716a0f":"Data Upload and Download Management: Data can be uploaded to the DPU through two methods:  \n* Using the Memory Poke command (D_MEM_DAT_POKE), or  \n* Using the Memory Upload command (D_MEM_DAT_UPLD).  \nThe Memory Poke command is intended for inserting a small amount of data (up to Z bytes) into a specific DPU memory location. The Z-byte limit is determined by the command length restriction set by Company X.","a78cb0f7-4a56-315b-9707-9d1a999b9433":"The CCM Control Task is responsible for processing memory dump commands. When a data dump is requested, the CCM Control Task divides the dump into smaller, manageable segments and processes a portion each time the task is activated. This deferred approach prevents a large dump from monopolizing CPU resources and ensures the high-priority CCM Command Dispatch Task remains available.","13a33233-e355-37f6-af42-e3c52ef4a137":"The global data elements that this CSC interacts with.","abb354a7-50a8-3ce4-ba91-99c573f53939":"Public Functions When the TMALI queue has no data, this routine waits on a semaphore until events become available as signaled by the ISR. If data is already present in the TMALI queue or the semaphore is acquired, the function calculates and returns the number of events in the queue to the caller. The parameter 'TickstoWait' defines the maximum wait time for data availability in kernel ticks. This parameter can also be set to the symbolic value 'FOREVER,' causing the function to wait indefinitely until data is available. If a timeout value is provided and no data becomes available within the specified period, the function returns zero (indicating no events are available). If the tmali task has not been initialized, the function returns an error.","144eb452-93dc-337a-a715-b8f0f85648fe":"The DPU processes commands received through two interfaces: the MIL-STD-1553 interface from the Spacecraft and the SSI interface from the ICU. Commands to the DPU can originate from either the SCU or the ICU. The possible sources for a DPU command are as follows:  \n* ICU – the command is created and transmitted by the ICU via the SSI.  \n* SCU – the command is created and transmitted by the SCU via the 1553.  \n* G-ICU – the command is created on the ground and sent to the DPU via the ICU/SSI.  \n* G-SCU – the command is created on the ground and sent to the DPU via the SCU/1553.  ","47b32ee5-d3c0-3863-b2d3-2eabc3b0fd23":"At boot time, an error queue does not exist as it has not yet been initialized. Errors occurring during this initial phase are directly assigned to the global task variable errno. For more details on errno, refer to section 2.3.7 of the VxWorks® Programmer’s Guide. Once the error queues have been created, any value set in errno is added to the Error Queue using the ccmErrEnq() function.","00ea49ee-4bb7-391c-9764-6de09ffe3fae":"The DCI control/status register's bit arrangement can be configured using the tmaliBitArrangementSet() function.","ed97367d-60ae-37b7-a0bc-1d9d617425cc":"The TMALI CSC comprises the following elements:\n* A ring buffer-based queue, TMALI_EVENT_QUEUE, which stores detector events received through the data capture interface from the DCI Driver until they are retrieved by the DPA CSC.\n* An API enabling the DPA CSC to access detector events in the queue, including the functions tmaliNextEvent() and tmaliWait().\n* A set of API functions for configuring the DCI interface, including tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet(), and tmaliDataTimeoutGet().\n* A housekeeping API function, tmaliHkGet(), that collects CSC housekeeping data upon request from the Command and Control Task.\n* The tmaliTask() task functions in conjunction with the ISR tmaliTransferToQueueISR(), using a semaphore to coordinate the transfer of data from the DCI to the queue.\n* An error-handling ISR, tmaliDciErrorReportedISR(), registered as a hook routine with the DCI Driver, which monitors and tracks errors reported by the DCI Driver.","42e4ddf0-576a-3f3a-a5b2-5f6ae43043ad":"Data Upload and Download Management: Data can be uploaded to the DPU through two methods:  \n* Using the Memory Poke command (D_MEM_DAT_POKE), or  \n* Using the Memory Upload command (D_MEM_DAT_UPLD).  \nThe Memory Poke command is intended for inserting a small amount of data (up to Z bytes) into a specific DPU memory location. The Z byte limit is determined by the command length restriction set by Company X.","406d5983-3c5c-3633-9e68-6ca9d74eb433":"This function is used by any CSC to report errors or events that need to be included in DPU housekeeping. If called from an interrupt context, a static global variable, ccmISRError, is set to ensure the error can be added to the queue later (refer to ccmCtrlTask()), because the error/event queue is protected by a semaphore, which cannot be accessed in an ISR. To handle potential priority inversion issues, the semaphore for the error queue is configured with priority inversion handling. Additionally, the function substitutes frequently recurring errors with a special repeat error code, which is a unique code that follows a previously reported error to indicate that the same error has occurred multiple times within the last high-rate reporting period.","1ccc0f44-d7cb-363b-8daa-42c9cbda4e48":"When the tmaliTransferToQueueISR() ISR is triggered, it signals a semaphore to wake up the tmaliTask(), which is responsible for transferring data to the queue via the VME bus. The tmaliTask() utilizes the read() function from the DCI Driver, which performs the data transfer using a high-speed assembly routine. Since the TMALI ring buffer is structured as an array, the tmaliTask() must first check the TMALI_EVENT_QUEUE to determine whether data in the DCI buffer can be retrieved with a single read() operation or if two read() calls are required to handle cases where the buffer wraps around. Additionally, the tmaliTask() must verify that there is sufficient space to store all the data available in the Ping-Pong buffer. If adequate space is unavailable for all the frames, the entire content of the readable Ping-Pong buffer is discarded, and the error S_TMALI_QUEUE_FULL is reported using the ‘ccmErrEnq’ mechanism. The discarded data always consists of complete CCD frames, as the DCI hardware ensures Ping-Pong switches occur at CCD frame boundaries. This approach prioritizes retaining older data as it is considered scientifically more valuable than data collected later after a burst.","8315d7d9-f1bb-3a29-9bb0-7fb8f91034eb":"The CSC uses a FIFO ring buffer to temporarily store data from the DCI before processing. The ring buffer employs two pointers, pIn and pOut, to track the data within it. The pointers are designed so that checking if the buffer is empty requires only a single comparison, making data reading straightforward. Since the buffer exclusively stores Events, which are four-byte entities, the pointers reference these units. As all data from the DCI is in bytes, size conversions are necessary before reading the data.","5c6dd184-15cf-3b63-93e9-f88e90f97cbb":"To prevent the loss of error counts due to rollover, ccmErrEnq() ensures that the error count for a specific error does not exceed 250 within a single high-rate housekeeping reporting period. If the error count surpasses 250 during this period, ccmErrEnq() will enqueue the S_ccm_ERR_REPEAT error with the current error count and reset its error tracking system.","f7aecaad-eb17-33cc-b06c-313bb1c98153":"At boot time, an error queue does not exist as it has not yet been initialized. Errors occurring during this initial phase are directly assigned to the global task variable errno. For further details on errno, refer to section 2.3.7 of the VxWorks® Programmer’s Guide. Once the error queues have been created, any value set in errno is added to the Error Queue using the ccmErrEnq() function.","677acf9d-95cd-3d75-bbb8-108ae99ab505":"When a command is received from the SCU through the 1553 interface or from the ICU through the SSI interface, the corresponding ISR will add the command packet to a Command Queue and signal a semaphore to wake up the ccmCmdTask(). Since the DPU can issue commands to itself, commands may be received in either interrupt context or task context. To handle this, the CCM utilizes two separate queues: one for interrupt context that does not use semaphore protection and another for task context that is semaphore protected.","b1a3ea21-45cc-3752-9545-11b23346c0ed":"The error S_ccm_ERR_REPEAT stores the count of the most recently repeated error in its least significant byte. When a new error is reported, ccmErrEnq() will add an S_ccm_ERR_REPEAT to the queue for any previously repeated error, followed by the new error. To ensure that the original error codes and their repeat counts remain grouped in the same error packet, ccmMkHkErr() queues a special error code, S_ccm_ERRQ_FLUSH, as an indicator for ccmErrEnq() to reset its error tracking system and enqueue any repeat counts linked to a specific error.","64a62731-7b98-308a-8aa7-6280741deb37":"The error S_ccm_ERR_REPEAT stores the count of the most recently repeated error in its least significant byte. When a new error is reported, ccmErrEnq() will add an S_ccm_ERR_REPEAT to the queue for any previously repeated error, followed by the new error. To ensure that the original error codes and their repeat counts remain grouped in the same error packet, ccmMkHkErr() enqueues a special error code, S_ccm_ERRQ_FLUSH, signaling ccmErrEnq() to reset its error tracking system and queue any repeat counts associated with a specific error.","138ca949-ad6a-35d3-88a4-03abb0ff4794":"This function is invoked by the MIL-STD-1553 Command ISR and the SSI Interface ISR whenever a command is received from the SCU or ICU, to add the command to the queue and activate the CCM Command Dispatch Task for its execution.","16598da8-f59a-3689-9801-4c35905e8346":"The initialization of the TMALI CSC involves creating the tmaliTask() with the default startup parameters. This task is responsible for allocating memory for the TMALI_EVENT_QUEUE, setting up DCI ISRs, initializing static variables and data structures, and then entering an infinite loop where it manages data transfer from the DCI to the TMALI queue, controlled by the semaphore semDciWait.","77082507-d2bf-3ad7-9ba3-5eb3bc2e6228":"The DPU generates eight varieties of housekeeping packets.","d0ccf8ba-3a19-31ec-8ebd-f427be4c23a5":"This function allows retrieval of the current data timeout value utilized by the DCI. The returned value represents the timeout duration in milliseconds. Details regarding the timeout can be found in document 036911400, section 4.3.2.4.1.3.","f6d42825-93ff-3c93-97a7-34b7c8a6631b":"During normal operation, frames are received approximately every 11 milliseconds. The DCI hardware generates an interrupt when event data is available in one of the Ping-Pong buffers, and no additional events have been received for a configurable period of time. This data timeout interrupt is not considered an error but typically signifies the completion of the current exposure. It enables the TMALI CSC to retrieve the remaining events from the DCI Ping-Pong buffer. The API function tmaliDciTimeoutSet() allows the DCI Driver's timeout setting to be modified.","58f96747-3b38-3b87-b88e-6234010d52cb":"Data can be uploaded to various locations, including DRAM, EEPROM, hardware registers, and the EEPROM filesystem. The D_MEM_DAT_UPLD command designates the target location. If the target location is the EEPROM filesystem, a \"block number\" is provided instead of a memory address. The DPU FSW uses this block number to generate a filename in the format eefs1:DPU_blk.##, where ## represents the block number. Once all the data is uploaded to the DPU FSW, it is saved to the corresponding file in the EEPROM filesystem. If a file with the same name already exists, it will be overwritten. The EEPROM filesystem can be reinitialized using the D_MEM_DISK_INIT command.","71b2fd83-b042-33a9-ab42-cebec7d2b637":"This function allows configuring DCI windowing parameters utilized in DCI data acquisition. Before instructing the DCI driver to adjust the DCI hardware windowing parameters, the specified window settings are validated. If the settings are invalid, the function returns an error, and the hardware windowing functionality is not enabled. The function both configures the specified hardware window settings and activates the hardware windowing feature.","5530a803-f64e-34b4-9cd9-4dfc68f401d4":"The DPU generates eight varieties of housekeeping packets.","0206f39c-fe52-3c51-827b-55372a174fe0":"The CCM Control Task is responsible for processing memory dump commands. When a data dump is requested, the CCM Control Task divides the dump into smaller, manageable segments and processes a portion each time the task is activated. This deferred approach prevents a large dump from monopolizing CPU resources and ensures the high-priority CCM Command Dispatch Task remains free for other tasks.","b993686e-1a46-3ac5-b2a4-712e34d9774a":"After all events in the Ping-Pong buffer have been fully transferred to the TMALI_EVENT_QUEUE, the tamliTask() function must reset the hardware to prepare for swapping the Ping-Pong buffer when it becomes ready. If the transfer from the ping buffer is not completed before the pong buffer fills up, the DCI Driver will trigger an error interrupt, calling the tmaliDciErrorReportedISR(). This ISR will set an error flag to allow the tamliTask() to recover and will also signal the semDciWait semaphore to wake up the tamliTask(), even if it may already be active, as the error could occur right after the tmaliTask() finishes transferring data. The error will be logged in TMALI_HK. Meanwhile, the DCI hardware will discard new events until the tamliTask() finishes the current transfer, detects the error flag, manually forces a Ping-Pong buffer swap, and re-enables data acquisition. This ensures that only complete frames are retained in the Ping-Pong buffer for processing. In normal circumstances, this error should not occur because the tamliTask() should process data fast enough to empty the Ping-Pong buffer. When events are processed too slowly, the issue will manifest as a TMALI queue full condition, which is reported as an S_TMALI_QUEUE_FULL error through the ccmErrEnq() mechanism.","3d68bfa5-ad37-33b3-8672-d2ef50464c0f":"This function configures the frame depth of the Ping-Pong buffers used by the DCI CSC, determining how many frames are loaded into the selected buffer before triggering an interrupt. The initial frame depth is set based on the parameter provided when starting the tmaliTask. The maximum allowable frame depth is 64 frames, and any attempt to set a higher value will result in the timeout being set to the default value of V frames. The adjustment to the frame depth may be slightly delayed if there is ongoing activity on the DCI bus, typically occurring after the DCI has reported either a frame level reached or a timeout condition, to reduce the likelihood of altering the setting during critical hardware operations. Changing the frame depth while the DCI CSC is processing data may lead to unpredictable behavior. If a new 'tmaliDciFrameDepthSet' command is issued before the previous setting has taken effect, the new request will overwrite the previous one, and the DCI will apply the updated value as soon as possible.","9621ed45-dd12-3a6d-9aa1-db95b4b7fd0a":"If an upload requires more than 65,535 bytes, the file must be divided into smaller files, each no larger than 65,535 bytes, and sent sequentially. The DPU FSW can process individual upload commands even if they are received out of order due to sequence numbers. There is no time constraint for completing a single virtual upload, allowing long uploads to span multiple ground contacts. During an ongoing upload, the last sequence number can be requested from the DPU FSW, which will identify any missing sequence numbers via event number S_ccm_MISSING_SEQNO. If an ongoing upload needs to be terminated, it can be canceled by issuing the D_MEM_DAT_CNCL command.","e4f70e1e-8be1-335f-9425-6a23d4108324":"This function allows setting the data timeout value used by the DCI, specified in milliseconds. The initial frame depth timeout is determined by the parameter provided when starting the tmaliTask. The timeout can be set up to a maximum of X seconds, and any attempt to exceed this limit will result in the timeout being reset to the default value of X milliseconds.","a8c0bbd3-0871-3761-ae67-a8281a387eb3":"The TMALI CSC acts as an intermediary for managing EVENT data, which is provided by the DCI Driver CSC and eventually sent to the DPA CSC. TMALI waits for a signal from the DCI CSC indicating that a frame limit or data timeout has been reached in the Ping-Pong buffer, signifying the EVENT data is ready for processing. TMALI retrieves all EVENT data from the DCI and informs the DCI that it can swap the Ping-Pong buffers when ready. TMALI then provides a semaphore to unblock the tmaliWait() call from the DPA.","f9265c63-7317-3874-a3cd-483e6e041dd8":"The DPA CSC invokes tmaliWait() to check the number of EVENTs available to be read. If tmaliWait() returns a value greater than zero, the DPA uses tmaliNextEvent() to retrieve each available EVENT.","c8b8bfe7-d485-3f2e-953b-5a26844e7342":"Events are retrieved from the TMALI_EVENT_QUEUE by the DPA CSC through an API with two functions: tmaliWait() and tmaliNextEvent(). To ensure efficiency, the following points apply to API usage:\n- The DPA CSC will embed the tmaliNextEvent() function directly to eliminate the overhead of a function call for each event.\n- Each event retrieved will be stored in a register by the DPA CSC, and the processing of that event will be completed while it remains in the register before the next event is retrieved.\n- The tmaliNextEvent() function does not perform error checking to maintain maximum efficiency, so the DPA CSC must monitor the number of events retrieved compared to the number provided by tmaliWait().","340fcf1b-3d14-3f79-8893-b8ce71433765":"The DPU-CCM CSC includes a centralized error reporting function, ccmErrEnq(), which other FSW tasks utilize to log errors. On wake-up, ccmTask() verifies whether it is time to generate an error/event packet for ground transmission. If necessary, ccmTask() invokes ccmHkMkError() to create the packet and send it to DPU-SCUI for transmission to the ground.","5ddca483-5b28-3e2a-aeec-a06fed997884":"For larger memory uploads to the DPU, such as software patches or complete software uploads, the standard memory upload process is utilized. This process involves sending multiple D_MEM_DAT_UPLD commands, collectively forming a single \"virtual\" upload. CCSDS-like sequence flags are used to enable the DPU firmware to handle a maximum of 65535 bytes in one \"virtual\" upload. Data from each D_MEM_DAT_UPLD command is stored in a temporary DRAM buffer until all sequence numbers for the entire upload are received. Once the final command in the sequence is received, the DPU firmware verifies the reception of all sequence numbers, checks the end-to-end upload checksum, and writes the entire temporary buffer to the target location specified in the first upload command.","952110df-29a7-3265-8d24-e7cad92f15c7":"The Command and Control CSC is initialized by creating the CCM Control Task, ccmCtrlTask(), from the operating system’s startup task, usrRoot(). Once created, it executes the ccmInit() function, which sets up the error/event queue, creates necessary semaphores, and configures various ISRs. It also spawns the remaining tasks that make up the DPU flight software. During startup, the CCM Control Task retrieves the default DPU configuration from the SYSTEM_CONFIG_AREA in EEPROM. If the checksum of the SYSTEM_CONFIG_AREA is invalid, hardcoded defaults are used. Initialization of other CSCs is performed by the CCM Control Task, either by directly calling their initialization functions or by spawning their associated tasks using the VxWorks® taskSpawn() function. When initializing a CSC, it passes the startup defaults retrieved from EEPROM to the initialization function as parameters. Additionally, the ccmInit() function initializes the command length verification table via ccmCmdLengthInit(), which the command processor uses to validate the lengths of received commands.","ca2836cb-29de-39a7-898b-ea1e69059578":"During normal operation, frames are received approximately every 11 milliseconds. The DCI hardware generates an interrupt when event data is available in one of the Ping-Pong buffers, and no additional events have been received for a configurable period of time. This data timeout interrupt is not considered an error but typically signifies the completion of the current exposure. It enables the TMALI CSC to retrieve the remaining events from the DCI Ping-Pong buffer. The API function tmaliDciTimeoutSet() allows the DCI Driver's timeout setting to be modified.","f018e08c-525d-3557-a377-b316b27047ab":"At boot time, an error queue does not exist as it has not yet been initialized. Errors occurring during this initial phase are directly assigned to the global task variable errno. For more details on errno, refer to section 2.3.7 of the VxWorks® Programmer’s Guide. Once the error queues have been created, any value set in errno is added to the Error Queue using the ccmErrEnq() function.","bcc0333b-e0d8-3b5c-a2ee-2b6503dfde4c":"During initialization, the TMALI CSC sets up an ISR hook function, tmaliTransferToQueueISR(), in the DCI Driver, which is triggered when either of the following occurs:\n* the DCI interface hits the configured frame threshold in the Ping-Pong buffer, or\n* the DCI interface identifies a data reception timeout.","5cd610f3-dc90-3662-ab7e-70f344bc19c1":"During normal operation, frames are received approximately every 11 milliseconds. The DCI hardware generates an interrupt when event data is available in one of the Ping-Pong buffers, and no additional events have been received for a configurable period of time. This data timeout interrupt is not considered an error but typically signifies the completion of the current exposure. It enables the TMALI CSC to retrieve the remaining events from the DCI Ping-Pong buffer. The API function tmaliDciTimeoutSet() allows the DCI Driver's timeout setting to be modified.","3d3c847c-86be-31b8-a857-0d109e53fa2d":"During initialization, the TMALI CSC sets up an ISR hook function, tmaliTransferToQueueISR(), in the DCI Driver, which is triggered when either the DCI interface hits the configured frame limit in the Ping-Pong buffer or a data receipt timeout is detected by the DCI interface.","662b5d71-25bc-37bf-a61b-37b2c585d794":"Public Functions: This routine waits on a semaphore when no data is present in the TMALI queue, blocking until events are available as signaled by the ISR. If data is already in the TMALI queue or the semaphore is acquired, the function determines and returns the number of events in the queue to the caller. The 'TickstoWait' parameter defines the maximum wait time in kernel ticks for data to become available. Setting this parameter to the symbolic value 'FOREVER' makes the function wait indefinitely until data is available. If a timeout is specified and no data is received within the allotted time, the function returns zero (indicating no events are available). If the tmali task has not been initialized, the function returns an error.","f7723ed1-c1e3-32e4-80c5-68be98104d52":"This function is used by any CSC to report errors or events that need to be included in DPU housekeeping. If called from an interrupt context, a static global variable, ccmISRError, is set to ensure the error can be added to the queue later (refer to ccmCtrlTask()), because the error/event queue is protected by a semaphore, which cannot be accessed in an ISR. To handle potential priority inversion issues, the semaphore for the error queue is configured with priority inversion handling. Additionally, the function substitutes frequently recurring errors with a special repeat error code, which is a unique code that follows a previously reported error to indicate that the same error has occurred multiple times within the last high-rate reporting period.","4cefbc60-9714-3794-821a-983469298eab":"The TMALI CSC comprises the following elements:\n* A ring buffer-based queue, TMALI_EVENT_QUEUE, which stores detector events received through the data capture interface from the DCI Driver until they are retrieved by the DPA CSC.\n* An API enabling the DPA CSC to access detector events in the queue, including the functions tmaliNextEvent() and tmaliWait().\n* A set of API functions for configuring the DCI interface, including tmaliBitArrangementSet(), tmaliDciFrameDepthGet(), tmaliDciFrameDepthSet(), tmaliDciWindowSet(), tmaliDataTimeoutSet(), and tmaliDataTimeoutGet().\n* A housekeeping API function, tmaliHkGet(), that collects CSC housekeeping data upon request from the Command and Control Task.\n* The tmaliTask() task functions in conjunction with the ISR tmaliTransferToQueueISR(), using a semaphore to coordinate the transfer of data from the DCI to the queue.\n* An error handling ISR, tmaliDciErrorReportedISR(), is registered as a hook routine with the DCI Driver and tracks errors reported by the DCI driver.","4f6fb9a6-44f5-325e-8080-636c41718181":"The DPU processes commands received through two interfaces: the MIL-STD-1553 interface from the Spacecraft and the SSI interface from the ICU. Commands to the DPU can originate from either the SCU or the ICU. The possible sources for a DPU command are as follows:  \n* ICU – the command is created and transmitted by the ICU via the SSI.  \n* SCU – the command is created and transmitted by the SCU via the 1553.  \n* G-ICU – the command is created on the ground and sent to the DPU via the ICU/SSI.  \n* G-SCU – the command is created on the ground and sent to the DPU via the SCU/1553.  ","69251ec5-bee9-31c3-94c5-4cda07e3e0b9":"For larger memory uploads to the DPU, such as software patches or complete software uploads, the standard memory upload process is utilized. This process involves sending multiple D_MEM_DAT_UPLD commands, collectively forming a single \"virtual\" upload. CCSDS-like sequence flags are used to enable the DPU firmware to handle a maximum of 65535 bytes in one \"virtual\" upload. Data from each D_MEM_DAT_UPLD command is stored in a temporary DRAM buffer until all sequence numbers for the entire upload are received. Once the final command in the sequence is received, the DPU firmware verifies the reception of all sequence numbers, checks the end-to-end upload checksum, and writes the entire temporary buffer to the target location specified in the first upload command.","cba4501b-afd7-3efb-a398-b140529b1ff0":"Public Functions: This routine waits on a semaphore when no data is present in the TMALI queue, blocking until events are available as signaled by the ISR. If data is already in the TMALI queue or the semaphore is acquired, the function determines and returns the number of events in the queue to the caller. The 'TickstoWait' parameter defines the maximum wait time in kernel ticks for data to become available. Setting this parameter to the symbolic value 'FOREVER' causes the function to wait indefinitely until data is available. If a timeout value is specified and no data becomes available within that period, the function returns zero (indicating no events available). If the TMALI task has not been initialized, the function returns an error.","98992ace-c8ef-3eb3-a46d-b1fef3c7f1d8":"The DPA CSC invokes tmaliWait() to check the number of EVENTs available to be read. If tmaliWait() returns a value greater than zero, the DPA uses tmaliNextEvent() to retrieve each available EVENT.","f9dfa81c-73bc-321e-8aa5-ec962c36c703":"The Telescope Module Access Library and Interface (TMALI) CSC handles the management of the detector event queue and offers an API for data processing algorithms to access detector events from the queue.","7cf578ce-6a0d-341d-a1f8-5ec45d9ecfd5":"The ring buffer data structure defines the pIn and pOut pointers as follows:  \n* pIn - the most recent location where data was stored.  \n* pOut - the most recent location that was emptied.  ","5b08dde6-f7a9-3837-a419-393fc4a10be3":"Ring buffer data structure: The pIn and pOut pointers are described as follows:  \n* pIn - the most recent location where data was written.  \n* pOut - the most recent location that was emptied.","2b53e58b-b3d9-3029-bc71-b192e31f298a":"The ring buffer data structure uses a pointer, pEnd, to mark the last available position in the buffer. Before moving any pointer, it must be checked if it is at the last position; if so, the pointer is reset to the start of the buffer, denoted by pBuf. Otherwise, the pointer can simply be incremented.","51d70ac6-c190-314f-99a9-d33b0c7261f7":"This function configures the frame depth of the Ping-Pong buffers used by the DCI CSC, determining how many frames are loaded into the selected buffer before triggering an interrupt. The initial frame depth is set based on the parameter provided when starting the tmaliTask. The maximum allowable frame depth is 64 frames, and any attempt to set a higher value will result in the timeout being set to the default value of V frames. Adjusting the frame depth may be slightly delayed if there is active communication on the DCI bus and typically occurs when the DCI has just reported a frame level reached or timeout condition, reducing the risk of conflicts during frame detection. Modifying the frame depth while the DCI CSC is processing data may lead to unpredictable behavior. If a new 'tmaliDciFrameDepthSet' command is issued before the previous command takes effect, the new request will overwrite the earlier one, and the DCI will adjust to the updated value at the next available opportunity.","7be33dd4-f6b4-31fd-9586-81606064efe7":"To prevent the loss of error counts due to rollover, ccmErrEnq() ensures that the error count for a specific error does not exceed 250 within a single high-rate housekeeping reporting period. If the error count surpasses 250 during this period, ccmErrEnq() will enqueue an S_ccm_ERR_REPEAT error with the current error count and reset its error tracking system.","035ea18e-468f-3a98-b85d-561cec40ce84":"The function ccmErrEnq() can be called from an interrupt context, but using the mutual exclusion mechanism on the Error Queue is not possible in this context since taking a semaphore in an interrupt context is prohibited. To address this, the global variable ccmISRerror is assigned the corresponding error code. This error will be added to the queue during the next execution of ccmTask(). However, since errors in interrupt context are managed in this way, multiple errors occurring before ccmTask() runs could result in overwriting previous errors with new ones, leading to potential loss of errors.","ced8ead4-8286-3925-95b8-15e3287635d3":"This function allows configuring DCI windowing parameters utilized in DCI data acquisition. Before instructing the DCI driver to adjust the DCI hardware windowing parameters, the specified window settings are validated. If the settings are invalid, the function returns an error, and the hardware windowing functionality is not enabled. The function sets the desired hardware window specification and activates the hardware windowing feature.","0f933526-af70-33ce-b341-7b55f7235f97":"The Command and Control (CCM) CSC, a Level 2 reusable component derived from the INSTRUMENT Y project, consists of the following elements:  \n- A Control Task, ccmCtrlTask(), responsible for initializing the DPU flight software (FSW), creating tasks during system boot, managing the generation of housekeeping data packets from the DPU, supervising task execution, and scheduling periodic tasks such as the heartbeat message and watchdog strobe.  \n- A Command Dispatch Task, ccmCmdTask(), that handles the reception and processing of real-time commands from the SCU or ICU.\n\nKey data structures include:  \n- A Static Data table that records the operational state, containing housekeeping production rates, specific CCM flags, and the count of executed commands.  \n- A Command Queue to store incoming commands, which are received via interrupt from either the ICU or SCU.  \n- An Error/Event Queue that gathers error and event codes generated by the DPU FSW. These codes are later retrieved, included in telemetry packets at defined intervals, and incorporated into DPU housekeeping data.","97c6dc14-862c-30cd-beba-b9c88ae2133a":"The Command and Control CSC is initialized by creating the CCM Control Task, ccmCtrlTask(), from the operating system’s startup task, usrRoot(). Once created, the task executes ccmInit(), which sets up the error/event queue, creates necessary semaphores, and sets up various ISRs. It then launches the other tasks that make up the DPU flight software. Upon starting, the CCM Control Task retrieves default startup configurations for the DPU from the SYSTEM_CONFIG_AREA in EEPROM. If the checksum in the SYSTEM_CONFIG_AREA is invalid, hardcoded defaults are used. The CCM Control Task initializes the other CSCs by either calling their initialization functions or spawning their associated tasks using the VxWorks® taskSpawn() function. The default startup configurations read from EEPROM are provided as parameters during these initializations. Additionally, ccmInit() constructs the command length verification table by calling ccmCmdLengthInit(), which the command processor uses to verify the expected lengths of newly received commands.","25d78690-834b-3a98-9beb-4f977ccc3125":"Ring buffer data structure: The pIn and pOut pointers are defined as follows:  \n* pIn - the most recent location where data was written.  \n* pOut - the most recent location that was emptied.  ","42a80079-ccba-3a00-8019-40a4a59a0c29":"A ring buffer data structure is defined as follows:  \n* Management is straightforward, but one position in the buffer remains unused when it is full, with the pIn pointer being just behind the pOut pointer.  \n* The buffer is empty when the pIn pointer and the pOut pointer are at the same position.","fbef9dee-4240-3746-a8e1-dd47c0c8e4d1":"This function allows configuring the bit arrangement used by the DCI. When bSpecialArrangement is set to TRUE, the DCI operates in special bit arrangement mode; otherwise, it defaults to normal mode with no rearrangement.","a5e45f42-01ea-345f-911e-6230799a5dac":"Each DPU FSW task invokes this function to indicate its execution, enabling ccmCtrlTask() to evaluate the health of the DPU FSW operation.","f3fddda1-3520-3ec2-9e6e-41c9753ca5f5":"During initialization, the TMALI CSC sets up an ISR hook function, tmaliTransferToQueueISR(), in the DCI Driver, which is triggered when either the DCI interface hits the configured frame limit in the Ping-Pong buffer or a data receipt timeout is detected by the DCI interface.","585dfbc2-30a4-37fb-9116-efe4efce2f3d":"The TMALI CSC gathers housekeeping data, which can be accessed through a call to tmaliHkGet(). The TMALI CSC housekeeping data is provided using the TMALI_HK data structure.","45dbc082-65e0-3758-ac9c-ec46d159ae10":"The error S_ccm_ERR_REPEAT stores the count of the most recently repeated error in its lowest byte. When a new error is reported as described earlier, ccmErrEnq() will queue an S_ccm_ERR_REPEAT for any previously repeated error, along with the newly reported error. To ensure that the original error codes and their repeat counts remain grouped in the same error packet, ccmMkHkErr() queues a special error code, S_ccm_ERRQ_FLUSH, as an indicator for ccmErrEnq() to reset its error tracking system and enqueue any repeat counts linked to a specific error.","6e194a13-5063-3e26-a2c8-91261c27e517":"The Command and Control (CCM) CSC, a Level 2 reusable component derived from the INSTRUMENT Y project, consists of the following elements:  \n- A Control Task, ccmCtrlTask(), responsible for initializing the DPU flight software (FSW), creating tasks during system bootup, scheduling DPU housekeeping data packet generation, supervising task execution, and managing the periodic execution of tasks like the heartbeat message and watchdog strobe.  \n- A Command Dispatch Task, ccmCmdTask(), designed to receive and process real-time commands from the SCU or ICU.\n\nKey data structures include:  \n- A Static Data table that tracks operational states, including housekeeping production rates, CCM-specific flags, and the count of executed commands.  \n- A Command Queue that temporarily stores incoming commands received from the SCU or ICU via interrupts.  \n- An Error/Event Queue that gathers error and event codes reported by the DPU FSW, which are later transferred into telemetry packets at regular intervals and included in DPU housekeeping data.","17cf5d55-03c7-3011-b7d7-1072b40292c4":"The CCM Control Task is responsible for initializing the DPU FSW and ensuring a successful boot. It achieves this by waiting on temporary semaphores with a 5-second timeout after starting the SCU Interface Task and the CCM Command Task. If both tasks signal successful initialization by releasing their semaphores, the CCM Control Task updates the BC_INDEX parameter in EEPROM to confirm the successful boot. If either task fails to initialize successfully, the CCM Control Task disables the watchdog strobe to trigger a DPU reboot. These two tasks' successful initialization is considered essential for a successful boot as they are required to establish ground contact and enable commandability for the DPU FSW. Once the initialization is done, the CCM Control Task waits on a binary semaphore, triggered by the SCUI Command ISR upon receiving the 1 Hz Clock Message. If no Clock Message is received, the semaphore times out after 1.5 seconds. The CCM Control Task continues to run, handling DPU housekeeping at set intervals, performing periodic tasks, and managing memory dump commands. It also calls ccmErrEnq() as the final step, ensuring that any error occurring in an interrupt service routine sets a global variable with the error number, which is then queued into the Error/Event Queue during normal task operations.","db03215f-e926-3451-ab93-f2a59e4fbc72":"When a command is received from the SCU through the 1553 interface or from the ICU through the SSI interface, the corresponding ISR will add the command packet to a Command Queue and signal a semaphore to wake up the ccmCmdTask(). Since the DPU can issue commands to itself, commands may be received in either interrupt context or task context. To handle this, the CCM utilizes two separate queues: one for interrupt context that does not use semaphore protection and another for task context that is semaphore protected.","8f72cbad-3883-33f5-b620-a78aa57d7f4e":"Determining Frame Depth in DCI: Benchmark testing will establish the optimal frame depth. The default frame depth is set to 10 frames, and based on the provided data, reading 10 maximum-sized frames at the highest data transfer rate will take about 24 milliseconds.","25644cd6-30ef-3273-b131-b348e228ceb4":"Ring buffer data structure:  \n* Management is straightforward, but one buffer slot is sacrificed in the full state, where the pIn pointer is one position behind the pOut pointer.  \n* The buffer is empty when the pIn pointer is equal to the pOut pointer.","91c7dd15-734b-3b72-8139-25084df788a5":"The CSC uses a FIFO ring buffer to temporarily store data from the DCI before processing. The ring buffer employs two pointers, pIn and pOut, to track the data within it. The pointers are designed so that checking if the buffer is empty requires only a single comparison, making data reading straightforward. Since the buffer exclusively stores Events, which are four-byte entities, the pointers reference these units. As all data from the DCI is in bytes, size conversions are necessary before reading the data.","f5a229cf-46ad-38fd-91fb-731287c46123":"This function allows retrieval of the current data timeout value utilized by the DCI. The returned value represents the timeout duration in milliseconds, as described in document 036911400, section 4.3.2.4.1.3.","e8e16ca3-c084-384b-9315-49d36cfa4a5e":"When the tmaliTransferToQueueISR() ISR is triggered, it signals a semaphore to wake up the tmaliTask(), which is responsible for transferring data to the queue via the VME bus. The tmaliTask() utilizes the read() function from the DCI Driver, which performs the data transfer using a high-speed assembly routine. Since the TMALI ring buffer is structured as an array, the tmaliTask() must first check the TMALI_EVENT_QUEUE to determine whether data in the DCI buffer can be retrieved with a single read() operation or if two read() calls are required to handle cases where the buffer wraps around. Additionally, the tmaliTask() must verify that there is sufficient space to store all the data available in the Ping-Pong buffer. If there isn't enough space to accommodate the full set of frames, the entire contents of the readable Ping-Pong buffer are discarded, and the error S_TMALI_QUEUE_FULL is reported through the 'ccmErrEnq' mechanism. The discarded data always consists of an integral number of CCD frames, as the DCI hardware ensures Ping-Pong transitions align with CCD frame boundaries. This approach prioritizes retaining scientific data collected immediately after a burst, which is considered more valuable than data collected later.","a98d05f0-94b8-3ed9-95f7-3f6754a8133b":"The D_MEM_BLK_DNLD command facilitates downloading data from a file stored in the EEPROM filesystem. Similar to the upload command, only the block number is required, and the file corresponding to that block number will be entirely downloaded. For downloading data from sources outside the EEPROM filesystem, the D_MEM_DAT_DNLD command is used. As previously mentioned, downloads are processed in a deferred manner to minimize CPU usage. A single download operation will appear on the ground as multiple download packets, which must be extracted and combined to reconstruct the original data sequence.","f4fd0784-28c4-3aed-ab43-00450a6c5a64":"The ring buffer data structure uses a pointer, pEnd, to mark the last available position in the buffer. Before moving any pointer, it must be checked if it is at the last position; if so, the pointer is reset to the start of the buffer, indicated by pBuf. Otherwise, the pointer is incremented.","b9ff6f1c-154a-3a82-b7b9-c8f0b5f886cc":"The TMALI CSC gathers housekeeping data, which can be accessed through the tmaliHkGet() function. The housekeeping data for TMALI CSC is provided using the TMALI_HK data structure.","bc4861a9-1d9d-3ab2-9857-d17176bfac3a":"A ring buffer data structure is defined as follows:  \n* Management is straightforward, but one position in the buffer remains unused when it is full, with the pIn pointer being just behind the pOut pointer.  \n* The buffer is empty when the pIn pointer and the pOut pointer are at the same position.","d95c7cab-7815-31b3-a6e4-3c31afa2baad":"The ring buffer data structure uses a pointer, pEnd, to mark the last available position in the buffer. Before moving any pointer, it must be checked if it is at the last position; if so, the pointer should be reset to the buffer's starting position, indicated by pBuf. Otherwise, the pointer can simply be incremented.","35648906-88dd-37b6-b898-9ace097dcebe":"The hardware windowing feature of the DCI can be enabled and managed using tmaliDciWindowSet(). This function enables the hardware windowing feature and communicates the designated window parameters to the DCI driver.","78919754-9dba-38c5-b5ba-a65b2059127b":"The DPU-CCM CSC includes a centralized error reporting function, ccmErrEnq(), which other FSW tasks utilize to log errors. On wake-up, ccmTask() verifies whether it is time to generate an error/event packet for ground transmission. If necessary, ccmTask() invokes ccmHkMkError() to create the packet and send it to DPU-SCUI for transmission to the ground."}